[{"title":"HTTP2 的深入探究","date":"2018-07-01T03:24:00.000Z","path":"posts/4a24537/","text":"内容参考自《HTTP2 基础教程》整理 web 优化当前性能挑战 发布现代 Web 页面或 Web 应用绝不是一件小事。每个页面会引用数百个对象， 关联十多个域名，网络环境相差迥异，设备的处理能力也参差不齐。在这样的前提下，提供表现一致且响应迅速的 Web 体验并不简单。如果要保证用户在网站上的交互流畅，就必须重视理解客户端获取 Web 页面和渲染的步骤，以及各个步骤要面临的挑战。理解了它们，就能理解椎动 HTTP/2 的力量，也能理解其新特性相对 HTTP/1 都带来哪些益处。 剖析 Web 页面请求用户在浏览器中点击链接到页面呈现在屏幕上，在此期间到底发生了什么? 我们把这一过程分成两部分: 资源获取 页面解析/渲染 资源获取 把待请求 URL 放入队列 解析 URL 中域名的 IP 地址(A) 建立与目标主机的 TCP 连接(B) 如果是 HTTPS 请求，初始化并完成 TLS 握手(C) 向页面对应的 URL 发送请求。 页面解析/渲染 接收响应: 如果(接收的)是主体 HTML，那么解析它，并针对页面中的资源触发优先获取机制(A) 如果页面上的关键资源已经接收到，就开始渲染页面(B) 接收其他资橱，继续解析渲染，直到结束(C)。 页面上的每 一 次点击，都需要重复执行前面那些流程，给网络带宽和设备资源带来压力。 Web 性能优化的的核心，就是加快甚至干脆去掉其中的某些步骤。 关键性能指标从上面的图中，我们能找到影响 Web 性能的端点，以及能动手改进的地方。 延迟：IP 数据包从一个网络端点到另一个网络端点所花费的时间 带宽：只要带宽没有饱和，两个网络端点之间的连接会一次处理尽可能多的数据量。 DNS 查询：通过域名系统(DNS)把主机名称转换成 IP 地址 建立连接时间：客户端和服务器之间建立连接需要往返数据应答，称为“三次握手”。 TLS 协商时间：如果客户端发起 HTTPS 连接，它还需要进行传输层安全协议(TLS)协商; 目前为止，客户端还没有真正发起 HTTP 请求，却已经用掉了 DNS 查询的往返时间，以及 TCP 和 TLS 的耗时。下面的指标严重依赖于页面内容本身或服务器性能，而不是网络。 首字节时间 (TTFB)：TTFB 是指客户端从开始定位到 Web 页面，至接收到主体页面响应的第一字节所耗费的时间。 内容下载时间：等同于被请求资糠的最后字节到达时间( TTLB )。 开始渲染时间：客户端的屏幕上什么时候开始显示内容?这个指标测量的是白屏时间。 文档加载完成时间(又叫页面加载时间)：客户端浏览器认为页面加载完毕的时间。 Web 性能的最佳实践 DNS 查询优化 限制不同域名的数量：当然，这通常不是你能控制的;但是如果准备迁移到 HTTP/2,域名数量对性能的相对影响会只增不减。 保证低限度的解析延迟 在主体页面 HTML 或响应中利用 DNS 预取指令 &lt;link rel=”dns-prefetch” href=”//ajax.googleapls .com〉 优化 TCP 连接 利用 preconnect 指令 &lt;link rel=”preconnect” href=”//fonts.example.com\" crossorigin> 尽早终止井响应。 实施最新的 TLS 最佳实践来优化 HTTPS。 避免重定向 如果它们不能被直接消灭，你还有两个选择: 利用 CDN 代替客户端在云端实现重定向 如果是同一域名的重定向，使用 Web 服务器上的 rewrite 规则，避免重定向。 客户端缓存 所谓的纯静态内容，例如图片或带版本的数据，可以在客户端永久缓存。 CSS/JS 和个性化资源，缓存时间大约是会话(交互)平均时间的两倍。 网络边缘的缓存 条件缓存：当资服不经常变化时，使用条件请求可以显著节省带宽和性能。但是，保证资源的最新版迅速可用也是非常重要的。使用条件缓存可以通过以下方法。 在请求中包含 HTTP 首部 Last-Modified-Since，仅当内容在指定时间之后被更新过，服务器才返回完整内容;否则只返回 304 响应码，并在响应首部中附带上新 的时间戳 Date 字段。 在请求体中包含实体校验码，或者叫 ETag：ETag 由服务器提供，内嵌于资源的响应首部中。服务器会比较当前 ETag 与请求首部中收到的 ETag, 如果一致，就只返回 304 晌应码:否则返回完整内容。 压缩和代码极简化：常规的压缩算法包括 gzip 和 deflate;相对晚些面世的 Brotli 算曲也开始崭露头角了。 避免阻塞 CSS/JS 如果 JS 执行顺序无关紧要，并且必须在 onload 事件触发之前运行，那么可以设置 async 属性。&lt;script async src=”/js/MyfHe.js\"> 如果 JS 执行顺序很重要，并且你也能承受脚本在 DOM 加载完之后运行，那么请使用 defer 属性。&lt;script defer src=”/js/MyfHe.js\"> 如果你不想延迟主页面的 onload 事件，可以考虑通过 iframe 获取 JS，因为它的处理独立于主页面。 但是，通过 iframe 下载的 JS 访问不了主页面上的元素。 图片优化 图片元信息 图片过载：图片最终被浏览器自动缩小，要么因为原始尺寸超过了浏览器可视区中的占位大小，要么因为像素超过设备的显示能力。这不仅浪费带宽，消耗的 CPU 资源也很可观 反模式 HTTP/2 对每个域名只会开启一个连接，所以 HTTP/1.1 下的一些诀窍对它来说只会适得其反。接下来讨论几个如今流行却不再适用于 HTTP/2 站点的做法。 生成精灵图和资源合并/内联：HTTP/2 中，针对特定资原的请求不再是阻塞式的，很多请求可以井行处理; 于是就性能而言，生成精灵图就失去意义了。 域名拆分：利用浏览器针对每个域名开启多个连接的能力来井行下载资源。 禁用 cookie 的域名：在 HTTP/1 下，请求和响应首部从不会被压缩。因此，对图片之类不依赖于 cookie 的资源，设置禁用 cookie 的域名是个合理的建议。但是 HTTP/2 中，首都是被压缩的，并且客户端和服务器都会保留“首部历史”，避免重复传输巳知信息。所以，如果你要重构站点，大可不必考虑禁用 cookie 的域 名 ，这样能减少很多包袱。 静态资源也应该从同一域名提供;使用与主页面 HTTP 相同的域名， 消除了额外的 DNS 查询以及(潜在的) socket 连接，它们都会减慢静态资源的获取。把阻塞渲染的资源放在同样的域名下，也可以提升性能。 HTTP/2 迁移升级到 HTIP/2 之前，你应该考虑如下方面: 浏览器对旧的支持情况 迁移到 TLS (HTTPS)的可能性 对你的网站做基于 h2 的优化(可能对 HTTP/1 有反作用) 网站上的第三方资源 保持对低版本客户端的兼容 撤销针对 HTTP/1.1 的“优化”Web 开发者之前花费了大量心血来充分使用 hl，并且已经总结了一些诀窍，例如资源合井、域名拆分、极简化、 禁用 cookie 的域名、生成精灵图，等等。所以，当得知这些实践中有些在 h2 下变成反模式时，你可能会感到吃惊。例如，资掘合并(把很多 css 或 JavaScript 文件拼 合成一个)能避免浏览器发出多个请求。对 hl 而言这很重要，因为发起请求的代价很高 ;但是在 h2 的世界里 ，这部分已经做了深度优化。放弃资源合并的结果可能是，针对单个资源发起请求的代价很低 ，但浏览器端可以进行更细粒度的缓存。 要不要进行域名拆分 HTIP/2 的设计思路是尽量在单个 TCP/IP socket 上通信 。 它的做法是，开启一个 socket，并以最理想的拥塞速率运行，这样比起协调多个 socket 更可靠也更高效。尽管如此， Akamai 的 Foundry 团队的研究表明，这种策略并不总是有效。取决于网站的具体情况，多个 socket 可能优于单个 socket。 它直接依赖于 TCP 拥塞控制的运作方式，以及达到最优设置所需的时间。设直较大的初始拥塞窗口值可以缓解此问题;但是如采这些较大的位无法由通信链路支持，那么也会产生问题。 第三方资源由于有第三方资源的存在，而且会拖累 HTTP/2 带来的任何可能的 性能优化。如果你使用的第三方资源不支持 HTTPS，那就更麻烦了，解决这类问题可以从下列问题开始。 用到的第三方资源支持 HTTPS 吗? 它们是否计划支持 HTTP/2 ? 它们是否意识到，自己应当尽可能降低所提供的资源对页面性能的影响，并将其视为关键任务? HTTP/2 协议HTTP/2 分层HTTP/2 大致可以分为两部分: 分帧层：即 h2 多路复用能力的核心部分; 它的目的是传输 HTTP，而不是其他。 基于帧的二进制协议。这方便了机器解析。 首部压缩：仅仅使用二进制协议似乎还不够， h2 的首部还会被深度压缩。这将显著减少传输中的冗余字节。 多路复用 加密传输 数据或 http 层：其中包含传统上被认为是 HTTP 及其关联数据的部分。 可以向后兼容 HTTP/1.1，对于熟悉 h1 并习惯于阅读线上协议的开发者来说，还有些地方需要重新确认。 连接 连接是所有 HTTP/2 会话的基础元素，其定义是客户端初始化的一个 TCP/IP socket，客户端是指发送 HTTP 请求的实体。 这和 h1 是一样的，不过与完全无状态的 h1 不同的是，h2 把 它所承载的帧和流共同依赖的连接层元素捆绑在一起，其中既包含连 接层设置也包含首部表。也就是说，与之前的 HTTP 版本不同，每个 h2 连接都有一定的开销。之所以这么设计，是考虑到收益远远超过其开销。 是否支持 h2HTTP/2 提供两种协议发现的机制。 在连接不加密的情况下 ，客户端会利用 Upgrade 首部来表明期望使用 h2。 如果服务器也可以支持 h2，它会返回一个“ 101 Switching Protocols&quot; (协议转换)响应。这增加了一轮完整的请求-响应通信。如果连接基于 TLS，客户端在 ClientHello 消息中设直 ALPN (Application-Layer Protocol Negotiation，应用层协议协商)扩展来表明期望使用 h2 协议，服务器用同样的方式回复。如果使用这种方式，那么 h2 在创建 TLS 握手的过程中完成协商，不需要多余的网络通信。 使用 HTTP Alternative Services (HTTP 替代服务)或 Alt-Svc。 帧 HTTP/2 是基于帧(frame)的协议。采用分帧是为了将重要信息都封装起来，让协议的解析方可以轻松阅读、解析井还原信息。相比之下，h1 不是基于帧的，而是以文本分隔。 解析 h1 的请求或响应可能出现下列问题。 一次只能处理一个请求或响应，完成之前不能停止解析。 无陆预判解析需要多少内存。这会带来一系列问题: 你要把一行读到多大的缓冲区里;如果行太长会发生什么;应该增加并重新分配内存，还是返回 400 错误。为了解决这些 问题，保持内存处理的效率和速度可不简单。 有了帧，处理协议的程序就能预先知道会收到什么。基于帧的协议，特别是 h2，开始有固定长度的字节，其中包含表示整帧长度的字段。 由于 h2 是分帧的，请求和响应可以交错甚至多路复用。多路复用有助于解决类似队头阻塞的问题。 流HTTP/2 规范对流(stream)的定义是: “HTTP/2 连接上独立的、双向的帧序列交换。” 你可以将流看作在连接上的一系列帧，它们构成了单独的 HTTP 请求和响应。如果客户端想要发出请求，它会开启一个新的流。然后，服务器将在这个流上回复。这与 h1 的 请求/响应 流程类似，重要的区别在于，因为有分帧，所以多个请求和响应可以交错，而不会互相阻塞。流 ID (帧首部的第 6~9 字节)用来标识帧所属的流。 消息 HTTP 消息泛指 HTTP 请求或响应。 一个悄息至少由 HEADERS 帧(它初始化流)组成，井且可以另外包含 CONTINUATION 和 DATA 帧，以及其他的 HEADERS 帧。 h1 的请求和响应都分成消息首部和消息体两部分;与之类似，h2 的请求和响应分成 HEADERS 帧和 DATA 帧。 一切都是 header hl 把消息分成两部分: 请求 /状态行， 首部。h2 取消了这种区分，井把这些行变成了魔法伪首部。看下图： 请注意，请求和状态行在这里拆分成了多个首部，即:scheme、:method、:path 和:status。 没有分块编码( chunked encoding) 不再有 101 的晌应 流量控制 h2 的新特性之一是基于流的流量控制。不同于 h1 的世界，只要客户端可以处理，服务端就会尽可能快地发送数据， h2 提供了客户端调整传输速度的能力。 优先级流的最后一个重要特性是依赖关系。通过 HEADERS 帧和 PRIORITY 帧，客户端可以明确地和服务端沟通它需要什么，以及它需要这些资源的顺序。这是通过声明侬赖关系树和树里的相对权重实现的。 侬赖关系为客户端提供了一种能力，通过指明某些对象对另一些对象有依赖，告知服务器这些对象应该优先传输。 权重让客户端告诉服务器如何确定具有共同依赖关系的对象的优先级。 举个例子： index. html - header.jpg - critical.js - less_critical.js - style.css - ad.js - photo.jpg 在收到主体 HTML 文件之后，客户端会解析它，并生成依赖树，然后给树里的元素分配权重。这时这棵树可能是这样的: index. html - style.css - critical.js - less_critical.js(weight 20) - photo.jpg(weight 8) - header.jpg(weight 8) - ad.js(weight 4) 服务端推送 提升单个对象性能的最佳方式，就是在它被用到之前就放到浏览器的缓存里面。这正是 HTTP/2 的服务端推送的目的。 首部压缩 首部压缩 (HPACK)是 HTTP/2 的关键元素之一。 可以看到，后者的很多数据与前者重复了。第一个请求约有 220 字节，第二个约有 230 字节，但二者只有 36 字节是不同的。如果仅仅发送这 36 字节，就可以节省约 85% 的字节数。简而言之， HPACK 的原理就是这样。 HTTP2 的性能HTTP/2 比 h1 确实做了更多的工作，其目的就是为了从总体上提升性能 。下面是一些 h1 没有，但 h2 实现了的事情 : 窗口大小调节 依赖树构建 维持首部信息的静态/动态表 压缩 /解压缩首部 优先级调整( h2 允许客户端多次调整单一请求的优先级) 预先推送客户端尚未请求的数据流 第三方资源 第三方请求往往通过不同域名发送;由于浏览器需要解析 DNS、建立 TCP 连接、协商 TLS ， 这将严重影响性能。 因为第三方资源在不同域名下，所以请求不能从服务端推送、资源依赖、请求优先级等 h2 特性中 受益。这些特性仅是为请求相同域名下的资源设计的。 你无法控制第三方资源的性能，也无法决定它们是否会通过 h2 传输。 换个角度来看，如果第三方内容占了页面加载时间的一半，那么 h2 只能解决一半的性能问题。 单点故障(SPOF)是指 Web 页面上引用的某个资源，如果它出问题，将延迟整个页面的加载(甚至导致页面出错)。Chrome 浏览器插件 SPOF-O-MATIC 很容易就能检测出 SPOF 问题，并且通过使用 WebPagetest 来图形化展示那些问题的影响。 未完待续…","tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://coder.liusixin.cn/tags/HTTP/"},{"name":"性能优化","slug":"性能优化","permalink":"http://coder.liusixin.cn/tags/性能优化/"}]},{"title":"纯前端实现裁剪压缩图片","date":"2018-06-13T14:21:46.000Z","path":"posts/b43df12e/","text":"前言由于前端是不能直接操作本地文件的， 要么通过 &lt;input type= &quot;file&quot;&gt; 用户单击选择文件或者拖拽的方式，要么使用 Flash 等三方的控件。同时 HTMLS 崛起，可以在前端使用原生的 API 实现图片的处理，这样可以减少后端服务器的压力，同时对用户也是友好的。 这里面有几个核心的功能： 支持拖拽 压缩 裁剪编辑 上传和上传进度显示 实践接下来会依次介绍每个功能的实现！ 1. 拖拽显示图片拖拽读取的功能主要是要兼听 HTML5 的 drag 事件， 这个没什么好说的，主要在于怎么读取用户拖过来的图片并把它转成 base64 以在本地显示。 监听 drop 事件 var handler = { init: function($container) { // 需要把dragover的默认行为禁掉，不然会跳页 $container.on('dragover', function(event) { event.preventDefault(); }); $container.on('drop', function(event) { event.preventDefault(); // 这里获取拖过来的图片文件， 为一个File对象 var file = event.originalEvent.dataTransfer.files[O]; handler.handleDrop($(this), file); }); } }; 这里获取到图片文件之后交给 handleDrop 来处理。 注意如果使用 input, 则监听 input 的 change 事件， // 如果使用的是 input，监听change事件 $container.on('change', 'input[type=file]', function(event) { if (!this.value) return; var file = this.files[O]; handler.handleDrop($(this).closest('.container'), file); this.value = ''; }); 在 handleDrop 函数里， 读取 file 的内容， 并把它转成 base64 的格式： // 读取File内容并转base64 handleDrop: function($container, file) { var $img = $container.find(\"img\"); handler.readimgFile(file, $img, $container); } readimgFile 读取图片文件内容 // 读取图片文件内容 readimgFile: function(file, $img, $container) { var reader = new FileReader(file); // 根据mime type检验用户是否选则是图片文件 if (file.type.split(\"/\")[0] !== \"image\") { // util.toast(\"You should choose an image file\"); // 工具弹出插件，如果没有请自行封装 alert(\"You should choose an image file\") return; } reader.onload = function(event) { // 获取图片base64内容 var base64 = event.target.result; // 如果图片大千1MB, 将body置半透明 /* * 如果图片有几个 MB 的，展示的时候会被卡一下， 通过把页面变虚的方式告诉用户现在正在处理之中，页面不可操作，请稍等一会。 */ if (file.size > ONE_MB) { $(\"body\").css(\"opacity\", 0.5); } // 因为这里图片太大会被卡一下， 整个页面会不可操作 $img.attr(\"src\", baseUrl); // 还原 if (file.size > ONE_MB) { $(\"body\").css(\"opacity\", 1); } // 然后再调一个压缩和上传的函数 handler.compressAndUpload($img, base64, file, $container); } // 读取为base64格式 reader.readAsDataURL(file); } 通过 FileReader 读取文件内容， 调的是 readAsDataURL, 这个 API 能够把二进制图片内容转成 base64 的格式， 读取完之后会触发 onload 事件， 在 onload 里面进行显示和上传。 还会有一个问题， 就是 ios 系统拍摄的照片，如果不是横着拍的，展示出来的照片旋转角度会有问题，即不管你怎么拍，ios 实际存的图片都是横着放的，因此需要用户自己手动去旋转。旋转的角度放在了 exif 的数据结构里面，把这个读出来就知道它的旋转角度了， 用一个 EXIF 的库读取 readImgFile: function(file, $img, $container) { EXIF.getData(file, function() { var orientation = this.exifdata.Orientation, rotateDeg = O; // 如果不是ios拍的照片或者是横拍的，则不用处理，直接读取 if (typeof orientation === \"undefined\" || orientation === 1) { // 原本的readImgFile, 添加一个rotateDeg的参数 handler.doReadImgFile(file, $img, $container, rotateDeg); } // 否刻用canvas旋转一下 else { rotateDeg = orientation === 6 ? 90 * Math.PI / 180 : orientation === 8 ? -90 * Math.PI / 180 : orientation === 3 ? 180 * Math.PI / 180 : 0; handler.doReadImgFile(file, $img, $container, rotateDeg); } }); } 知道角度之后， 就可以用 canvas 处理了， 在下面的压缩图片再进行说明， 因为压缩也要用到 canvas。 2. 压缩图片压缩图片可以借助 canvas, canvas 可以很方便地实现压缩，其原理是把一张图片画到一个小的画布，然后再把这个画布的内容导出 base64, 就能够拿到一张被压小的图片了。 在 compress 函数里面进行压缩 // 设定图片最大压缩宽度为1500px var maxWidth = 1500; var resultimg = handler.compress($img[O], maxWidth, file.type); // 调用压缩 在 compress 这个函数里首先创建一个 canvas 对象，然后计算这个画布的大小， compress: function(img, maxWidth, mimeType) { // 创建一个canvas对象 var cvs = document.createElement('canvas'); var width = img.naturalWidth, height = img.naturalHeight, imgRatio = width / height; // 如果图片维度超过了给定的maxWidth 1500, // 为了保持图片宽高比， 计算画布的大小 if (width > maxWidth) { width = maxWidth; height = width / imgRatio; } cvs.width = width; cvs.height = height; } 接下来把大的图片画到一个小的画布上 var ctx = cvs.getContext('2d'); ctx.drawImage( img, O, O, img.naturalWidth, img.naturalHeight, 0, 0, width, height ); // 图片质量进行适当压缩 var quality = width >= 1500 ? 0.5 : width > 600 ? 0.6 : 1; // 导出图片为base64 var newImageData = cvs.toDataURL(mimeType, quality); var resultImg = new Image(); resultImg.src = newImageData; return resultImg; 最后一行返回了一个被压缩过的小图片。这里有个问题需要注意一下，有的浏览器在把 base64 赋值给 new 出来的 Image 的 src 时，是异步的操作，特别是 Safari, 所以要用监听 onload, 才能对此图片进行下一步的处理 resultImg.onload = function() { ctx.drawImage( img, O, O, img.naturalWidth, img.naturalHeight, 0, 0, width, height ); }; resultImg.src = newImageData; 由于前面提到 ios 拍的照片需要旋转一下， 在压缩的时候可以一起处理。也就是说，如果需要旋转的话，那么画在 canvas 上面的时候就把它旋转好了 var ctx = cvs.getContext(\"2d\"); var destX = 0, destY = O; if (rotateDeg) { ctx.translate(cvs.width / 2, cvs.height / 2); ctx.rotate(rotateDeg); destX = -width / 2; destY = -height / 2; } ... ctx.drawImage(img, 0, 0, img.naturalWidth, img.naturalHeight, destX, destY, width, height); 需要先把 canvas 的原点移到画布的中心，然后再进行旋转，默认原点是在左上角，原理和transform类似。 这样就解决了 ios 图片旋转的问题，得到一张旋转和压缩调节过的图片之后，再用它进行裁剪和编辑。 3. 裁剪图片裁剪图片，使用了一个 cropper 插件，这个插件还是挺强大的， 支待裁剪、旋转、翻转，但是它并没有对图片真正的处理，只是记录了用户做了哪些变换，然后你自己再去处理。 3.1 简单裁剪假设用户没有进行旋转和翻转，只是简单地选了区域裁剪了一下，那就简单很多。 最简单的办法就是创建一个 canvas, 它的大小就是选框的大小， 然后根据起点 x、y 和宽高把图片相应的位置画到这个画布，再导出图片就可以了。 由于考虑到需要翻转， 所以用第二种方法：创建一个和图片一样大小的 canvas, 把图片原封不动地画上去， 然后把选中区域的数据 imageData 存起来， 重新设置画布的大小为选中框的大小， 再把 imageData 画上去，最后再导出就可以了， var cvs = document.createElement('canvas'); var img = $img[O]; var width = img.naturalWidth, height = img.naturalHeight, cvs.width = width; cvs.height = height; var ctx = cvs.getContext(\"2d\"); var destX = 0, destY = O; ctx.drawImage(img, destX, destY); // 把选中框里的图片内容存起来 var imageData = ctx.getImageData(cropOptions.x, cropOptions.y, cropOptions.width, cropoptions.height); cvs.width = cropOptions.width; cvs.height = cropOptions.height; // 然后再画上去 ctx.putImageData(imageData, 0, 0); 3.2 裁剪加翻转如果用户做了翻转， 只需要在 drawlmage 之前对画布做一下翻转变化 if (cropOptions.scaleX === -1 || cropOptions.scaleY === -1) { // 水平翻转 destX = cropOptions.scaleX === -1 ? width * -1 : 0; // 垂直翻转 destY = cropOptions.scaleY === -1 ? height * -1 : 0; ctx.scale(cropOptions.scaleX, cropOptions.scaleY); } ctx.drawlmage(img, destX, destY); 其他的都不用变，就可以实现上下左右翻转了，难点在于既要翻转又要旋转 3.3 旋转加翻转剪裁两种变化叠加没办法直接通过变化 canvas 的坐标一次性 drawImage 上去，有两种办法，第一种是用 imageData 进行数学变换，计算一遍得到 imageData 里面从第一行到最后一行每个像素新的 rgba 值是多少，然后再画上去。第二种是创建第二个 canvas，第一个 canvas 做翻转时把它画到第二个 canvas，第二个再进行旋转，我们用第二种办法 在第一个 canvas 画完之后，创建第二个 canvas 进行旋转。 ctx.drawlmage(img, destX, destY); //rotate if (cropOptions.rotate !== O) { var newCanvas = document.createElement('canvas'), deg = (cropOptions.rotate / 180) * Math.PI; // 旋转之后， 导致画布变大， 需要计算一下 newCanvas.width = Math.abs(width * Math.cos(deg)) + Math.abs(height * Math.sin(deg)); newCanvas.height = Math.abs(width * Math.sin(deg)) + Math.abs(height * Math.cos(deg)); var newContext = newCanvas.getContext('2d'); newContext.save(); newContext.translate(newCanvas.width / 2, newCanvas.height / 2); newContext.rotate(deg); (destX = -width / 2), (destY = -height / 2); // 将第一个canvas的内容在经旋转后的坐标系画上来 newContext.drawImage(cvs, destX, destY); newContext.restore(); } 4. 文件上传和上传进度文件上传只能通过表单提交的形式，编码方式为 multipart/form-data, 可以通过写个 form 标签进行提交， 也可以用 AJAX 模拟表单提交的格式。 首先创建一个 AJAX 请求，并设置编码方式 var xhr = new XMLHttpRequest(); xhr.open('POST', upload_url, true); var boundary = 'someboundary'; xhr.setRequestHeader( 'Content-Type', 'multipart/form-data; boundary=' + boundary ); 然后拼表单格式的数据进行上传 // 拼表单提交的数据形式 var data = img.src; data = data.replace('data:' + file.type + ';base64,', ''); xhr.sendAsBinary( [ //name=data '--' + boundary, 'Content-Disposition: form-data; name=\"data\"; filename=\"' + file.name + '\"', 'Content-Type: ' + file.type, '', atob(data), '--' + boundary, // name=docName '--' + boundary, 'Content-Disposition: form-data; name=\"docName\"', '', file.name, '--' + boundary + '--' ].join('\\r\\n') ); atob 将 base64 解码为二进制的格式， 符合表单提交的数据格式要求。 表单数据不同的字段是用 boundary 的随机字符串分隔的， 拼好之后用 sendAsBinary 发出去。 这个上传功能参考了一个 JIC 插件， 但是由于这个 API 已经废弃了， 所以新代码不推荐再使用这种方式。 在调这个函数之前先监听下它的事件 1. 上传的进度 xhr.upload.onprogress = function(event) { if (event.lengthComputable) { duringCallback((event.loaded / event.total) * 100); } }; 这里调用 duringCallback 的回调函数， 给这个回调函数传了当前进度的参数， 用这个参数就可以设置进度条的过程了。 进度条可以自已实现， 或者直接上网找一个。 2. 成功和失败 需要对成功和失败做一些反馈处理， xhr.onreadystatechange = function() { if (this.readyState === 4) { if (this.status === 200) { successCallback(this.responseText); } else if (this.status >= 400) { if (errorCallback) { errorCallback(this.responseText); } } } }; 至此整个功能就拆解说明完了， 上面的代码可以兼容到 IE10, FileReader 的 API 到 IElO 才兼容，问题应该不大。这个东西一来减少了后端的压力， 二来不用和后端来回交互， 对用户体验来说还是比较好的， 除了上面说的有一个地方会被卡一下之外。","tags":[{"name":"javascript","slug":"javascript","permalink":"http://coder.liusixin.cn/tags/javascript/"},{"name":"HTML5","slug":"HTML5","permalink":"http://coder.liusixin.cn/tags/HTML5/"},{"name":"插件","slug":"插件","permalink":"http://coder.liusixin.cn/tags/插件/"}]},{"title":"JTalk 第八期 前端安全大起底 总结","date":"2018-06-05T05:43:00.000Z","path":"posts/7189c795/","text":"JTalk《前端安全》活动结束啦，我收录了这次讲师所讲述的内容和部分同学提出的问题与讲师的答复，遗憾的是没有全部收录下来，只收录了部分内容，文章的内容并不完全代表讲师所讲述的全部内容，有部分是我回忆补充的，会有出入，希望这部分内容能帮到大家。 XSS 跨站脚本的攻击原理与防御 - 龙佳文 什么是 XSS? (XSS 会有哪些危害, 窃取凭据,窃取会话令牌) 在输入框输入标签字符可以反射得到 cookie 值，并将这个 cookie 发送到指定的地址 v-html 可以将重要的数据以任何的形式弹出这个功能类似 innerHEML XSS 产生的原因？（常见导致 XSS 的途径: 反射型，存储型，DOM based） 不使用 innerHEML 作为瀑布流展示 在地址中可以使用 标签的形式 得到或改变页面显示的形式 Chrome 会自带 XSS 防御，在注入标签的时候回被自动拦截,只能拦截主流的注入形式。 如何防御 XSS？（慎用数据,避免使用 innerHTML 等等） XSS 能实现的攻击有回话劫持，通过 cookie 将用户的信息发送到指定的地址 用过得到的 cookie 拿到 token 可以模仿用户的信息和行为进行常规的操作。 通过 JS 不断创建文件进行请求通过模仿某一服务器对指定服务器进行攻击。 对内容进行做转义，防止恶意的标签注入。 内容白名单，对外部动态内容的安全过滤使用白名单，而不是黑名单通过白名单对指定的标签进行过滤选择。 问题收录 攻击次数的上报 通过 CSP 的规范通过内部的声明，通过其可以将内容进行上报。 CSP 会去要求进入到所有的内容以外的进行执行。 在页面执行非法的 JS CSP 都会对其执行拦截。 知道概念 并不深入 怎么检测项目的隐患 OWSP 有安全的规范和安全的审计软件可以使用 转义 只针对 HTML 进行转义 对于其他的转义 需要后台做配合处理 XSS 对于攻击的防御，有没有好用的工具或实时监测漏洞的工具 对业务流程使用安全审计软件进行审计，如果公司对这个比较重视可以花钱去审计， 安全是需要团队和老板一起进行开发和协作。第三方的数据不一定可靠， 需要团队进行互相协作。 浅谈流量劫持与防治 - 刘洋河 典型的上网会经历哪些阶段 在急于将产品投入使用,导致软件开发的过程中出现很多的问题漏铜，而不知道攻击者的攻击方式，对于基础的内容只是一定要掌握。 流量劫持 并不是新生的话题,流量劫持一直纯在并没有彻底的消除。 理想的上网环境,打开浏览器就可以使用,当用户打开浏览器上网的时候是需要通过路由器的 IP 访问服务器网站 然后通过 CDN 进行对文件进行下载。 流量劫持是怎么发生的呢？ 链路本身不安全 从设计上未考虑安全性。 随着计算力发展，安全链路变得不安全。 干扰安全链路，迫使链路使用若安全方案。 DNS 投毒与防治 流量劫持与防治 DNS 基于一个 UDP 的协议，工作的时候效率较慢,缓存的时候是比较快的。 没有缓存的情况下需要查询很久。 公共域名访问顶级域 存在一个缓存时间 TTL 可以在指定的时限内 如果没有请求到数据会再次请求。 污染 DNS 可以使用缓存对 DNS 进行攻击或污染 HTTP 在网服务其对 DNS 加密，用户得到加密的我呢间下载后进行解密再使用，增加 DNS 的安全性。 抵抗 DNS 流量劫持 链路问题的排查 方案 A:在某些省份、地区⾃自建监测站，定期抓取固定资源 问题:资源太固定，监测站数量量也远远不不够 方案 B:业务⽅方在⾃自⼰己的 html 中监听资源的 error 事件 问题:⽆无法确认问题在于链路路，也可能只是普通的 js 出错 方案 C:使⽤用第三⽅方企业服务进⾏行行监控 问题:服务越多成本越⾼高 方案 D:CSP、SRI 问题:兼容性和灵活性差，⽆无法进⾏行行⾃自定义逻辑 问答这部分的问答，我只记录了讲师的回复，因为近期加班时长耳鸣，没能听清楚问题，向大家致歉。 浏览器在跑业务代码的时候， 没有空余的时间去做业务计算。 没有太多的资源去做,或者在 SDK 中嵌入，拿到文件的长度和首尾前 100 个字节进行判断，是否被篡改。 异步加载脚本，首先可以使用浏览器的加载机制去做， 另一个方案是不使用原有的方案进行加载。 使用自己定义的方案进行修改。 深入浅出 CSRF - 吴空 CSRF 是什么? CSRF 可以做什么? CSRF 攻击现状 CSRF 攻击 可以伪造邮件 仿制用户的信息 盗取账号 购买商品 银行转账。 CSRF 攻击原理与防御 CSRF 漏铜检测 防御内容详见 PPT CSRF 常见防御。 CSRF Tester 漏洞检测 使⽤用代理理抓取我们在浏览器器中访问过的所有的连接以及所有的表单等信息，通过在 CSRFTester 中修改相应的表单等 信息，重新提交，相当于一次伪造客户端请求，如果修测试的请求成功被⽹网站服务器器接受，则说明存在 CSRF 漏漏洞洞，当然此款⼯工具也可以被⽤用来进⾏行行 CSRF 攻击。 CSRF Request Build 漏洞检测 在⿊黑客圈指：观点验证程序，运⾏行行这个程序得到预期结果，就验证了了这个观点。 前端与服务器端如何在代码层面防范 CSRF 攻击 在自动化构建过程接入漏洞检测工具在提交的时候就进行漏铜的检测。 线上接口扫描，线上提供一个入口， 通过漏洞扫描工具 进行线上的扫描和更新。 用户安全验证探索 - 潘俊 安全验证在 Web 服务中的位置 信息的分类与网站的性质有关系，最常见的一般分为隐私和非隐私两大类。结合产品自身的特性来选择信息如何呈现给用户 常规操作和敏感操作对于验证的需求并不相同。 Case:[新买的手机有了别人的数据] Case:[新注册了一个账号，发现了不属于自己的东西] 验证的类型和优劣 强验证 弱验证(对于用户识别) 扩展的动态类型的验证 密码正在演变，登录的方式多样性与多样化。 密码的安全性和重要性逐渐在降低。 短信快捷登录 短信登录的兴起 智能手机的普及和移动互联网的发展 手机资费结构变化和短信功能的转变 SIM 卡实名化让手机可以从当个人账号的角色 短信开发的一些常见的问题 防范短信轰炸 短信的有效期 服务商和费用 短信登录的利弊 简单快捷安全 手机号是可以回收的 如何从产品整体层面来规划和制定策略 如何减少验证次数 设备化，将浏览器器也设备化(通过⼀一个⻓长效 COOKIE 标识) 增加设备关联，历史数据来决定设备与账号关系 地域，IP，甚⾄至活跃时间段都可以当成辅助来判定当前用户是否可信。 该如何选择验证方式 密码登录 短信登录 动态令牌 扫码登录 其他 强依赖第三方登录 人脸识别，指纹识别等等 该如何选择验证方式 纯微信开发 微信登录 手机短信 密码登录 手机 App 为主 手机短信 密码登录 人工申诉 微信登录 扫码登录 PC 浏览器位置 密码登录 手机短信 动态令牌 多端并重 手机短信 扫码登录 密码登录 微信登录 动态令牌 低交互信息类 密码登录 手机短信 工具类（重资产） 手机短信 动态令牌 人工申诉 微信登录 扫码登录 密码登录 工具类（重信息） 动态令牌 人工申诉 手机短信 密码登录 先后顺序代表推荐顺序和开发的优先级 总结安全问题，不只是局限于 Web 前端凡是涉及网络的地方都会有攻击的存在，大厂有自己的安全团队，中小型公司就成了黑客的练手的存在，据朋友说有很多地方在培训黑客，会拿一些中小型公司练手，听到这个感觉充满了挑战，是对自己能力和快速查错及解决问题综合的考验。产品的完成不只是功能的完善，代码的可靠性，健壮性，安全性也是很重要的，任何微小的瑕疵都会成为攻击方的入口，我认为这也是一种对自己的提升与考验，只有经历风雨存活下来的才是有能力继续前行的。 本文转自掘金","tags":[{"name":"前端安全","slug":"前端安全","permalink":"http://coder.liusixin.cn/tags/前端安全/"}]},{"title":"网站性能优化实战——从12.67s到1.06s的故事","date":"2018-06-01T04:42:50.000Z","path":"posts/92e76411/","text":"作者：腾讯课堂 NEXT 学位 文章摘自：https://juejin.im/post/5b0b7d74518825158e173a0c 网站性能监测与优化策略0.引言作为互联网项目，最重要的便是用户体验。在举国“互联网+”的热潮中，用户至上也已经被大多数企业所接收，特别是在如今移动端快速发展的时代，我们的网页不仅只是呈现在用户的 PC 浏览器里，更多的时候，用户是通过移动产品浏览我们的网页。加之有越来越多的开发者投入到 Web APP 和 Hybrid APP 的开发队伍中，性能，又再一次成为了被程序员们重点关注的话题。我曾经看到过这样一句话：一个网站的体验，决定了用户是否愿意去了解网站的功能；而网站的功能，决定了用户是否会一票否决网站的体验。这是改版自网络上的一句流行语，但却把网站性能这件事说的十分透彻，特别是在网站这样的项目中，如果一个用户需要超过 5s 才能看见页面，他会毫不犹豫地关闭它。 性能优化，作为工程师界的“上乘武功”，是我们在开发中老生常谈的话题，也是一名开发者从入门向资深进阶的必经阶段，虽然我们看到过很多的标准、军规，但在真正实践中，却常常力不从心，不知道落下了什么，不知道性能是否还有进一步优化的空间。 对于网站的性能，在行业内有很多既定的指标，但就以我们 Front-Enders 而言，应该更加关注以下指标：白屏时间、首屏时间、整页时间、DNS 时间、CPU 占用率。而我之前自己搭建的一个网站（网址：jerryonlyzrj.com/resume/ ，近日因域名备案无法打开，几日后即恢复正常），完全没做性能优化时，首屏时间是 12.67s，最后经过多方面优化，终于将其降低至 1.06s，并且还未配置 CDN 加速。其中过程我踩了很多坑，也翻了许多专业书籍，最后决定将这几日的努力整理成文，帮助前端爱好者们少走弯路。 今天，我们将从性能优化的三大方面工作逐步展开介绍，其中包括网络传输性能、页面渲染性能以及 JS 阻塞性能，系统性地带着读者们体验性能优化的实践流程。 1.网络传输性能优化在开始介绍网络传输性能优化这项工作之前，我们需要了解浏览器处理用户请求的过程，那么就必须奉上这幅神图了： 这是 navigation timing 监测指标图，从图中我们可以看出，浏览器在得到用户请求之后，经历了下面这些阶段：重定向 → 拉取缓存 →DNS 查询 → 建立 TCP 链接 → 发起请求 → 接收响应 → 处理 HTML 元素 → 元素加载完成。不着急，我们将对其中的细节一步步展开讨论： 1.1.浏览器缓存我们都知道，浏览器在向服务器发起请求前，会先查询本地是否有相同的文件，如果有，就会直接拉取本地缓存，这和我们在后台部属的 Redis、Memcache 类似，都是起到了中间缓冲的作用，我们先看看浏览器处理缓存的策略： 因为网上的图片太笼统了，而且我翻过很多讲缓存的文章，很少有将状态码还有什么时候将缓存存放在内存（memory）中什么时候将缓存在硬盘中（disk）系统地整理出来，所以我自己绘制了一张浏览器缓存机制流程图，结合这张图再更深入地说明浏览器的缓存机制。 这里我们可以使用 chrome devtools 里的 network 面板查看网络传输的相关信息： （这里需要特别注意，在我们进行缓存调试时，需要去除 network 面板顶部的 Disable cache 勾选项，否则浏览器将始终不会从缓存中拉取数据） 浏览器默认的缓存是放在内存内的，但我们知道，内存里的缓存会因为进程的结束或者说浏览器的关闭而被清除，而存在硬盘里的缓存才能够被长期保留下去。很多时候，我们在 network 面板中各请求的 size 项里，会看到两种不同的状态：from memory cache 和 from disk cache，前者指缓存来自内存，后者指缓存来自硬盘。而控制缓存存放位置的，不是别人，就是我们在服务器上设置的 Etag 字段。在浏览器接收到服务器响应后，会检测响应头部（Header），如果有 Etag 字段，那么浏览器就会将本次缓存写入硬盘中。 之所以拉取缓存会出现 200、304 两种不同的状态码，取决于浏览器是否有向服务器发起验证请求。 只有向服务器发起验证请求并确认缓存未被更新，才会返回 304 状态码。 这里我以 nginx 为例，谈谈如何配置缓存: 首先，我们先进入 nginx 的配置文档 $ vim /etc/nginx/conf.d/nginx.conf 在配置文档内插入如下两项： etag on; # 开启etag验证 expires 7d; # 设置缓存过期时间为7天 打开我们的网站，在 chrome devtools 的 network 面板中观察我们的请求资源，如果在响应头部看见 Etag 和 Expires 字段，就说明我们的缓存配置成功了。 【！！！特别注意！！！】在我们配置缓存时一定要切记，浏览器在处理用户请求时，如果命中强缓存，浏览器会直接拉取本地缓存，不会与服务器发生任何通信，也就是说，如果我们在服务器端更新了文件，并不会被浏览器得知，就无法替换失效的缓存。所以我们在构建阶段，需要为我们的静态资源添加 md5 hash 后缀，避免资源更新而引起的前后端文件无法同步的问题。 1.2.资源打包压缩我们之前所作的浏览器缓存工作，只有在用户第二次访问我们的页面才能起到效果，如果要在用户首次打开页面就实现优良的性能，必须对资源进行优化。我们常将网络性能优化措施归结为三大方面：减少请求数、减小请求资源体积、提升网络传输速率。现在，让我们逐个击破： 结合前端工程化思想，我们在对上线文件进行自动化打包编译时，通常都需要打包工具的协助，这里我推荐 webpack，我通常都使用 Gulp 和 Grunt 来编译 node，Parcel 太新，而且 webpack 也一直在自身的特性上向 Parcel 靠拢。 在对 webpack 进行上线配置时，我们要特别注意以下几点： ①JS 压缩：（这点应该算是耳熟能详了，就不多介绍了） new webpack.optimize.UglifyJsPlugin() ②HTML 压缩： new HtmlWebpackPlugin({ template: __dirname + '/views/index.html', // new 一个这个插件的实例，并传入相关的参数 filename: '../index.html', minify: { removeComments: true, collapseWhitespace: true, removeRedundantAttributes: true, useShortDoctype: true, removeEmptyAttributes: true, removeStyleLinkTypeAttributes: true, keepClosingSlash: true, minifyJS: true, minifyCSS: true, minifyURLs: true }, chunksSortMode: 'dependency' }) 我们在使用 html-webpack-plugin 自动化注入 JS、CSS 打包 HTML 文件时，很少会为其添加配置项，这里我给出样例，大家直接复制就行。 PS：这里有一个技巧，在我们书写 HTML 元素的 src 或 href 属性时，可以省略协议部分，这样也能简单起到节省资源的目的。 ③ 提取公共资源： new webpack.optimize.CommonsChunkPlugin({ name: 'vendor', filename: 'scripts/common/vendor-[hash:5].js' }) PS:这里是 webpack3 的语法，在 webpack4 中已作更改，希望大家注意 ④ 提取 css 并压缩： 在使用 webpack 的过程中，我们通常会以模块的形式引入 css 文件（webpack 的思想不就是万物皆模块嘛），但是在上线的时候，我们还需要将这些 css 提取出来，并且压缩，这些看似复杂的过程只需要简单的几行配置就行： 我们需要用到 extract-text-webpack-plugin ，所以还得大家自行 npm install const ExtractTextPlugin = require('extract-text-webpack-plugin') module: { rules: [ ..., { test: /\\.css$/, use: ExtractTextPlugin.extract({ fallback: 'style-loader', use: { loader: 'css-loader', options: { minimize: true } } }) } ] } ⑤ 使用 webpack3 的新特性：ModuleConcatenationPlugin new webpack.optimize.ModuleConcatenationPlugin() 如果你能按照上述五点将 webpack 上线配置完整配置出来，基本能将文件资源体积压缩到极致了，如有疏漏，还希望大家能加以补充。 给大家上一份我的 webpack 上线配置文档，欢迎参考： // webpack.pro.js const webpack = require('webpack') const HtmlWebpackPlugin = require('html-webpack-plugin') const ExtractTextPlugin = require('extract-text-webpack-plugin') const CleanWebpackPlugin = require('clean-webpack-plugin') const CopyWebpackPlugin = require('copy-webpack-plugin') module.exports = { entry: __dirname + '/public/scripts/index.js', output: { path: __dirname + '/build/static', // 打包后的文件存放的地方 filename: 'scripts/[name]-[hash:5].js' // 打包后输出文件的文件名,带有md5 hash戳 }, resolve: { extensions: ['.jsx', '.js'] }, module: { rules: [{ test: /(\\.jsx|\\.js)$/, use: { loader: 'babel-loader' }, exclude: /node_modules/ // 不进行编译的目录 }, { test: /\\.css$/, use: ExtractTextPlugin.extract({ fallback: 'style-loader', use: { loader: 'css-loader', options: { minimize: true } } }) }] }, plugins: [ new HtmlWebpackPlugin({ template: __dirname + '/views/index.html', filename: '../index.html', minify: { removeComments: true, collapseWhitespace: true, removeRedundantAttributes: true, useShortDoctype: true, removeEmptyAttributes: true, removeStyleLinkTypeAttributes: true, keepClosingSlash: true, minifyJS: true, minifyCSS: true, minifyURLs: true }, chunksSortMode: 'dependency' }), new ExtractTextPlugin('styles/style-[hash:5].css'), new CleanWebpackPlugin('build/*', { root: __dirname, verbose: true, dry: false }), new webpack.optimize.UglifyJsPlugin(), new CopyWebpackPlugin([{ from: __dirname + '/public/images', to: __dirname + '/build/static/images' }, { from: __dirname + '/public/scripts/vector.js', to: __dirname + '/build/static/scripts/vector.js' }]), new webpack.optimize.ModuleConcatenationPlugin(), new webpack.optimize.CommonsChunkPlugin({ name: 'vendor', filename: 'scripts/common/vendor-[hash:5].js' }) ] } 最后，我们还应该在服务器上开启 Gzip 传输压缩，它能将我们的文本类文件体积压缩至原先的四分之一，效果立竿见影，还是切换到我们的 nginx 配置文档，添加如下两项配置项目： gzip on; gzip_types text/plain application/javascriptapplication/x-javascripttext/css application/xml text/javascriptapplication/x-httpd-php application/vnd.ms-fontobject font/ttf font/opentype font/x-woff image/svg+xml; 如果你在网站请求的响应头里看到这样的字段，那么就说明咱们的 Gzip 压缩配置成功啦： 【！！！特别注意！！！】不要对图片文件进行 Gzip 压缩！不要对图片文件进行 Gzip 压缩！不要对图片文件进行 Gzip 压缩！我只会告诉你效果适得其反，至于具体原因，还得考虑服务器压缩过程中的 CPU 占用还有压缩率等指标，对图片进行压缩不但会占用后台大量资源，压缩效果其实并不可观，可以说是“弊大于利”，所以请在 gzip_types 把图片的相关项去掉。针对图片的相关处理，我们接下来会更加具体地介绍。 1.3.图片资源优化刚刚我们介绍了资源打包压缩，只是停留在了代码层面，而在我们实际开发中，真正占用了大量网络传输资源的，并不是这些文件，而是图片，如果你对图片进行了优化工作，你能立刻看见明显的效果。 1.3.1.不要在 HTML 里缩放图像很多开发者可能会有这样的错觉（其实我曾经也是这样），比如我们会为了方便在一个 200✖200 的图片容器内直接使用一张 400✖400 的图片，我们甚至认为这样能让用户觉得图片更加清晰，其实不然，在普通的显示器上，用户并不会感到缩放后的大图更加清晰，但这一切却导致网页加速速度下降，同时照成带宽浪费，你可能不知道，一张 200KB 的图片和 2M 的图片的传输时间会是 200ms 和 12s 的差距（亲身经历，深受其害(┬＿┬)）。所以，当你需要用多大的图片时，就在服务器上准备好多大的图片，尽量固定图片尺寸。 1.3.2.使用雪碧图（CSS Sprite）雪碧图的概念大家一定在开发中经常听见，其实雪碧图是减小请求数的示范性代表。而且很奇妙的是，多张图片拼在一块后，总体积会比之前所有图片的体积之和小（你可以亲自试试）。这里给大家推荐一个自动化生成雪碧图的工具：www.toptal.com/developers/… （图片来自官网首页） 只要你添加相关资源文件，他就会自动帮你生成雪碧图以及对应的 CSS 样式，你要做的，只是 download 和 copy。 1.3.3.使用字体图标（iconfont）不论是压缩后的图片，还是雪碧图，终归还是图片，只要是图片，就还是会占用大量网络传输资源。但是字体图标的出现，却让前端开发者看到了另外一个神奇的世界。 我最喜欢用的是阿里矢量图标库（网址：www.iconfont.cn/ ） ，里面有大量的矢量图资源，而且你只需要像在淘宝采购一样把他们添加至购物车就能把它们带回家，整理完资源后还能自动生成 CDN 链接，可以说是完美的一条龙服务了。（图片来自官网首页） 图片能做的很多事情，矢量图都能作，而且它只是往 HTML 里插入字符和 CSS 样式而已，和图片请求比起来，在网络传输资源的占用上它们完全不在一个数量级，如果你的项目里有大量的小图标，就用矢量图吧。 1.3.4.使用 WebPWebP 格式，是谷歌公司开发的一种旨在加快图片加载速度的图片格式。图片压缩体积大约只有 JPEG 的 2/3，并能节省大量的服务器带宽资源和数据空间。Facebook、Ebay 等知名网站已经开始测试并使用 WebP 格式。 我们可以使用官网提供的 Linux 命令行工具对项目中的图片进行 WebP 编码，也可以使用我们的线上服务，这里我推荐叉拍云（网址：www.upyun.com/webp ）。但是在实际的上线工作中，我们还是得编写 Shell 脚本使用命令行工具进行批量编码，不过测试阶段我们用线上服务就足够了，方便快捷。（图片来自叉拍云官网） 1.4.网络传输性能检测工具——Page Speed除了 network 版块，其实 chrome 还为我们准备好了一款监测网络传输性能的插件——Page Speed，咱们的文章封面，就是用的 Page Speed 的官方宣传图（因为我觉得这张图再合适不过了）。我们只需要通过下面步骤安装，就可以在 chrome devtools 里找到它了：chrome 菜单 → 更多工具 → 拓展程序 →chrome 网上应用商店 → 搜索 pagespeed 后安转即可。 （PS：使用 chrome 应用商店需要翻墙，怎么翻墙我就不便多说了） 这就是 Page Speed 的功能界面： 我们只需要打开待测试的网页，然后点击 Page Speed 里的 Start analyzing 按钮，它就会自动帮我们测试网络传输性能了，这是我的网站测试结果： Page Speed 最人性化的地方，便是它会对测试网站的性能瓶颈提出完整的建议，我们可以根据它的提示进行优化工作。这里我的网站已经优化到最好指标了(•́⌄•́๑)૭✧，Page Speed Score 表示你的性能测试得分，100/100 表示已经没有需要优化的地方。 优化完毕后再使用 chorme devtools 的 network 版块测量一下我们网页的白屏时间还有首屏时间，是不是得到了很大的提升？ 1.5.使用 CDNLast but not least， 再好的性能优化实例，也必须在 CDN 的支撑下才能到达极致。 如果我们在 Linux 下使用命令 $ traceroute targetIp 或者在 Windows 下使用批处理 &gt; tracert targetIp，都可以定位用户与目标计算机之间经过的所有路由器，不言而喻，用户和服务器之间距离越远，经过的路由器越多，延迟也就越高。使用 CDN 的目的之一便是解决这一问题，当然不仅仅如此，CDN 还可以分担 IDC 压力。 当然，凭着我们单个人的资金实力（除非你是王思聪）是必定搭建不起来 CDN 的，不过我们可以使用各大企业提供的服务，诸如腾讯云等，配置也十分简单，这里就请大家自行去推敲啦。 其实我们的 CDN 域名一般是和我们的网站主域名不同的，大家可以看看淘宝、腾讯的官方网站，看看他们存放静态资源的 CDN 域名，都是和主域名不一样的。为什么要这么做？主要有两个原因：[内容摘选自：bbs.aliyun.com/simple/t116… ] 便于 CDN 业务独立，能够独立配置缓存。 为了降低 web 压力，CDN 系统会遵循 Cache-Control 和 Expires HTTP 头标准对改请求返回的内容进行缓存，便于后面的请求不在回源，起到加速功能。而传统 CDN（Web 与 CDN 共用域名）的方式，需要对不同类型的文件设置相应的 Cache 规则或者遵循后端的 HTTP 头，但这样难以发挥 CDN 的最大优势，因为动态请求回源的概率非常之大，如果访客与源站的线路并不慢，通过 CDN 的请求未必快于直接请求源站的。 大型网站为了提升 web 性能到极致，通常缓存头设置比较大，像谷歌 JS 设置一年缓存，百度首页 logo 设置十年缓存，如果将静态元素抽取出来，就可以很方便的对所有静态元素部署规则，而不用考虑动态请求。减少规则的条数可以提升 CDN 的效率。 抛开无用 cookie，减小带宽占用。 我们都知道 HTTP 协议每次发送请求都会自动带上该域名及父级域名下的 cookie，但对于 CSS，JS 还有图片资源，这些 cookie 是没用的，反而会浪费访客带宽和服务器入带宽。而我们的主站，为了保持会话或者做其他缓存，都会存放着大量的 cookie，所以如果将 CDN 与主站域名分离，就能解决这一问题。 不过这样一来，新的问题就出现了：CDN 域名与主站域名不同，DNS 解析 CDN 域名还需要花费额外的时间，增加网络延迟。不过这难不住我们伟大的程序员前辈，DNS Prefetch 闪亮登场。 如果大家翻看大型网站的 HTML 源代码，都会在头部发现这样的 link 链接：（这里以淘宝首页为例） 这就是 DNS Prefetch。DNS Prefetch 是一种 DNS 预解析技术，当我们浏览网页时，浏览器会在加载网页时对网页中的域名进行预解析并缓存，这样在浏览器加载网页中的链接时，就无需进行 DNS 解析，减少用户的等待时间，提高用户体验。DNS Prefetch 现已被主流浏览器支持，大多数浏览器针对 DNS 解析都进行了优化，典型的一次 DNS 解析会耗费 20~120ms，减少 DNS 解析时间和次数是个很好的优化措施。这里附上一张 Can I use it 官网上的 DNS Prefetch 支持情况图： 所以，放心大胆地去使用它吧。 2.页面渲染性能优化2.1.浏览器渲染过程（Webkit） 其实大家应该对浏览器的 HTML 渲染机制比较熟悉了，基本流程同上图所述，大家在入门的时候，你的导师或者前辈可能会告诉你，在渲染方面我们要减少重排和重绘，因为他们会影响浏览器性能。不过你一定不知道其中原理是什么，对吧。今天我们就结合《Webkit 技术内幕》（这本书我还是很推荐大家买来看看，好歹作为一名前端工程师，你得知道我们天天接触的浏览器内核是怎样工作的）的相关知识，给大家普及普及那些深层次的概念。 PS：这里提到了 Webkit 内核，我顺带提一下浏览器内部的渲染引擎、解释器等组件的关系，因为经常有师弟或者一些前端爱好者向我问这方面的知识，分不清他们的关系，我就拿一张图来说明：（这部分内容与本文无关，如果你对此不感兴趣，可以直接跳过） 浏览器的解释器，是包括在渲染引擎内的，我们常说的 Chrome（现在使用的是 Blink 引擎）和 Safari 使用的 Webkit 引擎，Firefox 使用的 Gecko 引擎，指的就是渲染引擎。而在渲染引擎内，还包括着我们的 HTML 解释器（渲染时用于构造 DOM 树）、CSS 解释器（渲染时用于合成 CSS 规则）还有我们的 JS 解释器。不过后来，由于 JS 的使用越来越重要，工作越来越繁杂，所以 JS 解释器也渐渐独立出来，成为了单独的 JS 引擎，就像众所周知的 V8 引擎，我们经常接触的 Node.js 也是用的它。 2.2.DOM 渲染层与 GPU 硬件加速如果我告诉你，一个页面是由许多许多层级组成的，他们就像千层面那样，你能想象出这个页面实际的样子吗？这里为了便于大家想象，我附上一张之前 Firefox 提供的 3D View 插件的页面 Layers 层级图： 对，你没看错，页面的真实样子就是这样，是由多个 DOM 元素渲染层（Layers）组成的，实际上一个页面在构建完 Render Tree 之后，是经历了这样的流程才最终呈现在我们面前的： 浏览器会先获取 DOM 树并依据样式将其分割成多个独立的渲染层 CPU 将每个层绘制进绘图中 将位图作为纹理上传至 GPU（显卡）绘制 GPU 将所有的渲染层缓存（如果下次上传的渲染层没有发生变化，GPU 就不需要对其进行重绘）并复合多个渲染层最终形成我们的图像 从上面的步骤我们可以知道，布局是由 CPU 处理的，而绘制则是由 GPU 完成的。 其实在 chrome 中，也为我们提供了相关插件供我们查看页面渲染层的分布情况以及 GPU 的占用率：（所以说，平时我们得多去尝试尝试 chrome 的那些莫名其妙的插件，真的会发现好多东西都是神器） chrome 开发者工具菜单 →more tools→Layers（开启渲染层功能模块） chrome 开发者工具菜单 →more tools→rendering（开启渲染性能监测工具） 执行上面的操作后，你会在浏览器里看到这样的效果： 太多东西了，分模块讲吧： 最先是页面右上方的小黑窗：其实提示已经说的很清楚了，它显示的就是我们的 GPU 占用率，能够让我们清楚地知道页面是否发生了大量的重绘。 Layers 版块：这就是用于显示我们刚提到的 DOM 渲染层的工具了，左侧的列表里将会列出页面里存在哪些渲染层，还有这些渲染层的详细信息。 Rendering 版块：这个版块和我们的控制台在同一个地方，大家可别找不到它。前三个勾选项是我们最常使用的，让我来给大家解释一下他们的功能（充当一次免费翻译） ①Paint flashing：勾选之后会对页面中发生重绘的元素高亮显示 ②Layer borders：和我们的 Layer 版块功能类似，它会用高亮边界突出我们页面中的各个渲染层 ③FPS meter：就是开启我们在（一）中提到的小黑窗，用于观察我们的 GPU 占用率 可能大家会问我，提到 DOM 渲染层这么深的概念有什么用啊，好像跟性能优化没一点关系啊？大家应该还记得我刚说到 GPU 会对我们的渲染层作缓存对吧，那么大家试想一下，如果我们把那些一直发生大量重排重绘的元素提取出来，单独触发一个渲染层，那样这个元素不就不会“连累”其他元素一块重绘了对吧。 那么问题来了，什么情况下会触发渲染层呢？大家只要记住： Video 元素、WebGL、Canvas、CSS3 3D、CSS 滤镜、z-index 大于某个相邻节点的元素都会触发新的 Layer，其实我们最常用的方法，就是给某个元素加上下面的样式： transform: translateZ(0); backface-visibility: hidden; 这样就可以触发渲染层啦。 我们把容易触发重排重绘的元素单独触发渲染层，让它与那些“静态”元素隔离，让 GPU 分担更多的渲染工作，我们通常把这样的措施成为硬件加速，或者是 GPU 加速。大家之前肯定听过这个说法，现在完全清楚它的原理了吧。 2.3 重排与重绘现在到我们的重头戏了，重排和重绘。先抛出概念： 重排（reflow）：渲染层内的元素布局发生修改，都会导致页面重新排列，比如窗口的尺寸发生变化、删除或添加 DOM 元素，修改了影响元素盒子大小的 CSS 属性（诸如：width、height、padding）。 重绘（repaint）：绘制，即渲染上色，所有对元素的视觉表现属性的修改，都会引发重绘。 我们习惯使用 chrome devtools 中的 performance 版块来测量页面重排重绘所占据的时间： ① 蓝色部分：HTML 解析和网络通信占用的时间 ② 黄色部分：JavaScript 语句执行所占用时间 ③ 紫色部分：重排占用时间 ④ 绿色部分：重绘占用时间 不论是重排还是重绘，都会阻塞浏览器。要提高网页性能，就要降低重排和重绘的频率和成本，近可能少地触发重新渲染。正如我们在 2.3 中提到的，重排是由 CPU 处理的，而重绘是由 GPU 处理的，CPU 的处理效率远不及 GPU，并且重排一定会引发重绘，而重绘不一定会引发重排。所以在性能优化工作中，我们更应当着重减少重排的发生。 这里给大家推荐一个网站，里面详细列出了哪些 CSS 属性在不同的渲染引擎中是否会触发重排或重绘： csstriggers.com/ （图片来自官网） 2.4.优化策略谈了那么多理论，最实际不过的，就是解决方案，大家一定都等着急了吧，做好准备，一大波干货来袭： CSS 属性读写分离：浏览器每次对元素样式进行读操作时，都必须进行一次重新渲染（重排 + 重绘），所以我们在使用 JS 对元素样式进行读写操作时，最好将两者分离开，先读后写，避免出现两者交叉使用的情况。最最最客观的解决方案，就是不用 JS 去操作元素样式，这也是我最推荐的。 通过切换 class 或者使用元素的 style.csstext 属性去批量操作元素样式。 DOM 元素离线更新：当对 DOM 进行相关操作时，例、appendChild 等都可以使用 Document Fragment 对象进行离线操作，带元素“组装”完成后再一次插入页面，或者使用 display:none 对元素隐藏，在元素“消失”后进行相关操作。 将没用的元素设为不可见：visibility: hidden，这样可以减小重绘的压力，必要的时候再将元素显示。 压缩 DOM 的深度，一个渲染层内不要有过深的子元素，少用 DOM 完成页面样式，多使用伪元素或者 box-shadow 取代。 图片在渲染前指定大小：因为 img 元素是内联元素，所以在加载图片后会改变宽高，严重的情况会导致整个页面重排，所以最好在渲染前就指定其大小，或者让其脱离文档流。 对页面中可能发生大量重排重绘的元素单独触发渲染层，使用 GPU 分担 CPU 压力。（这项策略需要慎用，得着重考量以牺牲 GPU 占用率为代价能否换来可期的性能优化，毕竟页面中存在太多的渲染层对于 GPU 而言也是一种不必要的压力，通常情况下，我们会对动画元素采取硬件加速。 3.JS 阻塞性能JavaScript 在网站开发中几乎已经确定了垄断地位，哪怕是一个再简单不过的静态页面，你都可能看到 JS 的存在，可以说，没有 JS，网站就基本告别用户交互了。然而，脚本带来的问题就是他会阻塞页面的平行下载，还会提高进程的 CPU 占用率。更有甚者，现在 node.js 已经在前端开发中普及，稍有不慎，我们引发了内存泄漏，或者在代码中误写了死循环，会直接造成我们的服务器崩溃。在如今这个 JS 已经遍布前后端的时代，性能的瓶颈不单单只是停留在影响用户体验上，还会有更多更为严重的问题，对 JS 的性能优化工作不可小觑。 在编程的过程中，如果我们使用了闭包后未将相关资源加以释放，或者引用了外链后未将其置空（比如给某 DOM 元素绑定了事件回调，后来却 remove 了该元素），都会造成内存泄漏的情况发生，进而大量占用用户的 CPU，造成卡顿或死机。我们可以使用 chrome 提供的 JavaScript Profile 版块，开启方式同 Layers 等版块，这里我就不再多说了，直接上效果图： 我们可以清楚看见 JS 执行时各函数的执行时间以及 CPU 占用情况，如果我在代码里增加一行 while(true){}, 那么它的占用率一定会飙升到一个异常的指标（亲测 93.26%）。 其实浏览器强大的内存回收机制在大多数时候避免了这一情况的发生，即便用户发生了死机，他只要结束相关进程（或关闭浏览器）就可以解决这一问题，但我们要知道，同样的情况还会发生在我们的服务器端，也就是我们的 node 中，严重的情况，会直接造成我们的服务器宕机，网站崩溃。所以更多时候，我们都使用 JavaScript Profile 版块来对我们的 node 服务进行压力测试，搭配 node-inspector 插件，我们能更有效地检测 JS 执行时各函数的 CPU 占用率，针对性地进行优化。 PS：所以没修炼到一定水平，千万别在服务端使用闭包，一个是真没啥用，我们会有更多优良的解决办法，二是真的很容易内存泄漏，造成的后果是你无法预期的 4.【拓展】负载均衡之所以将负载均衡作为拓展内容，是因为如果是你自己搭建的个人网站，或者中小型网站，其实并不需要考虑多大的并发量，但是如果你搭建的是大型网站，负载均衡便是开发过程不可或缺的步骤。 4.1.Node.js 处理 IO 密集型请求现在的开发流程都注重前后端分离，也就是软件工程中常提到的“高内聚低耦合”的思想，你也可以用模块化的思想去理解，前后解耦就相当与把一个项目分成了前端和后端两个大模块，中间通过接口联系起来，分别进行开发。这样做有什么好处？我就举最有实际效果的一点：“异步编程”。这是我自己想的名字，因为我觉得前后解耦的形式很像我们 JS 中的异步队列，传统的开发模式是“同步”的，前端需要等后端封装好接口，知道了能拿什么数据，再去开发，时间短，工程大。而解耦之后，我们只需要提前约定好接口，前后两端就可以同时开发，不仅高效而且省时。 我们都知道 node 的核心是事件驱动，通过 Event Loop 去异步处理用户请求，相比于传统的后端服务，它们都是将用户的每个请求分配一个进程进行处理，推荐大家去看这样一篇博文：mp.weixin.qq.com/s?__biz=MzA… 。特别生动地讲解了事件驱动的运行机制，通俗易懂。事件驱动的最大优势是什么？就是在高并发 IO 时，不会造成堵塞，对于直播类网站，这点是至关重要的，我们有成功的先例——快手，快手强大的 IO 高并发究其本质一定能追溯到 node。 其实现在的企业级网站，都会搭建一层 node 作为中间层。大概的网站框架如图所示： 4.2.pm2 实现 Node.js“多进程”我们都知道 node 的优劣，这里分享一份链接，找了挺久写的还算详细：www.zhihu.com/question/19… 。其实很多都是老套路，那些说 node 不行的都是指着 node 是单进程这一个软肋开撕，告诉你，我们有解决方案了——pm2。这是它的官网：pm2.keymetrics.io/ 。它是一款 node.js 进程管理器，具体的功能，就是能在你的计算机里的每一个内核都启动一个 node.js 服务，也就是说如果你的电脑或者服务器是多核处理器（现在也少见单核了吧），它就能启动多个 node.js 服务，并且它能够自动控制负载均衡，会自动将用户的请求分发至压力小的服务进程上处理。听起来这东西简直就是神器啊！而且它的功能远远不止这些，这里我就不作过多介绍了，大家知道我们在上线的时候需要用到它就行了，安装的方法也很简单，直接用 npm 下到全局就可以了 $ npm i pm2 -g 具体的使用方法还有相关特性可以参照官网。 下面是 pm2 启动后的效果图： 4.3.nginx 搭建反向代理在开始搭建工作之前，首先得知道什么是反向代理。可能大家对这个名词比较陌生，先上一张图： 所谓代理就是我们通常所说的中介，网站的反向代理就是指那台介于用户和我们真实服务器之间的服务器（说的我都拗口了），它的作用便是能够将用户的请求分配到压力较小的服务器上，其机制是轮询。听完这句话是不是感觉很耳熟，没错，在我介绍 pm2 的时候也说过同样的话，反向代理起到的作用同 pm2 一样也是实现负载均衡，你现在应该也明白了两者之间的差异，反向代理是对服务器实现负载均衡，而 pm2 是对进程实现负载均衡。大家如果想深入了解反向代理的相关知识，我推荐知乎的一个贴子：www.zhihu.com/question/24… 。但是大家会想到，配服务器是运维的事情啊，和我们前端有什么关系呢？的确，在这部分，我们的工作只有一些，只需要向运维提供一份配置文档即可。 http { upstream video { ip_hash; server localhost:3000; } server { listen: 8080; location / { proxy_pass: http://video } } } 也就是说，在和运维对接的时候，我们只需要将上面这几行代码改为我们配置好的文档发送给他就行了，其他的事情，运维小哥会明白的，不用多说，都在酒里。 但是，这几行代码该怎么去改呢？首先我们得知道，在 nginx 中，模块被分为三大类：handler、filter 和 upstream。而其中的 upstream 模块，负责完成完成网络数据的接收、处理和转发，也是我们需要在反向代理中用到的模块。接下来我们将介绍配置代码里的内容所表示的含义： 4.3.1.upstream 配置信息upstream 关键字后紧跟的标识符是我们自定义的项目名称，通过一对花括号在其中增添我们的配置信息。 ip_hash 关键字：控制用户再次访问时是否连接到前一次连接的服务器 server 关键字：我们真实服务器的地址，这里的内容肯定是需要我们去填写的，不然运维怎么知道你把项目放在那个服务器上了，也不知道你封装了一层 node 而得去监听 3000 端口。 4.3.2.server 配置信息server 是 nginx 的基本配置，我们需要通过 server 将我们定义的 upstream 应用到服务器上。 listen 关键字：服务器监听的端口 location 关键字：和我们之前在 node 层说到的路由是起同样的功能，这里是把用户的请求分配到对应的 upstream 上 5.拓展阅读网站的性能与监测是一项复杂的工程，还有很多很多后续的工作，我之前所提到的这些，也只能算是冰山一角，在熟悉开发规范的同时，也需要实践经验的积累。 在翻阅了许多与网站性能相关的书籍后，我还是更钟情于唐文前辈编著的《大型网站性能监测、分析与优化》，里面的知识较新，切合实际，至少我读完一遍后很有收获、醍醐灌顶，我也希望对性能感兴趣的读者在看完我的文章后能去翻翻这本著作。","tags":[{"name":"性能优化","slug":"性能优化","permalink":"http://coder.liusixin.cn/tags/性能优化/"}]},{"title":"HTTP 相关知识了解一下","date":"2018-05-26T04:13:04.000Z","path":"posts/a4336408/","text":"很多前端开发的同学 \b 不是特别了解 http 相关的知识，本文我们就深入去了解下 http 协议原理和实践相关的内容。 首先了解下浏览器输入 url 后 http 请求返回的过程是什么，看下图 (一) 首先一开始要做 == redirect == 重定向，那么为什么要 redirect 呢，因为浏览器可能记录了你这个地址已经永久跳转成一个新的地址，所以一开始浏览器需要判断需不需要 redirect 以及 redirect 到哪里。 (二) 看缓存，请求的资源可能已经缓存过，在 == App cache == 里看是否有缓存，如果没有缓存，就会去服务器请求资源。 \b(三) 输入域名，域名会对应 ip 之后才能真正访问到服务器，所以这时候会先去查找域名对应的 IP 地址，\b 这就叫 == DNS 解析 == (四) 有了 IP 之后，就会创建 == tcp 连接 ==，该过程要经过 tcp 的 == 三次握手 == 之后才能真正创建连接。同时如果这个请求是 https 的，就会创建 https 的链接，这跟 tcp 的三次握手不一样，中间会有一个保证安全的数据传输的过程。 (五) 连接创建好之后，才会真正发起 http 请求的数据包，数据包发送完成之后，服务器接收到这个数据并进行处理之后会 \b 返回这个请求响应的内容数据，返回数据之后这个 http 请求才真正完成 1. 网络协议分层我们先来看下经典五层模型图例： 这个五层模型中，分为应用层、传输层、网络层、数据链路层、物理层，每一个服务器上都会有这样的层级关系存在来维护整个网络数据传输的过程。 本文主要内容是 http 相关内容，所以主要是在应用层展开。http 协议基于传输层里的 TCP/IP 协议，该协议会涉及到一些 http 请求的性能，以及请求过程的消耗，\b 会面也会有一些 TCP/IP 协议的介绍。 低三层： 物理层(硬件) - 主要作用是定义物理设备如何传输数据 数据链路层 - 在通信的实体间建立数据链路连接 网络层 - 为数据在结点之间传输创建逻辑链路 1.1 传输层传输层主要有两个协议，一个是 TCP/IP，一个是 UDP。更多情况下都使用的是 TCP/IP 协议，因为它更可靠的传输数据。 向用户提供可靠的端到端(e2e)服务 个人电脑到网络服务器建立连接之后，如果传输数据很大，一次性无法完成传输，就需要分片传输，传输成功之后再重新组装。两端传输数据的方式都是在这一层定义 传输层向高层屏蔽了下层数据通信的细节 \bhttp 协议要传输数据只需在浏览器输入 url，输入 url 这个过程还涉及到一系列数据的拼装及传输，比如分包传输具体是怎么实现，服务器怎么接收，ajax 请求，整个过程传输层已经做好了封装，这个过程用户不需要知道。 1.2 应用层http 协议所在层 为应用软件提供了很多服务 构建于 TCP 协议之上 屏蔽网络传输相关细节 2. http 协议发展历史 HTTP/0.9 只有一个命令 GET 没有 HEADER 等描述数据的信息 服务器发送完毕，就关闭 TCP 连接 HTTP/1.0 增加了很多命令 增加 status code 和 header 多字符集支持、多部分发送、权限、缓存等 HTTP/1.1 持久连接 pipeline 增加 host 和其它一些命令 HTTP2 所有数据以二进制传输 同一个连接里面发送多个请求不再需要按照顺序来 头信息压缩以及推送等提高效率的功能 头信息压缩及推送 http2 解决了 http 里整体性能低下的问题，在 http1.1 里，每次发送请求和返回请求，它的 http 头都会进行一个完整传输，\b 并且很多字段都是以字符串形式保存，占用大量带宽。http2 里会将头信息进行压缩传输。 推送是什么概念呢？在 http1.1 里，客户端发起请求然后服务端响应请求返回内容，客户端永远是主动方，服务端永远是被动方。在 http2 里，服务端是可以主动发起数据传输的。比如：一个 html 页面中引入了 css 和 js，浏览器首先要对 html 进行分析，再寻找 css 和 js 对应的 url 去请求对应的文件，这就涉及到一个顺序问题，需要先请求到 html 文本，在浏览器里运行解析了这个文本之后才能发送 css 及 js 的请求。但是 \b 在 http2 中服务端可以主动把 css 及 js 文件推送到客户端，与 html 并行传输，极大提高传输效率 3. http 的连接 在客户端和服务端之间进行 http 请求的发送和返回的过程当中，需要创建一个 TCP connection。http 只有请求和响应这个概念，不存在连接，请求和响应都是数据包，之间要经过一个传输的通道，这个传输的通道就是在 tcp 里创建的一个连接(TCP connection)。这个连接可以保持状态，http 请求就是在这个连接之上发送的，所以在一个 tcp 连接上可以发送多个 http 请求。 在不同版本下，http 连接的模式不一样，在 http1.0 里，这个连接是在 http 请求创建同时创建 tcp 连接，请求结束后 tcp 连接就会关闭。 在 http1.1 里，这个连接可以通过某种方式声明是否保持连接状态。tcp 连接在创建过程中有三次握手消耗，三次握手就表示三次网络传输(客户端发送 - 服务端响应 - 客户端再次发送)，然后才能发送 http 请求。如果 tcp 连接一直保持，第二个 http 请求就没有三次握手的开销 在 http2 里不仅可以保持 \btcp\b 的连接，同时这个连接上的 http 请求可以并发，就是说同一个用户对同一个服务器发起一个网页请求时只需要一个 tcp 连接。 3.1 tcp 的三次握手 (一) 在 tcp 的三次握手当中，客户端会向服务端发起一个创建连接的数据包请求，这里会有一个标识为 SYN=1,SYN 是一个标志位，表示创建请求的数据包。后面会发送一个叫 Seq=X，X 表示数字，一般为 1。服务端接收到这个数据包之后就会知道要创建一个连接 (二) 创建 \b 连接之后，\b 服务端就会开启一个 tcp 端口，返回给客户端数据，这个数据 SYN=1,ACK=X+1,Seq=Y,客户端拿到这个数据表示服务端允许创建这个 tcp 连接。 (三) 这时候客户端再去发送 ACK=Y+1,Seq=Z。 那么 \b 为什么 tcp 要进行三次握手呢，这是为了防止服务端开启一些无用连接，网络连接具有延时性。客户端向服务端发起创建连接请求时，服务端直接创建了这个连接，返回的数据包因为网络原因丢失，那么客户端就一直接收不到服务器返回的数据，连接超时这个连接就会关闭，然后再发起新的连接，如果没有三次握手的话，这时服务端是不知道客户端到底有没有接收到返回的数据，浪费服务端的开销。所以需要三次握手去即时的察觉到网络原因导致的数据包传输中断的问题。 3.2 URI、URL、URN在 http 协议中，基本上使用的都是 URL。 URI(Uniform Resource Identifier) 统一资源标志符 用来唯一标识互联网上的信息资源 包含 URL 和 URN URL(Uniform Resource Locator) 统一资源定位器 \b URN 永久统一资源定位符 在资源移动之后还能被找到 目前还没有非常成熟的使用方案 3.3 HTTP 报文 从图中可以看到 http 首部下面有一段空行，空行下面表示 http body 部分，上面就是 http headers 部分。 3.3.1 请求报文(一) \bGET http 请求头中，首行第一部分包含的是 method 请求方法 \b，每个方法有各自的语义，分别是 GET(获取数据)、POST(创建数据)、PUT(更新数据)、DELETE(删除数据)。这几种方法只是语义上的说明，并没有强约束，\b 比如使用 GET 方法去更新数据，只是这样违反了 http 语义化的定义规则。 (二) /test/hi-there.txt 首行第二部分是请求的资源资源地址 url，一般这里是存放 \b 路由相关的内容 (三) HTTP/1.0 首行第三部分是 http 的版本，现在的 web 服务一般都是 http1.1，http2 也会有越来越多的实现，不同的版本也会有不同操作方式。 3.3.2 响应报文(一) \b200 ok http 状态码，200 代表成功 3.4 HTTP 方法 用来定义对于资源的操作 常用有 GET、POST 等 从定义上有各自的语义 方法 说明 GET | 请求指定的页面信息，并返回实体主体。HEAD | 类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头POST | 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。PUT | 从客户端向服务器传送的数据取代指定的文档的内容。DELETE | 请求服务器删除指定的页面。 3.5 HTTP CODE 定义服务器对请求的处理结果 各个区间的 CODE 有各自的语义 好的 \bHTTP 服务可以通过 CODE 判断结果 HTTP Status： 1xx（临时响应）表示临时响应并需要请求者继续执行操作的状态代码。 代码 状态 说明 100 | （继续） | 请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。101 | （切换协议） | 请求者已要求服务器切换协议，服务器已确认并准备切换。 2xx （成功）表示成功处理了请求的状态代码。 代码 状态 说明 200 | （成功） | 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。201 | （已创建） | 请求成功并且服务器创建了新的资源。202 | （已接受） | 服务器已接受请求，但尚未处理。203 | （非授权信息） | 服务器已成功处理了请求，但返回的信息可能来自另一来源。204 | （无内容） | 服务器成功处理了请求，但没有返回任何内容。205 | （重置内容） | 服务器成功处理了请求，但没有返回任何内容。206 | （部分内容） | 服务器成功处理了部分 GET 请求。 3xx （重定向）表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。 代码 状态 说明 300 | （多种选择） | 针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。301 | （永久移动） | 请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。302 | （临时移动） | 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。303 | （查看其他位置） | 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。304 | （未修改） | 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。305 | （使用代理） | 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。307 | （临时重定向） | 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 4xx（请求错误）这些状态代码表示请求可能出错，妨碍了服务器的处理。 代码 状态 说明 400 | （错误请求） | 服务器不理解请求的语法。401 | （未授权） | 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。403 | （禁止） | 服务器拒绝请求。404 | （未找到） | 服务器找不到请求的网页。405 | （方法禁用） | 禁用请求中指定的方法。406 | （不接受） | 无法使用请求的内容特性响应请求的网页。407 | （需要代理授权）| 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。408 | （请求超时）| 服务器等候请求时发生超时。409 | （冲突）| 服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。410 | （已删除） | 如果请求的资源已永久删除，服务器就会返回此响应。411 | （需要有效长度） | 服务器不接受不含有效内容长度标头字段的请求。412 | （未满足前提条件） | 服务器未满足请求者在请求中设置的其中一个前提条件。413 | （请求实体过大） | 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。414 | （请求的 URI 过长） | 请求的 URI（通常为网址）过长，服务器无法处理。415 | （不支持的媒体类型） | 请求的格式不受请求页面的支持。416 | （请求范围不符合要求） | 如果页面无法提供请求的范围，则服务器会返回此状态代码。417 | （未满足期望值） | 服务器未满足”期望”请求标头字段的要求。 5xx（服务器错误）这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。 代码 状态 说明 500 | （服务器内部错误） | 服务器遇到错误，无法完成请求。501 | （尚未实施） | 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。502 | （错误网关）| 服务器作为网关或代理，从上游服务器收到无效响应。503 | （服务不可用） | 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。504 | （网关超时） | 服务器作为网关或代理，但是没有及时从上游服务器收到请求。505 | （HTTP 版本不受支持） | 服务器不支持请求中所用的 HTTP 协议版本。 4. HTTP 客户端浏览器就是我们最常用的 http 客户端 \b 同时 curl 可以查看 http 请求返回的内容 curl 还可以查看请求的详细内容， curl -v [host] 4.1 CORS 跨域请求的限制与解决做过前端开发的同学对跨域并不会陌生，通常我们可以使用 jsonp 去实现跨域请求。 jsonp 跨域： &lt;script src=\"http://www.example.com:8080\">&lt;/script> 原理： 浏览器允许 link、img、script 标签上写入路径加载一些内容的时候，是允许跨域的。 服务端设置跨域： 这里以 express 为例，我们只需在响应头中 \b 添加 Access-Control-Allow-Origin 即可 response.writeHead(200, { 'Access-Control-Allow-Origin': '*' }) 浏览器在发送请求的时候并不知道服务是否跨域，还是会发送请求并且接收返回内容，只是在浏览器接收内容的时候 \b 没有找到 Access-Control-Allow-Origin 头设置为 \b 允许的话，它会把请求返回的内容忽略掉并且会在服务端报错。这个是浏览器所提供的功能。 实际上 Access-Control-Allow-Origin 值为 * 是不安全的，这样会导致第三方服务也可以通过跨域访问你的服务，可以设置为特定的域名 response.writeHead(200, { 'Access-Control-Allow-Origin': 'http://xxxx.com' }) 4.1.1 CORS 预请求浏览器是根据 header 判断某个请求的返回是否允许，如果 \b 想要允许自定义的头进行发送的话，需要返回新的头 \b 告知浏览器允许 response.writeHead(200, { 'Access-Control-Allow-Origin': '*', 'Access-Control-Allow-Headers': 'X-Test-Cors' }) 同时会发现 network 中多出一个请求，这就是预请求 (一) 在跨域请求中，默认允许的方法只有 GET、HEAD、POST，其它的方法默认不允许，浏览器是有一个预请求的方式去验证的。 (二) 默认允许的 Content-Type：text/plain、multipart/form-data、application/x-www-form-urlencoded。这三个就是在 html 里使用 form 表单可以设置的三种数据类型。其它的也需要预请求验证过之后才能进行发送。\b (三) 其它的请求头限制具体可以查看文档https://fetch.spec.whatwg.org/#cors-safelisted-request-header (四) XMLHttpRequestUpload 对象均没有注册任何事件监听器 (五) 请求中没有使用 ReadableStream 对象 4.2 缓存 Cache-Control 可缓存性 public（任何地方都会缓存） private（发起请求的浏览器） no-cache 可以在本地进行缓存，但是每次发起请求都要在服务端验证，如果服务端允许使用本地缓存，才能真正使用本地缓存。 到期 max-age = &lt;seconds&gt; s-maxage = &lt;seconds&gt; 在代理服务器中才会生效，代理服务器中如果两个都设置了，会优先选择 s-maxage 配置项 max-stale = &lt;secon ds&gt; 发起端设置。即便缓存失效，只要这个时间内还可以使用过期的缓存，而不需要去原服务器请求新的内容。 重新验证(不常用) \bmust-revalidate 在设置了 max-age 缓存中如果过期，必须去原服务端发送请求 \b 然后重新获取数据再来验证内容是否真的过期，而不能直接使用本地缓存。 proxy-revalidate 和 must-revalidate 类似，但是用在缓存服务器当中。 其它 no-store 与 no-cache 对应，表示任何情况下都不会存储缓存，永远都要去服务端请求新的内容才能使用它。即便服务端允许使用缓存，但本地 \b 没有进行缓存 no-transform 用在 proxy 服务器，有些 proxy 服务器返回资源过大，会帮助进行压缩及格式转换，该属性会不允许。 没有缓存情况下请求资源 设置客户端缓存后 response.writeHead(200, { 'Content-Type': 'text/javascript', 'Cache-Control': 'max-age=200' }) response.end('console.log(\"script loaded\")') 可以看到 Size 变为了 == (from memory cache) ==，表示从浏览器中读取缓存。 在做前端开发的时候，有些静态资源文件我们希望浏览器缓存下来，但是在服务端内容更新之后，客户端请求的是缓存下的旧资源文件，这样就没法更新应用。 目前最常见的方式就是前端编译的时候加静态资源文件 md\b5 戳。 4.3 资源验证首先看一张图 浏览器创建请求，请求到达本地缓存(如果有 cache-control)，如果有本地缓存，就直接返回给浏览器显示出来，不经过任何网络传输。如果没有本地缓存，请求进入网络传输，\b 如果有代理服务器就会进入并查找缓存设置，查看资源是否被缓存，有缓存就返回缓存资源经过本地缓存再到浏览器显示。如果代理服务器未缓存，就会进入原服务器获取新的内容再返回。 4.3.1 验证头 Last-Modified 上次修改时间 配合 If-Modified-Since 或者 If-Unmodified-Since 使用 浏览器在请求资源的 headers 里有 Last-Modified 这个头，并指定了时间，这个时间内下次浏览器发起请求时就会带上 Last-Modified传入的值，通过 If-Modified-Since 或 If-Unmodified-Since(通常为 If-Modified-Since)带到服务器上，服务器通过读取 headers 里 If-Modified-Since 带入的值找到资源存在的地方对比上次修改的时间，如果时间一样，就表示资源没有被重新修改过，服务器就通知浏览器直接使用缓存的资源，这就是资源验证的过程。 Etag(更加严格的验证方式) 数据签名 - 对内容产生唯一的签名 配合 If-Match 或者 If-Non-Match 使用 有任何的修改两个签名就会不一样，最典型的做法就是对资源内容做哈希计算，计算之后会得到一个唯一值，用这个签名来标记这个资源，下一次浏览器发起请求时会带上If-Match 或者 If-Non-Match 头，这个头的值就是服务端返回 Etag 的值，然后对比服务器拿到浏览器传入的签名和服务器存在的签名，如果相同，就不需要返回新的内容。 4.4 Cookie 和 Session Cookie 通过 Set-Cookie 设置 下次请求会自动带上 键值对，可以设置多个 Cookie 属性 max-age(有效时间)和 expires(到某个时间点过期)设置过期时间 Secure 只在 https 的时候发送 HttpOnly 无法通过 document.cookie 访问 // Cookie设置，以express为例 response.writeHead(200, { 'Content-Type': 'text/html', 'Set-Cookie': 'name=hello' }) // 设置多个 'Set-Cookie': ['name=hello', 'age=12'] // 过期时间 'Set-Cookie': ['name=hello; max-age=2', 'age=12'] // 禁止js访问cookie 'Set-Cookie': ['name=hello', 'age=12; HttpOnly'] // 子域名共享主域名cookie，前提是cookie要在主域名下设置 'Set-Cookie': ['name=hello', 'age=12; domain=example.com'] Session session 机制是一种服务器端的机制，服务器使用一种类似于散列表的结构（也可能就是使用散列表）来保存信息。 当程序需要为某个客户端的请求创建一个 session 的时候，服务器首先检查这个客户端的请求里是否已包含了一个 session 标识 - 称为 session id，如果已包含一个 session id 则说明以前已经为此客户端创建过 session，服务器就按照 session id 把这个 session 检索出来使用（如果检索不到，可能会新建一个），如果客户端请求不包含 session id，则为此客户端创建一个 session 并且生成一个与此 session 相关联的 session id，session id 的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串，这个 session id 将被在本次响应中返回给客户端保存。 保存这个 session id 的方式可以采用 cookie，这样在交互过程中浏览器可以自动的按照规则把这个标识发挥给服务器。一般这个 cookie 的名字都是类似于SEEESIONID，而。比如 weblogic 对于 web 应用程序生成的 cookie，JSESSIONID=ByOK3vjFD75aPnrF7C2HmdnV6QZcEbzWoWiBYEnLerjQ99zWpBng!-145788764，它的名字就是JSESSIONID。 由于 cookie 可以被人为的禁止，必须有其他机制以便在 cookie 被禁止时仍然能够把 session id 传递回服务器。经常被使用的一种技术叫做 URL 重写，就是把 session id 直接附加在 URL 路径的后面，附加方式也有两种，一种是作为 URL 路径的附加信息，表现形式为http://...../xxx;jsessionid=ByOK3vjFD75aPnrF7C2HmdnV6QZcEbzWoWiBYEnLerjQ99zWpBng!-145788764 另一种是作为查询字符串附加在 URL 后面，表现形式为http://...../xxx?jsessionid=ByOK3vjFD75aPnrF7C2HmdnV6QZcEbzWoWiBYEnLerjQ99zWpBng!-145788764 这两种方式对于用户来说是没有区别的，只是服务器在解析的时候处理的方式不同，采用第一种方式也有利于把 session id 的信息和正常程序参数区分开来。为了在整个交互过程中始终保持状态，就必须在每个客户端可能请求的路径后面都包含这个 session id。 另一种技术叫做表单隐藏字段。就是服务器会自动修改表单，添加一个隐藏字段，以便在表单提交时能够把 session id 传递回服务器。比如下面的表单： &lt;form name=\"testform\" action=\"/xxx\"> &lt;input type=\"text\"> &lt;/form> 在被传递给客户端之前将被改写成： &lt;form name=\"testform\" action=\"/xxx\"> &lt;input type=\"hidden\" name=\"jsessionid\" value=\"ByOK3vjFD75aPnrF7C2HmdnV6QZcEbzWoWiBYEnLerjQ99zWpBng!-145788764\"> &lt;input type=\"text\"> &lt;/form> 这种技术现在已较少应用，实际上这种技术可以简单的用对 action 应用 URL 重写来代替。 4.5 HTTP 长连接http 的请求是在 tcp 的连接上进行发送的，tcp 连接又分为长连接和短连接。 长连接就是在 tcp 连接上把 http 请求发送并接收返回，这个时候一次 http 请求已经结束，浏览器和服务器会协商是否断掉这个连接，长连接就是在不断掉连接下可以持续发送 http 请求，适合高并发。 在 Connection Id 这一栏可以看到很多 10247 的相同 id，表示这些请求都是在同一连接下发送的。但还是会有不同的连接，因为 http1.1 的连接在 tcp 连接上发送请求是有先后顺序的，不会并发请求。 我们希望在加载网站首页的时候可以并发处理这些请求，浏览器可以允许产生一个并发的创建 tcp 连接，chrome 允许最大并发数为 6。 可以看到，并发情况下会创建不同的 tcp 连接，chrome 如果超出了 6 个并发，后面的请求会等待前面的完成，并且会尽量复用前面的连接地址而保持长连接，这是浏览器默认的行为。 可以手动关闭长连接 response.writeHead(200, { 'Content-Type': 'image/jpg', 'Connection': 'close' }) 关闭长连接之后可以发现每次连接 id 都会不一样，后面的也会等待前面的完成，没有重复利用 tcp 连接，每次请求发送完成 tcp 连接就会关闭。 一般情况下 keep-alive 都是开启的，并且 \b 会设置一个自动关闭时间。 信道复用 在 tcp 连接上并发的发送 http 请求，也就是说在连接一个网站时只需一个 tcp 连接，只在同域下请求有效，http2 实现了这个功能。 4.6 数据协商在客户端发送给服务端请求的时候，客户端会声明这个请求拿到的数据格式以及数据相关的一些限制是怎样的，服务端会根据客户端的这个声明做出判断，从而返回不同的数据类型格式。 分类 请求 Accept Accept-Encoding Accept-Language User-Agent 返回 Content-Type Content-Encoding Content-Language MIME_types 相关对照表看这里文档 4.7 Redirect在开发中，我们存放资源的位置如果发生了改变，页面在请求时就会报 404 错误，为了避免这种错误，需要帮助浏览器指向到正确的地址。 http.createServer(function(req, res) { if(req.url === '/'){ res.writeHead(302, { 'Location': '/new' }) res.end('') } if(req.url === '/new'){ res.writeHead(200, { 'Content-Type': 'text/html' }) res.end('&lt;div>web&lt;/div>') } }) 图中可以看到第一次请求页面状态码为 302，并跳转到了 new 这个 url 下。 但是 302 是临时跳转，每一次 \b 访问都要经过服务端的跳转，图中也可以看到有两个 url 的请求。如果确定每次访问 / 下都会跳转到 new 下，可以指定状态码为 301 永久跳转，这样访问页面就只出现 new。 需要注意的是，301 会尽可能长时间的把跳转页面缓存下来，这时候服务端即使修改了 url，浏览器还是会从缓存里读取，这个是有用户使用浏览器情况所决定的，除非用户主动去清理浏览器缓存。所以 301 要慎重处理。 4.8 CSPContent-Security-Policy 内容安全策略，这使得浏览器变得更加安全。 作用 限制资源获取 报告资源获取越权 限制方式 default-src 限制全局 制定资源类型 connect-src img-src manifest-src font-src media-src style-src frame-src script-src res.writeHead(200, { 'Content-Type': 'text/html', 'Content-Security-Policy': 'default-src http: https:' }) 加入限制之后浏览器就会阻止 js 脚本的加载并报错 只允许本站下的资源 res.writeHead(200, { 'Content-Type': 'text/html', 'Content-Security-Policy': 'default-src \\'self\\'' }) 允许某些站点的内容 res.writeHead(200, { 'Content-Type': 'text/html', 'Content-Security-Policy': 'default-src \\'self\\' http://www.example.com/' }) 限制 form 表单的 \b 跳转 res.writeHead(200, { 'Content-Type': 'text/html', 'Content-Security-Policy': 'default-src \\'self\\'; form-action \\'self\\'' }) 详细内容可以查看 csp 文档 MDN CSP 内容安全策略如果出现了不希望出现的情况下，可以申请主动向服务端发起请求来汇报 res.writeHead(200, { 'Content-Type': 'text/html', 'Content-Security-Policy': 'default-src \\'self\\' report-uri /report' }) 如果我们只想对限制进行错误报告而不阻止资源加载的话，可以这么写 res.writeHead(200, { 'Content-Type': 'text/html', 'Content-Security-Policy-Report-Only': 'default-src \\'self\\'' }) scp不仅可以写在 headers 里，还可以在html的meta标签里写 &lt;meta http-equiv=\"Content-Security-Policy\" content=\"default-src 'self'\"> 在meta下是不允许写 report-uri 的，这个指令只能写在 headers 里。 5. Nginx 代理服务器5.1 基础代理配置nginx 是现在互联网界用的最多的 web 服务器，它是一个非常纯粹的做 http 协议实现的服务器，并没有一个工具来实现业务逻辑的开发。主要是用来做 http 的代理服务器。 nginx 的安装和用法可以查网上相关教程。这里介绍的主要是 nginx 的代理和缓存的功能。 \b 一个最简单的代理 // nginx.conf server { listen 80; server_name test.com; location / { proxy_pass http://127.0.0.1:8888; # proxy_set_header Host $host; } } 可以看到，浏览器下 host 是 test.com，但在服务器下就变成了 127.0.0.1:8888。这是因为设置了代理，浏览器请求是发送到 nginx 的，nginx 再进行转发，发送到实际的 node 服务，这时候作为发起方，\b 它认为的 host 就是这里设置的 proxy_pass。 想要拿到浏览器的 host 。可以设置 proxy_set_header 属性 $host。 中间代理可以修改任何想要修改的数据，但只是在 http 中，https 的传输过程是加密的，中间代理无法解析。在手机上所看到的一些移动联通的 \b 广告就是 \b 经过代理层插入了一些代码所展示的。 5.2 nginx 缓存# nginx.conf proxy_cache_path cache levels=1:2 keys_zone=my_cache:10m; server { listen 80; server_name example.com; location / { proxy_cache my_cache; proxy_pass http://127.0.0.1:8080; proxy_set_header Host $host; } } proxy_cache_path：第一个选项表示缓存路径，levels 是否创建二级文件夹，keys_zone url 对应的缓存位置及内存大小 response.writeHead(200, { 'Cache-Control': 'max-age=10, s-maxage=10, private' }) s-maxage 是专门为代理缓存设置过期时间的，而 private 就表示只允许浏览器缓存。 5.3 HTTPS https 在传输过程中，客户端会生成一个随机数传输到服务端，中间会带上一个 \b 支持的加密套件，服务端拿到之后保存并且也生成一段随机数，然后把这段随机数和服务端生成的证书一同发到客户端，同时客户端也会把服务端的随机数保存，并且通过服务端证书生成预主秘钥，生成过程也会生成一个随机数，这个随机数 \b 通过公钥加密后传输给服务端，服务端通过私钥解密拿到预主秘钥。然后客户端和服务端同时对这 \b 三个随机数进行算法解密生成主密钥(这里会涉及到加密套件，服务端选择的加密套件必须是客户端所支持的)，后续的数据传输都是经过主密钥加密进行传输的。这对主密钥只有客户端和服务端共有，中间代理无法破解 \b，这就是 https 的加密原理。 这里是通过抓取工具抓的 https 加密的站点，可以看到，数据都被加密，无法破解。 5.3.1 nginx 部署 https 服务要部署 https 服务，首先要生成一对公钥和私钥，这里有一个 \b 命令可以帮助生成 openssl req -x509 -newkey rsa:2048 -nodes -sha256 -keyout localhost-privkey.pem -out localhost-cert.pem 敲入回车之后可以看到这样的提示，这里我们测试，全部按回车跳过就好。 最终会生成两个文件，然后在 nginx 配置这个证书 // nginx.conf proxy_cache_path cache levels=1:2 keys_zone=my_cache:10m; server { listen 80 default_server; listen [::]:80 default_server; server_name test.com; return 302 https://$server_name$request_uri; } server { listen 443; server_name test.com; ssl on; ssl_certificate_key /www/data/cert/localhost-privkey.pem; ssl_certificate /www/data/cert/localhost-cert.pem; location / { proxy_cache my_cache; proxy_pass http://127.0.0.1:8080; proxy_set_header Host $host; } } ssl on; ssl_certificate_key /www/data/cert/localhost-privkey.pem; ssl_certificate /www/data/cert/localhost-cert.pem; location / { proxy_cache my_cache; proxy_pass http://127.0.0.1:8080; proxy_set_header Host $host; } } 配置好之后重启 nginx 服务，然后输入 https 的域名 提示非安全连接是因为 chrome 浏览器认为的安全证书是要通过有权威的机构去签发的，这种机构会先认证域名所有者与服务是否属于你，验证通过才会签发证书。 5.3.2 http2 优势 信道复用 分帧传输 Server Push(推送) http2 的使用 res.writeHead(200, { 'Content-Type': 'text/html', 'Link': '&lt;/test.jpg>; as=image; rel=preload' }) server 头信息了的 Link可以指定这个头想要推送的内容，&lt;/xxx&gt; 为文件绝对路径，as 指定文件类型，preload 表示需要进行服务端推送。 nginx 里也要做这些配置。在使用 nginx 做反向代理时，我们希望 nginx 帮助处理这些东西，而 http2 也是在 nginx 里提供的，node server 还是 \b 为 http 的服务，nginx 会把 http2 的请求转化为 http 的请求发送到 node 服务上。\b 为何不在 node 上做 http2 的服务呢，因为在 nginx 开启一个 http2 的服务是非常容易的，在 node 上做 http2 的服务可能还会涉及到大量的逻辑修改，成本开销比较大。 需要注意的是，目前只有在 https 下才能开启 http2 在 nginx 下开启 http2 很简单。 // nginx.conf proxy_cache_path cache levels=1:2 keys_zone=my_cache:10m; server { listen 80 default_server; listen [::]:80 default_server; server_name test.com; return 302 https://$server_name$request_uri; } server { listen 443 http2; server_name test.com; http2_push_preload on; ssl on; ssl_certificate_key /www/data/cert/localhost-privkey.pem; ssl_certificate /www/data/cert/localhost-cert.pem; location / { proxy_cache my_cache; proxy_pass http://127.0.0.1:8080; proxy_set_header Host $host; } } http2_push_preload 开启之后，在接收 node 返回信息里如果有 \b Link：rel=preload，就会去寻找该路径资源，然后主动推送。 可以看到 Protocal 值为 h2，这个就是 http2 的缩写。 这里有一个可以测试 http2 性能的网站 网站入口 可以看到，使用 HTTP2 的性能提升非常显著。 有些浏览器不支持 http2，nginx 会帮助浏览器做兼容处理，这个兼容方案为 ALPN ，客户端跟服务端会进行协商用哪个协议，如果客户端只支持 http1.1，服务端就会以 http1.1 的传输方式进行。 以上就是对 http 知识的总结","tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://coder.liusixin.cn/tags/HTTP/"},{"name":"性能优化","slug":"性能优化","permalink":"http://coder.liusixin.cn/tags/性能优化/"}]},{"title":"Docker 常用命令及实践","date":"2018-05-24T11:30:13.000Z","path":"posts/a0b65e8c/","text":"Docker 虚拟机常用命令1. 先更新软件包yum -y update 2. 安装 Docker 虚拟机yum install -y docker 3. 运行、重启、关闭 Docker 虚拟机service docker start service docker start service docker stop 4. 搜索镜像docker search 镜像名称 5. 下载镜像docker pull 镜像名称 6. 查看镜像docker images 7. 删除镜像docker rmi 镜像名称 8. 运行容器docker run 启动参数 镜像名称 9. 查看容器列表docker ps -a 10. 停止、挂起、恢复容器docker stop 容器ID docker pause 容器ID docker unpase 容器ID 11. 查看容器信息docker inspect 容器ID 12. 删除容器docker rm 容器ID 13. 数据卷管理docker volume create 数据卷名称 #创建数据卷 docker volume rm 数据卷名称 #删除数据卷 docker volume inspect 数据卷名称 #查看数据卷 14. 网络管理docker network ls 查看网络信息 docker network create --subnet=网段 网络名称 docker network rm 网络名称 15. 避免 VM 虚拟机挂起恢复之后，Docker 虚拟机断网vi /etc/sysctl.conf 文件中添加net.ipv4.ip_forward=1这个配置 #重启网络服务 systemctl restart network 安装 PXC 集群，负载均衡，双机热备1. 安装 PXC 镜像docker pull percona/percona-xtradb-cluster 2. 为 PXC 镜像改名docker tag percona/percona-xtradb-cluster pxc 3. 创建 net1 网段docker network create --subnet=172.18.0.0/16 net1 4. 创建 5 个数据卷docker volume create --name v1 docker volume create --name v2 docker volume create --name v3 docker volume create --name v4 docker volume create --name v5 5. 创建备份数据卷（用于热备份数据）docker volume create --name backup 6. 创建 5 节点的 PXC 集群注意，每个 MySQL 容器创建之后，因为要执行 PXC 的初始化和加入集群等工作，耐心等待 1 分钟左右再用客户端连接 MySQL。另外，必须第 1 个 MySQL 节点启动成功，用 MySQL 客户端能连接上之后，再去创建其他 MySQL 节点。 #创建第1个MySQL节点 docker run -d -p 3306:3306 -e MYSQL_ROOT_PASSWORD=abc123456 -e CLUSTER_NAME=PXC -e XTRABACKUP_PASSWORD=abc123456 -v v1:/var/lib/mysql -v backup:/data --privileged --name=node1 --net=net1 --ip 172.18.0.2 pxc #创建第2个MySQL节点 docker run -d -p 3307:3306 -e MYSQL_ROOT_PASSWORD=abc123456 -e CLUSTER_NAME=PXC -e XTRABACKUP_PASSWORD=abc123456 -e CLUSTER_JOIN=node1 -v v2:/var/lib/mysql -v backup:/data --privileged --name=node2 --net=net1 --ip 172.18.0.3 pxc #创建第3个MySQL节点 docker run -d -p 3308:3306 -e MYSQL_ROOT_PASSWORD=abc123456 -e CLUSTER_NAME=PXC -e XTRABACKUP_PASSWORD=abc123456 -e CLUSTER_JOIN=node1 -v v3:/var/lib/mysql --privileged --name=node3 --net=net1 --ip 172.18.0.4 pxc #创建第4个MySQL节点 docker run -d -p 3309:3306 -e MYSQL_ROOT_PASSWORD=abc123456 -e CLUSTER_NAME=PXC -e XTRABACKUP_PASSWORD=abc123456 -e CLUSTER_JOIN=node1 -v v4:/var/lib/mysql --privileged --name=node4 --net=net1 --ip 172.18.0.5 pxc #创建第5个MySQL节点 docker run -d -p 3310:3306 -e MYSQL_ROOT_PASSWORD=abc123456 -e CLUSTER_NAME=PXC -e XTRABACKUP_PASSWORD=abc123456 -e CLUSTER_JOIN=node1 -v v5:/var/lib/mysql -v backup:/data --privileged --name=node5 --net=net1 --ip 172.18.0.6 pxc 7. 安装 Haproxy 镜像docker pull haproxy 8. 宿主机上编写 Haproxy 配置文件vi /home/soft/haproxy.cfg 配置文件如下： global #工作目录 chroot /usr/local/etc/haproxy #日志文件，使用rsyslog服务中local5日志设备（/var/log/local5），等级info log 127.0.0.1 local5 info #守护进程运行 daemon defaults log global mode http #日志格式 option httplog #日志中不记录负载均衡的心跳检测记录 option dontlognull #连接超时（毫秒） timeout connect 5000 #客户端超时（毫秒） timeout client 50000 #服务器超时（毫秒） timeout server 50000 #监控界面 listen admin_stats #监控界面的访问的IP和端口 bind 0.0.0.0:8888 #访问协议 mode http #URI相对地址 stats uri /dbs #统计报告格式 stats realm Global\\ statistics #登陆帐户信息 stats auth admin:abc123456 #数据库负载均衡 listen proxy-mysql #访问的IP和端口 bind 0.0.0.0:3306 #网络协议 mode tcp #负载均衡算法（轮询算法） #轮询算法：roundrobin #权重算法：static-rr #最少连接算法：leastconn #请求源IP算法：source balance roundrobin #日志格式 option tcplog #在MySQL中创建一个没有权限的haproxy用户，密码为空。Haproxy使用这个账户对MySQL数据库心跳检测 option mysql-check user haproxy server MySQL_1 172.18.0.2:3306 check weight 1 maxconn 2000 server MySQL_2 172.18.0.3:3306 check weight 1 maxconn 2000 server MySQL_3 172.18.0.4:3306 check weight 1 maxconn 2000 server MySQL_4 172.18.0.5:3306 check weight 1 maxconn 2000 server MySQL_5 172.18.0.6:3306 check weight 1 maxconn 2000 #使用keepalive检测死链 option tcpka 9. 创建两个 Haproxy 容器#创建第1个Haproxy负载均衡服务器 docker run -it -d -p 4001:8888 -p 4002:3306 -v /home/soft/haproxy:/usr/local/etc/haproxy --name h1 --privileged --net=net1 --ip 172.18.0.7 haproxy #进入h1容器，启动Haproxy docker exec -it h1 bash haproxy -f /usr/local/etc/haproxy/haproxy.cfg #创建第2个Haproxy负载均衡服务器 docker run -it -d -p 4003:8888 -p 4004:3306 -v /home/soft/haproxy:/usr/local/etc/haproxy --name h2 --privileged --net=net1 --ip 172.18.0.8 haproxy #进入h2容器，启动Haproxy docker exec -it h2 bash haproxy -f /usr/local/etc/haproxy/haproxy.cfg 10. Haproxy 容器内安装 Keepalived，设置虚拟 IP#进入h1容器 docker exec -it h1 bash #更新软件包 apt-get update #安装VIM apt-get install vim #安装Keepalived apt-get install keepalived #编辑Keepalived配置文件（参考下方配置文件） vim /etc/keepalived/keepalived.conf #启动Keepalived service keepalived start #宿主机执行ping命令 ping 172.18.0.201 配置文件内容如下： vrrp_instance VI_1 { state MASTER interface eth0 virtual_router_id 51 priority 100 advert_int 1 authentication { auth_type PASS auth_pass 123456 } virtual_ipaddress { 172.18.0.201 } } #进入h2容器 docker exec -it h2 bash #更新软件包 apt-get update #安装VIM apt-get install vim #安装Keepalived apt-get install keepalived #编辑Keepalived配置文件 vim /etc/keepalived/keepalived.conf #启动Keepalived service keepalived start #宿主机执行ping命令 ping 172.18.0.201 配置文件内容如下： vrrp_instance VI_1 { state MASTER interface eth0 virtual_router_id 51 priority 100 advert_int 1 authentication { auth_type PASS auth_pass 123456 } virtual_ipaddress { 172.18.0.201 } } 11. 宿主机安装 Keepalived，实现双击热备#宿主机执行安装Keepalived yum -y install keepalived #修改Keepalived配置文件 vi /etc/keepalived/keepalived.conf #启动Keepalived service keepalived start Keepalived 配置文件如下： vrrp_instance VI_1 { state MASTER interface ens33 virtual_router_id 51 priority 100 advert_int 1 authentication { auth_type PASS auth_pass 1111 } virtual_ipaddress { 192.168.99.150 } } virtual_server 192.168.99.150 8888 { delay_loop 3 lb_algo rr lb_kind NAT persistence_timeout 50 protocol TCP real_server 172.18.0.201 8888 { weight 1 } } virtual_server 192.168.99.150 3306 { delay_loop 3 lb_algo rr lb_kind NAT persistence_timeout 50 protocol TCP real_server 172.18.0.201 3306 { weight 1 } } 12. 热备份数据#进入node1容器 docker exec -it node1 bash #更新软件包 apt-get update #安装热备工具 apt-get install percona-xtrabackup-24 #全量热备 innobackupex --user=root --password=abc123456 /data/backup/full 13. 冷还原数据停止其余 4 个节点，并删除节点 docker stop node2 docker stop node3 docker stop node4 docker stop node5 docker rm node2 docker rm node3 docker rm node4 docker rm node5 node1 容器中删除 MySQL 的数据 #删除数据 rm -rf /var/lib/mysql/* #清空事务 innobackupex --user=root --password=abc123456 --apply-back /data/backup/full/2018-04-15_05-09-07/ #还原数据 innobackupex --user=root --password=abc123456 --copy-back /data/backup/full/2018-04-15_05-09-07/ 重新创建其余 4 个节点，组件 PXC 集群 安装 Redis，配置 RedisCluster 集群1. 安装 Redis 镜像docker pull yyyyttttwwww/redis 2. 创建 net2 网段docker network create --subnet=172.19.0.0/16 net2 3. 创建 6 节点 Redis 容器docker run -it -d --name r1 -p 5001:6379 --net=net2 --ip 172.19.0.2 redis bash docker run -it -d --name r2 -p 5002:6379 --net=net2 --ip 172.19.0.3 redis bash docker run -it -d --name r3 -p 5003:6379 --net=net2 --ip 172.19.0.4 redis bash docker run -it -d --name r4 -p 5004:6379 --net=net2 --ip 172.19.0.5 redis bash docker run -it -d --name r5 -p 5005:6379 --net=net2 --ip 172.19.0.6 redis bash 4. 启动 6 节点 Redis 服务器#进入r1节点 docker exec -it r1 bash cp /home/redis/redis.conf /usr/redis/redis.conf cd /usr/redis/src ./redis-server ../redis.conf #进入r2节点 docker exec -it r2 bash cp /home/redis/redis.conf /usr/redis/redis.conf cd /usr/redis/src ./redis-server ../redis.conf #进入r3节点 docker exec -it r3 bash cp /home/redis/redis.conf /usr/redis/redis.conf cd /usr/redis/src ./redis-server ../redis.conf #进入r4节点 docker exec -it r4 bash cp /home/redis/redis.conf /usr/redis/redis.conf cd /usr/redis/src ./redis-server ../redis.conf #进入r5节点 docker exec -it r5 bash cp /home/redis/redis.conf /usr/redis/redis.conf cd /usr/redis/src ./redis-server ../redis.conf #进入r6节点 docker exec -it r6 bash cp /home/redis/redis.conf /usr/redis/redis.conf cd /usr/redis/src ./redis-server ../redis.conf 5. 创建 Cluster 集群#在r1节点上执行下面的指令 cd /usr/redis/src mkdir -p ../cluster cp redis-trib.rb ../cluster/ cd ../cluster #创建Cluster集群 ./redis-trib.rb create --replicas 1 172.19.0.2:6379 172.19.0.3:6379 172.19.0.4:6379 172.19.0.5:6379 172.19.0.6:6379 172.19.0.7:6379 打包部署后端项目1. 进入人人开源后端项目，执行打包（修改配置文件，更改端口，打包三次生成三个 JAR 文件）mvn clean install -Dmaven.test.skip=true 2. 安装 Java 镜像docker pull java 3. 创建 3 节点 Java 容器#创建数据卷，上传JAR文件 docker volume create j1 #启动容器 docker run -it -d --name j1 -v j1:/home/soft --net=host java #进入j1容器 docker exec -it j1 bash #启动Java项目 nohup java -jar /home/soft/renren-fast.jar #创建数据卷，上传JAR文件 docker volume create j2 #启动容器 docker run -it -d --name j2 -v j2:/home/soft --net=host java #进入j1容器 docker exec -it j2 bash #启动Java项目 nohup java -jar /home/soft/renren-fast.jar #创建数据卷，上传JAR文件 docker volume create j3 #启动容器 docker run -it -d --name j3 -v j3:/home/soft --net=host java #进入j1容器 docker exec -it j3 bash #启动Java项目 nohup java -jar /home/soft/renren-fast.jar 4. 安装 Nginx 镜像docker pull nginx 5. 创建 Nginx 容器，配置负载均衡宿主机上/home/n1/nginx.conf 配置文件内容如下： user nginx; worker_processes 1; error_log /var/log/nginx/error.log warn; pid /var/run/nginx.pid; events { worker_connections 1024; } http { include /etc/nginx/mime.types; default_type application/octet-stream; log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' '$status $body_bytes_sent \"$http_referer\" ' '\"$http_user_agent\" \"$http_x_forwarded_for\"'; access_log /var/log/nginx/access.log main; sendfile on; #tcp_nopush on; keepalive_timeout 65; #gzip on; proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; client_max_body_size 10m; client_body_buffer_size 128k; proxy_connect_timeout 5s; proxy_send_timeout 5s; proxy_read_timeout 5s; proxy_buffer_size 4k; proxy_buffers 4 32k; proxy_busy_buffers_size 64k; proxy_temp_file_write_size 64k; upstream tomcat { server 192.168.99.104:6001; server 192.168.99.104:6002; server 192.168.99.104:6003; } server { listen 6101; server_name 192.168.99.104; location / { proxy_pass http://tomcat; index index.html index.htm; } } } 创建第 1 个 Nginx 节点 docker run -it -d --name n1 -v /home/n1/nginx.conf:/etc/nginx/nginx.conf --net=host --privileged nginx 宿主机上/home/n2/nginx.conf 配置文件内容如下： user nginx; worker_processes 1; error_log /var/log/nginx/error.log warn; pid /var/run/nginx.pid; events { worker_connections 1024; } http { include /etc/nginx/mime.types; default_type application/octet-stream; log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' '$status $body_bytes_sent \"$http_referer\" ' '\"$http_user_agent\" \"$http_x_forwarded_for\"'; access_log /var/log/nginx/access.log main; sendfile on; #tcp_nopush on; keepalive_timeout 65; #gzip on; proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; client_max_body_size 10m; client_body_buffer_size 128k; proxy_connect_timeout 5s; proxy_send_timeout 5s; proxy_read_timeout 5s; proxy_buffer_size 4k; proxy_buffers 4 32k; proxy_busy_buffers_size 64k; proxy_temp_file_write_size 64k; upstream tomcat { server 192.168.99.104:6001; server 192.168.99.104:6002; server 192.168.99.104:6003; } server { listen 6102; server_name 192.168.99.104; location / { proxy_pass http://tomcat; index index.html index.htm; } } } 创建第 2 个 Nginx 节点 docker run -it -d --name n2 -v /home/n2/nginx.conf:/etc/nginx/nginx.conf --net=host --privileged nginx 6. 在 Nginx 容器安装 Keepalived#进入n1节点 docker exec -it n1 bash #更新软件包 apt-get update #安装VIM apt-get install vim #安装Keepalived apt-get install keepalived #编辑Keepalived配置文件(如下) vim /etc/keepalived/keepalived.conf #启动Keepalived service keepalived start vrrp_instance VI_1 { state MASTER interface ens33 virtual_router_id 51 priority 100 advert_int 1 authentication { auth_type PASS auth_pass 123456 } virtual_ipaddress { 192.168.99.151 } } virtual_server 192.168.99.151 6201 { delay_loop 3 lb_algo rr lb_kind NAT persistence_timeout 50 protocol TCP real_server 192.168.99.104 6101 { weight 1 } } #进入n1节点 docker exec -it n2 bash #更新软件包 apt-get update #安装VIM apt-get install vim #安装Keepalived apt-get install keepalived #编辑Keepalived配置文件(如下) vim /etc/keepalived/keepalived.conf #启动Keepalived service keepalived start vrrp_instance VI_1 { state MASTER interface ens33 virtual_router_id 51 priority 100 advert_int 1 authentication { auth_type PASS auth_pass 123456 } virtual_ipaddress { 192.168.99.151 } } virtual_server 192.168.99.151 6201 { delay_loop 3 lb_algo rr lb_kind NAT persistence_timeout 50 protocol TCP real_server 192.168.99.104 6102 { weight 1 } } 打包部署前端项目1. 在前端项目路径下执行打包指令npm run build 2. build 目录的文件拷贝到宿主机的/home/fn1/renren-vue、/home/fn2/renren-vue、/home/fn3/renren-vue 的目录下面3. 创建 3 节点的 Nginx，部署前端项目宿主机/home/fn1/nginx.conf 的配置文件 user nginx; worker_processes 1; error_log /var/log/nginx/error.log warn; pid /var/run/nginx.pid; events { worker_connections 1024; } http { include /etc/nginx/mime.types; default_type application/octet-stream; log_format main &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39; &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39; &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;; access_log /var/log/nginx/access.log main; sendfile on; #tcp_nopush on; keepalive_timeout 65; #gzip on; proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; client_max_body_size 10m; client_body_buffer_size 128k; proxy_connect_timeout 5s; proxy_send_timeout 5s; proxy_read_timeout 5s; proxy_buffer_size 4k; proxy_buffers 4 32k; proxy_busy_buffers_size 64k; proxy_temp_file_write_size 64k; server { listen 6501; server_name 192.168.99.104; location / { root /home/fn1/renren-vue; index index.html; } } } #启动第fn1节点 docker run -it -d --name fn1 -v /home/fn1/nginx.conf:/etc/nginx/nginx.conf -v /home/fn1/renren-vue:/home/fn1/renren-vue --privileged --net=host nginx 宿主机/home/fn2/nginx.conf 的配置文件 user nginx; worker_processes 1; error_log /var/log/nginx/error.log warn; pid /var/run/nginx.pid; events { worker_connections 1024; } http { include /etc/nginx/mime.types; default_type application/octet-stream; log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' '$status $body_bytes_sent \"$http_referer\" ' '\"$http_user_agent\" \"$http_x_forwarded_for\"'; access_log /var/log/nginx/access.log main; sendfile on; #tcp_nopush on; keepalive_timeout 65; #gzip on; proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; client_max_body_size 10m; client_body_buffer_size 128k; proxy_connect_timeout 5s; proxy_send_timeout 5s; proxy_read_timeout 5s; proxy_buffer_size 4k; proxy_buffers 4 32k; proxy_busy_buffers_size 64k; proxy_temp_file_write_size 64k; server { listen 6502; server_name 192.168.99.104; location / { root /home/fn2/renren-vue; index index.html; } } } #启动第fn2节点 docker run -it -d --name fn2 -v /home/fn2/nginx.conf:/etc/nginx/nginx.conf -v /home/fn2/renren-vue:/home/fn2/renren-vue --privileged --net=host nginx 宿主机/home/fn3/nginx.conf 的配置文件 user nginx; worker_processes 1; error_log /var/log/nginx/error.log warn; pid /var/run/nginx.pid; events { worker_connections 1024; } http { include /etc/nginx/mime.types; default_type application/octet-stream; log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' '$status $body_bytes_sent \"$http_referer\" ' '\"$http_user_agent\" \"$http_x_forwarded_for\"'; access_log /var/log/nginx/access.log main; sendfile on; #tcp_nopush on; keepalive_timeout 65; #gzip on; proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; client_max_body_size 10m; client_body_buffer_size 128k; proxy_connect_timeout 5s; proxy_send_timeout 5s; proxy_read_timeout 5s; proxy_buffer_size 4k; proxy_buffers 4 32k; proxy_busy_buffers_size 64k; proxy_temp_file_write_size 64k; server { listen 6503; server_name 192.168.99.104; location / { root /home/fn3/renren-vue; index index.html; } } } 启动 fn3 节点 #启动第fn3节点 docker run -it -d --name fn3 -v /home/fn3/nginx.conf:/etc/nginx/nginx.conf -v /home/fn3/renren-vue:/home/fn3/renren-vue --privileged --net=host nginx 4. 配置负载均衡宿主机/home/ff1/nginx.conf 配置文件 user nginx; worker_processes 1; error_log /var/log/nginx/error.log warn; pid /var/run/nginx.pid; events { worker_connections 1024; } http { include /etc/nginx/mime.types; default_type application/octet-stream; log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' '$status $body_bytes_sent \"$http_referer\" ' '\"$http_user_agent\" \"$http_x_forwarded_for\"'; access_log /var/log/nginx/access.log main; sendfile on; #tcp_nopush on; keepalive_timeout 65; #gzip on; proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; client_max_body_size 10m; client_body_buffer_size 128k; proxy_connect_timeout 5s; proxy_send_timeout 5s; proxy_read_timeout 5s; proxy_buffer_size 4k; proxy_buffers 4 32k; proxy_busy_buffers_size 64k; proxy_temp_file_write_size 64k; upstream fn { server 192.168.99.104:6501; server 192.168.99.104:6502; server 192.168.99.104:6503; } server { listen 6601; server_name 192.168.99.104; location / { proxy_pass http://fn; index index.html index.htm; } } } #启动ff1节点 docker run -it -d --name ff1 -v /home/ff1/nginx.conf:/etc/nginx/nginx.conf --net=host --privileged nginx 宿主机/home/ff2/nginx.conf 配置文件 user nginx; worker_processes 1; error_log /var/log/nginx/error.log warn; pid /var/run/nginx.pid; events { worker_connections 1024; } http { include /etc/nginx/mime.types; default_type application/octet-stream; log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' '$status $body_bytes_sent \"$http_referer\" ' '\"$http_user_agent\" \"$http_x_forwarded_for\"'; access_log /var/log/nginx/access.log main; sendfile on; #tcp_nopush on; keepalive_timeout 65; #gzip on; proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; client_max_body_size 10m; client_body_buffer_size 128k; proxy_connect_timeout 5s; proxy_send_timeout 5s; proxy_read_timeout 5s; proxy_buffer_size 4k; proxy_buffers 4 32k; proxy_busy_buffers_size 64k; proxy_temp_file_write_size 64k; upstream fn { server 192.168.99.104:6501; server 192.168.99.104:6502; server 192.168.99.104:6503; } server { listen 6602; server_name 192.168.99.104; location / { proxy_pass http://fn; index index.html index.htm; } } } #启动ff2节点 docker run -it -d --name ff2 -v /home/ff2/nginx.conf:/etc/nginx/nginx.conf --net=host --privileged nginx 5. 配置双机热备#进入ff1节点 docker exec -it ff1 bash #更新软件包 apt-get update #安装VIM apt-get install vim #安装Keepalived apt-get install keepalived #编辑Keepalived配置文件(如下) vim /etc/keepalived/keepalived.conf #启动Keepalived service keepalived start vrrp_instance VI_1 { state MASTER interface ens33 virtual_router_id 52 priority 100 advert_int 1 authentication { auth_type PASS auth_pass 123456 } virtual_ipaddress { 192.168.99.152 } } virtual_server 192.168.99.151 6701 { delay_loop 3 lb_algo rr lb_kind NAT persistence_timeout 50 protocol TCP real_server 192.168.99.104 6601 { weight 1 } } #进入ff1节点 docker exec -it ff2 bash #更新软件包 apt-get update #安装VIM apt-get install vim #安装Keepalived apt-get install keepalived #编辑Keepalived配置文件(如下) vim /etc/keepalived/keepalived.conf #启动Keepalived service keepalived start vrrp_instance VI_1 { state MASTER interface ens33 virtual_router_id 52 priority 100 advert_int 1 authentication { auth_type PASS auth_pass 123456 } virtual_ipaddress { 192.168.99.152 } } virtual_server 192.168.99.151 6701 { delay_loop 3 lb_algo rr lb_kind NAT persistence_timeout 50 protocol TCP real_server 192.168.99.104 6602 { weight 1 } }","tags":[{"name":"Docker","slug":"Docker","permalink":"http://coder.liusixin.cn/tags/Docker/"},{"name":"微服务","slug":"微服务","permalink":"http://coder.liusixin.cn/tags/微服务/"}]},{"title":"Eslint 规则总结","date":"2018-03-27T03:26:33.000Z","path":"posts/ed5f9f50/","text":"ESLint 主要有以下特点： 默认规则包含所有 JSLint、JSHint 中存在的规则，易迁移； 规则可配置性高：可设置「警告」、「错误」两个 error 等级，或者直接禁用； 包含代码风格检测的规则（可以丢掉 JSCS 了）； 支持插件扩展、自定义规则。 Use /_ eslint-disable _/ to ignore all warnings in a file. 有一种万能方法，就是在报错的 JS 文件中第一行写上 /* eslint-disable */ 配置 可以通过以下三种方式配置 ESLint: 使用 .eslintrc 文件（支持 JSON 和 YAML 两种语法）； 在 package.json 中添加 eslintConfig 配置块；直接在代码文件中定义。 以下是.eslintrc 文件示例和解释：为了方便查看，特记录如下,需要用的规则。 { \"env\": { \"browser\": true, \"node\": true, \"commonjs\": true }, \"ecmaFeatures\": { // lambda表达式 \"arrowFunctions\": true, // 解构赋值 \"destructuring\": true, // class \"classes\": true, // http://es6.ruanyifeng.com/#docs/function#函数参数的默认值 \"defaultParams\": true, // 块级作用域，允许使用let const \"blockBindings\": true, // 允许使用模块，模块内默认严格模式 \"modules\": true, // 允许字面量定义对象时，用表达式做属性名 // http://es6.ruanyifeng.com/#docs/object#属性名表达式 \"objectLiteralComputedProperties\": true, // 允许对象字面量方法名简写 /*var o = { method() { return \"Hello!\"; } }; 等同于 var o = { method: function() { return \"Hello!\"; } }; */ \"objectLiteralShorthandMethods\": true, /* 对象字面量属性名简写 var foo = 'bar'; var baz = {foo}; baz // {foo: \"bar\"} // 等同于 var baz = {foo: foo}; */ \"objectLiteralShorthandProperties\": true, // http://es6.ruanyifeng.com/#docs/function#rest参数 \"restParams\": true, // http://es6.ruanyifeng.com/#docs/function#扩展运算符 \"spread\": true, // http://es6.ruanyifeng.com/#docs/iterator#for---of循环 \"forOf\": true, // http://es6.ruanyifeng.com/#docs/generator \"generators\": true, // http://es6.ruanyifeng.com/#docs/string#模板字符串 \"templateStrings\": true, \"superInFunctions\": true, // http://es6.ruanyifeng.com/#docs/object#对象的扩展运算符 \"experimentalObjectRestSpread\": true }, \"rules\": { // 定义对象的set存取器属性时，强制定义get \"accessor-pairs\": 2, // 指定数组的元素之间要以空格隔开(,后面)， never参数：[ 之前和 ] 之后不能带空格，always参数：[ 之前和 ] 之后必须带空格 \"array-bracket-spacing\": [2, \"never\"], // 在块级作用域外访问块内定义的变量是否报错提示 \"block-scoped-var\": 0, // if while function 后面的{必须与if在同一行，java风格。 \"brace-style\": [2, \"1tbs\", { \"allowSingleLine\": true }], // 双峰驼命名格式 \"camelcase\": 2, // 数组和对象键值对最后一个逗号， never参数：不能带末尾的逗号, always参数：必须带末尾的逗号， // always-multiline：多行模式必须带逗号，单行模式不能带逗号 \"comma-dangle\": [2, \"never\"], // 控制逗号前后的空格 \"comma-spacing\": [2, { \"before\": false, \"after\": true }], // 控制逗号在行尾出现还是在行首出现 // http://eslint.org/docs/rules/comma-style \"comma-style\": [2, \"last\"], // 圈复杂度 \"complexity\": [2,9], // 以方括号取对象属性时，[ 后面和 ] 前面是否需要空格, 可选参数 never, always \"computed-property-spacing\": [2,\"never\"], // 强制方法必须返回值，TypeScript强类型，不配置 \"consistent-return\": 0, // 用于指统一在回调函数中指向this的变量名，箭头函数中的this已经可以指向外层调用者，应该没卵用了 // e.g [0,\"that\"] 指定只能 var that = this. that不能指向其他任何值，this也不能赋值给that以外的其他值 \"consistent-this\": 0, // 强制在子类构造函数中用super()调用父类构造函数，TypeScrip的编译器也会提示 \"constructor-super\": 0, // if else while for do后面的代码块是否需要{ }包围，参数： // multi 只有块中有多行语句时才需要{ }包围 // multi-line 只有块中有多行语句时才需要{ }包围, 但是块中的执行语句只有一行时， // 块中的语句只能跟和if语句在同一行。if (foo) foo++; else doSomething(); // multi-or-nest 只有块中有多行语句时才需要{ }包围, 如果块中的执行语句只有一行，执行语句可以零另起一行也可以跟在if语句后面 // [2, \"multi\", \"consistent\"] 保持前后语句的{ }一致 // default: [2, \"all\"] 全都需要{ }包围 \"curly\": [2, \"all\"], // switch语句强制default分支，也可添加 // no default 注释取消此次警告 \"default-case\": 2, // 强制object.key 中 . 的位置，参数: // property，'.'号应与属性在同一行 // object, '.' 号应与对象名在同一行 \"dot-location\": [2, \"property\"], // 强制使用.号取属性 // 参数： allowKeywords：true 使用保留字做属性名时，只能使用.方式取属性 // false 使用保留字做属性名时, 只能使用[]方式取属性 e.g [2, {\"allowKeywords\": false}] // allowPattern: 当属性名匹配提供的正则表达式时，允许使用[]方式取值,否则只能用.号取值 e.g [2, {\"allowPattern\": \"^[a-z]+(_[a-z]+)+$\"}] \"dot-notation\": [2, {\"allowKeywords\": true}], // 文件末尾强制换行 \"eol-last\": 2, // 使用 === 替代 == \"eqeqeq\": [2, \"allow-null\"], // 方法表达式是否需要命名 \"func-names\": 0, // 方法定义风格，参数： // declaration: 强制使用方法声明的方式，function f(){} e.g [2, \"declaration\"] // expression：强制使用方法表达式的方式，var f = function() {} e.g [2, \"expression\"] // allowArrowFunctions: declaration风格中允许箭头函数。 e.g [2, \"declaration\", { \"allowArrowFunctions\": true }] \"func-style\": 0, \"no-alert\": 0,//禁止使用alert confirm prompt \"no-array-constructor\": 2,//禁止使用数组构造器 \"no-bitwise\": 0,//禁止使用按位运算符 \"no-caller\": 1,//禁止使用arguments.caller或arguments.callee \"no-catch-shadow\": 2,//禁止catch子句参数与外部作用域变量同名 \"no-class-assign\": 2,//禁止给类赋值 \"no-cond-assign\": 2,//禁止在条件表达式中使用赋值语句 \"no-console\": 2,//禁止使用console \"no-const-assign\": 2,//禁止修改const声明的变量 \"no-constant-condition\": 2,//禁止在条件中使用常量表达式 if(true) if(1) \"no-continue\": 0,//禁止使用continue \"no-control-regex\": 2,//禁止在正则表达式中使用控制字符 \"no-debugger\": 2,//禁止使用debugger \"no-delete-var\": 2,//不能对var声明的变量使用delete操作符 \"no-div-regex\": 1,//不能使用看起来像除法的正则表达式/=foo/ \"no-dupe-keys\": 2,//在创建对象字面量时不允许键重复 {a:1,a:1} \"no-dupe-args\": 2,//函数参数不能重复 \"no-duplicate-case\": 2,//switch中的case标签不能重复 \"no-else-return\": 2,//如果if语句里面有return,后面不能跟else语句 \"no-empty\": 2,//块语句中的内容不能为空 \"no-empty-character-class\": 2,//正则表达式中的[]内容不能为空 \"no-empty-label\": 2,//禁止使用空label \"no-eq-null\": 2,//禁止对null使用==或!=运算符 \"no-eval\": 1,//禁止使用eval \"no-ex-assign\": 2,//禁止给catch语句中的异常参数赋值 \"no-extend-native\": 2,//禁止扩展native对象 \"no-extra-bind\": 2,//禁止不必要的函数绑定 \"no-extra-boolean-cast\": 2,//禁止不必要的bool转换 \"no-extra-parens\": 2,//禁止非必要的括号 \"no-extra-semi\": 2,//禁止多余的冒号 \"no-fallthrough\": 1,//禁止switch穿透 \"no-floating-decimal\": 2,//禁止省略浮点数中的0 .5 3. \"no-func-assign\": 2,//禁止重复的函数声明 \"no-implicit-coercion\": 1,//禁止隐式转换 \"no-implied-eval\": 2,//禁止使用隐式eval \"no-inline-comments\": 0,//禁止行内备注 \"no-inner-declarations\": [2, \"functions\"],//禁止在块语句中使用声明（变量或函数） \"no-invalid-regexp\": 2,//禁止无效的正则表达式 \"no-invalid-this\": 2,//禁止无效的this，只能用在构造器，类，对象字面量 \"no-irregular-whitespace\": 2,//不能有不规则的空格 \"no-iterator\": 2,//禁止使用__iterator__ 属性 \"no-label-var\": 2,//label名不能与var声明的变量名相同 \"no-labels\": 2,//禁止标签声明 \"no-lone-blocks\": 2,//禁止不必要的嵌套块 \"no-lonely-if\": 2,//禁止else语句内只有if语句 \"no-loop-func\": 1,//禁止在循环中使用函数（如果没有引用外部变量不形成闭包就可以） \"no-mixed-requires\": [0, false],//声明时不能混用声明类型 \"no-mixed-spaces-and-tabs\": [2, false],//禁止混用tab和空格 \"linebreak-style\": [0, \"windows\"],//换行风格 \"no-multi-spaces\": 1,//不能用多余的空格 \"no-multi-str\": 2,//字符串不能用\\换行 \"no-multiple-empty-lines\": [1, {\"max\": 2}],//空行最多不能超过2行 \"no-native-reassign\": 2,//不能重写native对象 \"no-negated-in-lhs\": 2,//in 操作符的左边不能有! \"no-nested-ternary\": 0,//禁止使用嵌套的三目运算 \"no-new\": 1,//禁止在使用new构造一个实例后不赋值 \"no-new-func\": 1,//禁止使用new Function \"no-new-object\": 2,//禁止使用new Object() \"no-new-require\": 2,//禁止使用new require \"no-new-wrappers\": 2,//禁止使用new创建包装实例，new String new Boolean new Number \"no-obj-calls\": 2,//不能调用内置的全局对象，比如Math() JSON() \"no-octal\": 2,//禁止使用八进制数字 \"no-octal-escape\": 2,//禁止使用八进制转义序列 \"no-param-reassign\": 2,//禁止给参数重新赋值 \"no-path-concat\": 0,//node中不能使用__dirname或__filename做路径拼接 \"no-plusplus\": 0,//禁止使用++，-- \"no-process-env\": 0,//禁止使用process.env \"no-process-exit\": 0,//禁止使用process.exit() \"no-proto\": 2,//禁止使用__proto__属性 \"no-redeclare\": 2,//禁止重复声明变量 \"no-regex-spaces\": 2,//禁止在正则表达式字面量中使用多个空格 /foo bar/ \"no-restricted-modules\": 0,//如果禁用了指定模块，使用就会报错 \"no-return-assign\": 1,//return 语句中不能有赋值表达式 \"no-script-url\": 0,//禁止使用javascript:void(0) \"no-self-compare\": 2,//不能比较自身 \"no-sequences\": 0,//禁止使用逗号运算符 \"no-shadow\": 2,//外部作用域中的变量不能与它所包含的作用域中的变量或参数同名 \"no-shadow-restricted-names\": 2,//严格模式中规定的限制标识符不能作为声明时的变量名使用 \"no-spaced-func\": 2,//函数调用时 函数名与()之间不能有空格 \"no-sparse-arrays\": 2,//禁止稀疏数组， [1,,2] \"no-sync\": 0,//nodejs 禁止同步方法 \"no-ternary\": 0,//禁止使用三目运算符 \"no-trailing-spaces\": 1,//一行结束后面不要有空格 \"no-this-before-super\": 0,//在调用super()之前不能使用this或super \"no-throw-literal\": 2,//禁止抛出字面量错误 throw \"error\"; \"no-undef\": 1,//不能有未定义的变量 \"no-undef-init\": 2,//变量初始化时不能直接给它赋值为undefined \"no-undefined\": 2,//不能使用undefined \"no-unexpected-multiline\": 2,//避免多行表达式 \"no-underscore-dangle\": 1,//标识符不能以_开头或结尾 \"no-unneeded-ternary\": 2,//禁止不必要的嵌套 var isYes = answer === 1 ? true : false; \"no-unreachable\": 2,//不能有无法执行的代码 \"no-unused-expressions\": 2,//禁止无用的表达式 \"no-unused-vars\": [2, {\"vars\": \"all\", \"args\": \"after-used\"}],//不能有声明后未被使用的变量或参数 \"no-use-before-define\": 2,//未定义前不能使用 \"no-useless-call\": 2,//禁止不必要的call和apply \"no-void\": 2,//禁用void操作符 \"no-var\": 0,//禁用var，用let和const代替 \"no-warning-comments\": [1, { \"terms\": [\"todo\", \"fixme\", \"xxx\"], \"location\": \"start\" }],//不能有警告备注 \"no-with\": 2,//禁用with \"array-bracket-spacing\": [2, \"never\"],//是否允许非空数组里面有多余的空格 \"arrow-parens\": 0,//箭头函数用小括号括起来 \"arrow-spacing\": 0,//=>的前/后括号 \"accessor-pairs\": 0,//在对象中使用getter/setter \"block-scoped-var\": 0,//块语句中使用var \"brace-style\": [1, \"1tbs\"],//大括号风格 \"callback-return\": 1,//避免多次调用回调什么的 \"camelcase\": 2,//强制驼峰法命名 \"comma-dangle\": [2, \"never\"],//对象字面量项尾不能有逗号 \"comma-spacing\": 0,//逗号前后的空格 \"comma-style\": [2, \"last\"],//逗号风格，换行时在行首还是行尾 \"complexity\": [0, 11],//循环复杂度 \"computed-property-spacing\": [0, \"never\"],//是否允许计算后的键名什么的 \"consistent-return\": 0,//return 后面是否允许省略 \"consistent-this\": [2, \"that\"],//this别名 \"constructor-super\": 0,//非派生类不能调用super，派生类必须调用super \"curly\": [2, \"all\"],//必须使用 if(){} 中的{} \"default-case\": 2,//switch语句最后必须有default \"dot-location\": 0,//对象访问符的位置，换行的时候在行首还是行尾 \"dot-notation\": [0, { \"allowKeywords\": true }],//避免不必要的方括号 \"eol-last\": 0,//文件以单一的换行符结束 \"eqeqeq\": 2,//必须使用全等 \"func-names\": 0,//函数表达式必须有名字 \"func-style\": [0, \"declaration\"],//函数风格，规定只能使用函数声明/函数表达式 \"generator-star-spacing\": 0,//生成器函数*的前后空格 \"guard-for-in\": 0,//for in循环要用if语句过滤 \"handle-callback-err\": 0,//nodejs 处理错误 \"id-length\": 0,//变量名长度 \"indent\": [2, 4],//缩进风格 \"init-declarations\": 0,//声明时必须赋初值 \"key-spacing\": [0, { \"beforeColon\": false, \"afterColon\": true }],//对象字面量中冒号的前后空格 \"lines-around-comment\": 0,//行前/行后备注 \"max-depth\": [0, 4],//嵌套块深度 \"max-len\": [0, 80, 4],//字符串最大长度 \"max-nested-callbacks\": [0, 2],//回调嵌套深度 \"max-params\": [0, 3],//函数最多只能有3个参数 \"max-statements\": [0, 10],//函数内最多有几个声明 \"new-cap\": 2,//函数名首行大写必须使用new方式调用，首行小写必须用不带new方式调用 \"new-parens\": 2,//new时必须加小括号 \"newline-after-var\": 2,//变量声明后是否需要空一行 \"object-curly-spacing\": [0, \"never\"],//大括号内是否允许不必要的空格 \"object-shorthand\": 0,//强制对象字面量缩写语法 \"one-var\": 1,//连续声明 \"operator-assignment\": [0, \"always\"],//赋值运算符 += -=什么的 \"operator-linebreak\": [2, \"after\"],//换行时运算符在行尾还是行首 \"padded-blocks\": 0,//块语句内行首行尾是否要空行 \"prefer-const\": 0,//首选const \"prefer-spread\": 0,//首选展开运算 \"prefer-reflect\": 0,//首选Reflect的方法 \"quotes\": [1, \"single\"],//引号类型 `` \"\" '' \"quote-props\":[2, \"always\"],//对象字面量中的属性名是否强制双引号 \"radix\": 2,//parseInt必须指定第二个参数 \"id-match\": 0,//命名检测 \"require-yield\": 0,//生成器函数必须有yield \"semi\": [2, \"always\"],//语句强制分号结尾 \"semi-spacing\": [0, {\"before\": false, \"after\": true}],//分号前后空格 \"sort-vars\": 0,//变量声明时排序 \"space-after-keywords\": [0, \"always\"],//关键字后面是否要空一格 \"space-before-blocks\": [0, \"always\"],//不以新行开始的块{前面要不要有空格 \"space-before-function-paren\": [0, \"always\"],//函数定义时括号前面要不要有空格 \"space-in-parens\": [0, \"never\"],//小括号里面要不要有空格 \"space-infix-ops\": 0,//中缀操作符周围要不要有空格 \"space-return-throw-case\": 2,//return throw case后面要不要加空格 \"space-unary-ops\": [0, { \"words\": true, \"nonwords\": false }],//一元运算符的前/后要不要加空格 \"spaced-comment\": 0,//注释风格不要有空格什么的 \"strict\": 2,//使用严格模式 \"use-isnan\": 2,//禁止比较时使用NaN，只能用isNaN() \"valid-jsdoc\": 0,//jsdoc规则 \"valid-typeof\": 2,//必须使用合法的typeof的值 \"vars-on-top\": 2,//var必须放在作用域顶部 \"wrap-iife\": [2, \"inside\"],//立即执行函数表达式的小括号风格 \"wrap-regex\": 0,//正则表达式字面量用小括号包起来 \"yoda\": [2, \"never\"]//禁止尤达条件 } }","tags":[{"name":"Eslint","slug":"Eslint","permalink":"http://coder.liusixin.cn/tags/Eslint/"}]},{"title":"跨浏览器的HTML5表单验证","date":"2018-03-15T06:52:46.000Z","path":"posts/ffc0eab3/","text":"前言表单验证通常采用的方法是用策略模式的思想， 把一个个验证规则封装成一个函数，如非空规则，最大长度规则等，不同的输入框选择某一个或者某几个规则进行验证。这样有它的好处，也有它的坏处。好处是每个规则是独立的，包括它的检验规则和出错提示信息，可以把它们封装在一起。坏处是当你写一个表单里面有 10 个 input, 每个 input 都有 3~4 个验证规则， 那你的 JS 至少得写 30 行代码用来添加验证规则， 这样代码看起来就有点冗长了。 其实 HTML5 增加了很多种类型的 input, 每个 input 还支持 pattern/minlength/maxlength 等规则的验证， 可以说几乎不用自己去写验证规则。使用 HTML5 的表单验证能够更加的方便快捷。但是每个浏览器在某些行为不一致， 再加上兼容性的原因， 大家都不太想用。其实这两个缺点是可以克服的。 使用 HTML5 的 input 有一个很大的优点， 就是手机上会根据不同的类型弹不同的键盘， 方便用户输入， 这一点你用什么策略模式都是无法做到的。 但是由于不同的浏览器对不合法输入提示文案不一致，样式也不一样，并且老的浏览器不兼容 (IE9 及以下），在生产环境中比较少看到有人用。 具体来说存在三个问题： 输入框 blur 的时候不会触发检查，只有在点提交时才触发， 但是有一种场景是希望用户一旦离开这个输入框就对其输入进行检查； 提示控件的 UI 差异很大，safari 还不会触发提示控件，一些浏览器如 IE 会给非法的输入框添加一个红色的边框； 文案是写死的，并且不同浏览器的文案不一致，其中应该以 Chrome 的提示最好。 实现跨浏览器插件为解决这些问题，网上有一些插件，如 HTML5 Form, 做了跨浏览器的处理， 但是使用起来效果并不是十分让人满意， HTML5 Form 在 Safari 下面就失效了。 接下来我们就自己封装一个插件。 为了实现跨浏览器的一致性和使用的方便，达到了以下特点： 统一 UI 和文案 支待异步验证 支持多重类型规则验证 能够中英文切换 先来说一下怎么用这个插件，然后再分析怎么实现一个这样的插件。 插件使用方法1. 最简单的使用方法 所有的 input 要写在 form 里面 &lt;form class=\"sign-up\"> &lt;label>邮箱地址&lt;/label> &lt;input type=\"email\" name=\"account\" data-t=\"email\" required=\"\"> &lt;label>密码&lt;/label> &lt;input type=\"password\" name=\"password\" pattern=\".{6,20}\" data-pm=\"密码要在6到 20位之间\" required=\"\"> &lt;label>确认密码&lt;/label> &lt;input type=\"password\" name=\"confirm-pwd\" maxlength=\"20\" minlength=\"6\"> &lt;input id=\"confirm-sign\" type=\"submit\" value=\"注册\"> &lt;p>&lt;/p> &lt;/form> 定义了 input 的 type=&quot;email&quot; , 还要再写多 一个`data­-t=”email” 主要是因为 IE10 以下的浏览器会把不认识的 type 强制改成 text。 上面总共用到了类型、必填、正则、长度检验，出错信息放在了 data-pm 属性里面。 这比你手动一个个去添加规则要方便多了。有了上面的 HTML 结构之后， 只需要初始化插件就可以了。 new Form( document.getElementByid('sign-up-form'), { errorMsgClass: 'error', // 错误提示桯的类名， 用于自定义样式 errorinputClass: 'invalid' //input无教的类名， 用于自定义样式 }, submit ); function submit() { console.log('表单验证成功， 准备提交'); // 提交操作 } 执行 new From 的时候传了 3 个参数， 第一个是 form 的 DOM 元素， 第二个参数是验证规则的一些配置， 第三是验证成功的回调函数。 第二个参数 checkOpt 有两个属性 errorMsgClass和errorInputClass 用来自定义样式。 2. 添加自定义检验 有时候有些检验无法用 HTML5 的属性检验，这个时候需要添加自定义检验， 如上面的密码需要保证两次的输入一致，可以在checkOpt里面添加自定义验证 checkOpt.rule = { 'confirm-pwd': { check: checkPwdIdentity, // 定义检验函数 msg: '两次密码输入不一致' // 出错提示信息 } }; function checkPwdIdentity() { return this.form['password'].value === this.form['confirm-pwd'].value; } 添加了一个 rule 属性，key 值为 input 的 name 属性，value 值包含一个自定义的检验函数和出错信息。 3. 自定义异步检验 有些数据需要向服务请求检验，如检验账户是否存在 checkOpt.rule.account = { check: checkAccountExist, msg: '账户已存在！', async: true }; function checkAccountExist(failCallback, successCallback) { var input = this; util.ajax( '/register/hasUser', { account: this.value }, function(data) { // 如果用户存在则调用failCallback, 让插件添加一个错误提示 if (data.isUser) { failCallback(); } // 成功则调用插件的成功回调函数 else { successCallback(); } } ); } 在回调函数里面传进两个参数，如果检验失败则执行第一个参数，成功则执行第二个参数，为插件所用。 4. 添加自定义类型出错提示 不同类型的输入框给出不同类型的出错提示 Form.prototype.validationMessage_cn = { email: '无效的邮箱格式', number: '无效的数字格式', url: '无效的网址格式', password: '格式无效', text: '格式无效' }; 可以取消掉浏览器提供的文案， 用上面的默认文案，显示英文站的时候取消掉中文浏览器的中文提示： // 如果浏览器的语言不是中文的话， 就不要使用英文的文案了， 双语站时侯适用 checkOpt.disableBrowserMsg = !( navigator.language || navigator.userLanguage ).match(/cn/i); 还可以指定插件使用的语言 // 双语站切换时适用 checkOpt.lang = 'en'; // 或者en 插件的实现怎么实现这么一个方便快捷的表单验证插件呢？它的实现并不是很复杂，只是需要考虑很多细节。下面分析一些关键点和难点。 1. 为非 HTML5 浏览器添加 checkValidity 函数如果没有 checkValidity 函数的话就给它添加一个， 相当于自行实现一个 HTML5 的 checkValidity 函数。 因为在后续的验证里面需要用到这个函数 var input = document.createElement('input'); if (!input.checkValidity) { HTMLinputElement.prototype.checkValidity = function() { // 这里根据不同的属性规则做检验， 如type/pattern/minlength, 代码略 }; } 2. 添加错误提示重点是计算提示显示的位置 Form.prototype.addErrorMsg = function(input, msg) { // 根据input计算msg相对input的位置 }; 3. 异步检验的实现异步检验的难点在于，什么时候执行 submit 回调。 解决方案是给每个 input 添加一个 hasCheck 属性，如果检查通过则设置为 true, 一旦 focus 了就设为 false, blur 则触发检查。只有所有的 input 都有了属性 hasCheck 为 true 时才能执行 submit 回调。 下面代码中的 checkAsync 的第二个参数 needSubmit, 点提交时设置成 true, 而 blur 验证则为 false, 用于控制检验成功后是否要提交表单。 异步检验核心代码 Form.prototype.checkAsync = function(input, needSubmit) { var name = input.name; var rule = input.form.Form.checkOpt.rule; rule[name]['check'].call( input, // 检验失败回调函数 function() { var Form = input.form.Form; Form.addErrorMsg(input, Form.checkOpt.rule[name].msg); }, // 检验成功回调函数 function() { input.hasCheck = true; if (needSubmit) { input.form.Form.tryCallSubmit(input); } } ); }; tryCallSubmit 函数检查除 submit 外所有的 input 是否为 hasCheck 是 true, 如果有则执行 submit callback。 以上就是整个跨浏览器的 HTML5 表单验证插件的思想。 表单验证的实现可能有多种方式， 但是借助 HTML5 的特性做表单验证无疑会更简单，代码更少，用户体验更好。","tags":[{"name":"javascript","slug":"javascript","permalink":"http://coder.liusixin.cn/tags/javascript/"},{"name":"HTML5","slug":"HTML5","permalink":"http://coder.liusixin.cn/tags/HTML5/"},{"name":"插件","slug":"插件","permalink":"http://coder.liusixin.cn/tags/插件/"}]},{"title":"Koa2 源码学习(二)","date":"2018-03-05T11:42:12.000Z","path":"posts/a73cd400/","text":"上文我们读了 koa 源码中的 application 模块，了解其核心实现原理，其中在 // application.js module.exports = class Application extends Emitter{ ... createContext(req, res) { const context = Object.create(this.context); const request = context.request = Object.create(this.request); const response = context.response = Object.create(this.response); } } 这段代码就引出了我们接下来分析的 context 模块，同样利用删减法。 context.jsconst proto = module.exports = { const createError = require('http-errors'); const httpAssert = require('http-assert'); const delegate = require('delegates'); const statuses = require('statuses'); ... } delegate(proto, 'response') .method('attachment') .method('redirect') .method('remove') ... delegate(proto, 'request') .method('acceptsLanguages') .method('acceptsEncodings') .method('acceptsCharsets') ... delegate 把 response 和 request 下面的方法和属性都挂载到 proto 上，然后把它暴露给 application，这里的 proto 就是 context。 // delegator function Delegator(proto, target) { if (!(this instanceof Delegator)) return new Delegator(proto, target); this.proto = proto; this.target = target; this.methods = []; this.getters = []; this.setters = []; this.fluents = []; } Delegator.prototype.method = function(name) { var proto = this.proto; var target = this.target; this.methods.push(name); proto[name] = function() { return this[target][name].apply(this[target], arguments); }; return this; }; Delegator 函数传入 proto 和 target 并分别缓存，然后调用 method 方法，把所有的方法名 push 到 methods 数组里，同时对 proto 下每一个传入的方法名配置成一个函数，函数内部是具体目标对象的方法。详细源码请看node-delegates // application.js module.exports = class Application extends Emitter{ ... createContext(req, res) { const context = Object.create(this.context); const request = context.request = Object.create(this.request); const response = context.response = Object.create(this.response); context.app = request.app = response.app = this; // 把当前实例挂载 context.req = request.req = response.req = req; context.res = request.res = response.res = res; request.ctx = response.ctx = context; request.response = response; response.request = request; context.originalUrl = request.originalUrl = req.url; context.cookies = new Cookies(req, res, { keys: this.keys, secure: request.secure }); request.ip = request.ips[0] || req.socket.remoteAddress || ''; context.accept = request.accept = accepts(req); context.state = {}; return context; } } Object.create 传入了 context 暴露出的 proto，proto 作为指定的原型对象在它的原有基础上生成新的对象（context），同时 request 和 response 也利用 Object.create 创建一个新的对象并把它挂载到 context 上。这样，在 context 不仅能访问到 request response 内部的方法属性外还能访问它们自身。 然后 context，req，res 互相挂载，这样就能很便利的去访问他们内部的方法和属性。 Object.create 解释看这里Object.create 总结content.js 主要就是提供了对 request 和 response 对象的方法与属性便捷访问能力。 request.js// request.js module.exports = { get header() {...}, set header(val) {...}, get headers() {...}, set headers(val) {...}, get url() {...}, set url(val) {...}, get origin() {...}, get href() {...} ... }; 从代码我们可以看到，request.js 封装了请求相关的属性以及方法，再把对象暴露给 application，通过 application.js 中的 createContext 方法，代理对应的 request 对象。 具体源代码看这里 request.js response.js和 request.js 一样，封装了响应相关的属性以及方法，这里就不贴代码了。 具体源代码看这里 response.js 中间件先来看段代码 const Koa = require('koa'); const app = new Koa(); app.use(async (ctx, next) => { ctx.type = 'text/html; charset=utf-8'; ctx.body = 'hello world'; }); app.listen(8081); 在 koa 中，要应用一个中间件，我们使用 app.use()，我们要理解一个概念，就是在 koa 中，一切皆是中间件。再来一段代码： const Koa = require('koa') const app = new Koa() const mid1 = async(ctx, next) => { ctx.body = 'Hello ' await next() ctx.body = ctx.body + 'OK' } const mid2 = async(ctx, next) => { ctx.type = 'text/html; charset=utf-8' await next() } const mid3 = async(ctx, next) => { ctx.body = ctx.body + 'World ' await next() } app.use(mid1) app.use(mid2) app.use(mid3) app.listen(8085) 打印出Hello World OK，从执行结果来看，首先执行 mid1 中的代码，在遇到 await next()之后会把控制权交给下一个中间件处理，直到所有的中间件都执行完毕，然后再回来继续执行剩下的业务代码。到这里我们就对 koa 的中间件执行特点有所了解了。 // application use(fn) { ... this.middleware.push(fn); return this; } 在前面的代码中，我们看到中间件在使用过程中会不断加到堆栈中，执行顺序也会按照先进先出的原则执行。但是 koa 中间件为什么可以依次执行？并在执行过程中可以暂停下来走后面的流程然后再回来继续执行？这里我们就要用到 koa-compose 了。 compose 这里用到了纯函数，关于纯函数可以去看下函数式编程相关概念，首先纯函数无副作用，既不依赖，也不会改变全局状态。这样函数之间可以达到自由组合的效果。 我们先用一段 js 代码来模拟下这个执行原理 function tail(i) { if(i > 3) return i console.log('修改前', i); return arguments.callee(i + 1) } tail(0) // 修改前 0 // 修改前 1 // 修改前 2 // 修改前 3 通过这种方式在每次调用的时候把这个函数的执行返回，它执行后的结果就是下一次调用的入参，这个返回的函数负责执行下一个流程，一直执行到边界条件为止。 然后再看 compose 核心代码 // koa-compose module.exports = compose function compose (middleware) { // 接收中间件函数数组 if (!Array.isArray(middleware)) throw new TypeError('Middleware stack must be an array!') // 判断入参middleware是否为数组 for (const fn of middleware) { // 判断数组内每一项是否是function if (typeof fn !== 'function') throw new TypeError('Middleware must be composed of functions!') } return function (context, next) { // next可以看成是一个钩子回调函数，能串联到下一个中间件 // last called middleware # let index = -1 // 注册初始下标 return dispatch(0) // 直接执行 function dispatch (i) { if (i &lt;= index) return Promise.reject(new Error('next() called multiple times')) // 判断next是否多次调用 index = i let fn = middleware[i] // 下表为0，默认第一个中间件 if (i === middleware.length) fn = next // 说明已调用到最后一个中间件，这里next为undified if (!fn) return Promise.resolve() // next取反为true，直接返回一个代码执行完毕的resolve try { return Promise.resolve(fn(context, function next () { return dispatch(i + 1) //递归调用，next将结果传递给下一个中间件 })) } catch (err) { return Promise.reject(err) } } } } 可以看到 compose 是一个闭包函数，返回匿名函数再执行的最终结果返回的是一个 promise 对象。 compose 内部存储了所有的中间件，通过递归的方式不断的运行中间件。 再回到 application 来看 // application.js callback() { const fn = compose(this.middleware); const handleRequest = (req, res) => { const ctx = this.createContext(req, res); // 生成上下文对象 return this.handleRequest(ctx, fn); }; return handleRequest; } handleRequest(ctx, fnMiddleware) { const res = ctx.res; res.statusCode = 404; const onerror = err => ctx.onerror(err); const handleResponse = () => respond(ctx); onFinished(res, onerror); return fnMiddleware(ctx).then(handleResponse).catch(onerror); } fnMiddleware 是通过 handleResponse 传入下来的，然后在 callback 回调执行的时候生成上下文对象 ctx，然后把 ctx 传给了 handleRequest，另一个参数 fn 就是 compose 处理之后返回的匿名函数，对应就是 compose 里return Promise.resolve(fn(context, function next (){} 这里的 context 和 next。 fnMiddleware 第一次执行的时只传入了 ctx，next 为 undified，对应的就是 compose 里直接return dispatch(0)，这时候还没有执行第一个中间件，在它内部才传入了 next。 compose 的作用其实就是把每个不相干的中间件串在一起，然后来组合函数，把这些函数串联起来依次执行，上一个函数的输出结果就是下一个函数的入参。 总结Compose 是一种基于 Promise 的流程控制方式，可以通过这种方式对异步流程同步化，解决之前的嵌套回调和 Promise 链式耦合。","tags":[{"name":"Nodejs","slug":"Nodejs","permalink":"http://coder.liusixin.cn/tags/Nodejs/"},{"name":"Koa2","slug":"Koa2","permalink":"http://coder.liusixin.cn/tags/Koa2/"}]},{"title":"Koa2 源码学习(一)","date":"2018-03-02T03:09:27.000Z","path":"posts/80d4f62/","text":"引言最近读了一下 Koa2 的源码；在阅读 Koa2 (2.3.0) 的源码的过程中，我的感受是整个代码设计精巧，思路清晰，是一个小而精的 nodejs web 服务框架。 设计理念作为 web 服务框架，都是要围绕核心服务而展开的。那什么是核心服务呢？其实就是接收客户端的一个 http 的请求，对于这个请求，除了接收以外，还有解析这个请求。所以说会有 HPPT：接收 -&gt; 解析 -&gt; 响应 在响应客户端的时候，也有很多种方式，比如返回一个 html 页面，或者 json 文本。在解析请求和响应请求的中间，会有一些第三方的中间件，比如 日志、表单解析等等来增强 koa 的服务能力，所以 koa 至少要提供 “请求解析”、”响应数据”、”中间件处理” 这三种核心能力的封装，同时还需要有一个串联他们执行环境的上下文（context） HTTP 接收 解析 响应 中间件 执行上下文 上下文可以理解为是 http 的请求周期内的作用域环境来托管请求响应和中间件，方便他们之间互相访问。 以上分析是站在单个 http 请求的角度来看一个 web 服务能力。那么站在整个网站，站在整个后端服务的角度来看的话，能够提供 “请求”、”响应”、”解析”、”中间件”、”http 流程全链路” 这些服务能力的综合体，可以看做是一个应用服务对象。如果把这些全放到 koa 里的话，那么对应的就是： Application Context Request Response Middlewares Session Cookie Koa 的组成结构首先看下 koa 的目录结构 application.js：框架入口；负责管理中间件，以及处理请求 context.js：context 对象的原型，代理 request 与 response 对象上的方法和属性 request.js：request 对象的原型，提供请求相关的方法和属性 response.js：response 对象的原型，提供响应相关的方法和属性 // application.js const isGeneratorFunction = require('is-generator-function'); // 判断当前传入的function是否是标准的generator function const debug = require('debug')('koa:application'); // js调试工具 const onFinished = require('on-finished'); // 事件监听，当http请求关闭，完成或者出错的时候调用注册好的回调 const response = require('./response'); // 响应请求 const compose = require('koa-compose'); // 中间件的函数数组 const isJSON = require('koa-is-json'); // 判断是否为json数据 const context = require('./context'); // 运行服务上下文 const request = require('./request'); // 客户端的请求 const statuses = require('statuses'); // 请求状态码 const Cookies = require('cookies'); const accepts = require('accepts'); // 约定可被服务端接收的数据，主要是协议和资源的控制 const Emitter = require('events'); // 事件循环 const assert = require('assert'); // 断言 const Stream = require('stream'); const http = require('http'); const only = require('only'); // 白名单选择 const convert = require('koa-convert'); // 兼容旧版本koa中间件 const deprecate = require('depd')('koa'); // 判断当前在运行koa的某些接口或者方法是否过期，如果过期，会给出一个升级的提示 以上是 koa 入口文件的依赖分析。接下来我们进行源码分析，首先我们利用删减法来筛出代码的核心实现即可，不用上来就盯细节！我们只保留 constructor // application.js module.exports = class Application extends Emitter { constructor() { super(); this.proxy = false; // 是否信任 proxy header 参数，默认为 false this.middleware = []; //保存通过app.use(middleware)注册的中间件 this.subdomainOffset = 2; // 子域默认偏移量，默认为 2 this.env = process.env.NODE_ENV || 'development'; // 环境参数，默认为 NODE_ENV 或 ‘development’ this.context = Object.create(context); //context模块，通过context.js创建 this.request = Object.create(request); //request模块，通过request.js创建 this.response = Object.create(response); //response模块，通过response.js创建 } // ... } 我们可以看到，这段代码暴露出一个类，构造函数内预先声明了一些属性，该类继承了 Emitter，也就是说这个类可以直接为自定义事件注册回调函数和触发事件，同时可以捕捉到其他地方触发的事件。 除了这些基本属性之外，还有一些公用的 api，最重要的两个一个是listen，一个是use。koa 的每个实例上都会有这些属性和方法。 // application.js module.exports = class Application extends Emitter { constructor() { super(); this.proxy = false; this.middleware = []; this.subdomainOffset = 2; this.env = process.env.NODE_ENV || 'development'; this.context = Object.create(context); this.request = Object.create(request); this.response = Object.create(response); } listen() { const server = http.createServer(this.callback()); return server.listen.apply(server, arguments); } use(fn) { this.middleware.push(fn); return this; } } listen 方法内部通过 http.createServer 创建了一个 http 服务的实例，通过这个实例去 listen 要监听的端口号，http.createServer 的参数传入了 this.callback 回调 // application.js module.exports = class Application extends Emitter { ... callback() { const fn = compose(this.middleware); // 把所有middleware进行了组合，使用了koa-compose const handleRequest = (req, res) => { const ctx = this.createContext(req, res); return this.handleRequest(ctx, fn); // 返回了本身的回调函数 }; return handleRequest; } } 可以看到，handleRequest 返回了本身的回调，接下来看 handleRequest 。 handleRequest 方法直接作为监听成功的调用方法。已经拿到了 包含 req res 的 ctx 和可以执行所有中间件函数的 fn。首先一进来默认设置状态码为404 . 然后分别声明了 成功函数执行完成以后的成功 失败回调方法。这两个方法实际上就是再将 ctx 分化成 req res。 分别调这两个对象去客户端执行内容返回。context.js request.js response.js 分别是封装了一些对 ctx req res 操作相关的属性，我们以后再说。 // application.js module.exports = class Application extends Emitter { ... handleRequest(ctx, fnMiddleware) { const res = ctx.res; // 拿到context.res res.statusCode = 404; // 设置默认状态吗404 const onerror = err => ctx.onerror(err); // 设置onerror触发事件 const handleResponse = () => respond(ctx); // 向客户端返回数据 onFinished(res, onerror); return fnMiddleware(ctx).then(handleResponse).catch(onerror); } } 失败执行的回调 onerror(err) { assert(err instanceof Error, `non-error thrown: ${err}`); if (404 == err.status || err.expose) return; if (this.silent) return; const msg = err.stack || err.toString(); console.error(); console.error(msg.replace(/^/gm, ' ')); console.error(); } 成功执行的回调 function respond(ctx) { ... } return fnMiddleware(ctx).then(handleResponse).catch(onerror); 我们拆分理解，首先 return fnMiddleware(ctx) 返回了一个中间件数组处理链路，then(handleResponse) 等到整个中间件数组全部完成之后把返回结果通过 then 传递到 handleResponse。 // application.js module.exports = class Application extends Emitter { ... createContext(req, res) { const context = Object.create(this.context); const request = context.request = Object.create(this.request); const response = context.response = Object.create(this.response); context.app = request.app = response.app = this; context.req = request.req = response.req = req; context.res = request.res = response.res = res; request.ctx = response.ctx = context; request.response = response; response.request = request; context.originalUrl = request.originalUrl = req.url; context.cookies = new Cookies(req, res, { keys: this.keys, secure: request.secure }); request.ip = request.ips[0] || req.socket.remoteAddress || ''; context.accept = request.accept = accepts(req); context.state = {}; return context; } } 这里我们不用去太深入代码，理解原理即可。createContext 创建 context 的时候，还会将 req 和 res 分别挂载到 context 对象上，并对 req 上一些关键的属性进行处理和简化 挂载到该对象本身，简化了对这些属性的调用。我们通过一张图来直观地看到所有这些对象之间的关系。 最左边一列表示每个文件的导出对象 中间一列表示每个 Koa 应用及其维护的属性 右边两列表示对应每个请求所维护的一些列对象 黑色的线表示实例化 红色的线表示原型链 蓝色的线表示属性 createContext 简单理解就是挂载上面的对象，方便整个上下游 http 能及时访问到进出请求及特定的行为。 // application.js module.exports = class Application extends Emitter { ... } function respond(ctx) { // allow bypassing koa if (false === ctx.respond) return; const res = ctx.res; if (!ctx.writable) return; let body = ctx.body; const code = ctx.status; // 赋值服务状态码 if ('HEAD' == ctx.method) { // 请求头方法判断 if (!res.headersSent &amp;&amp; isJSON(body)) { ctx.length = Buffer.byteLength(JSON.stringify(body)); } return res.end(); } // status body if (null == body) { body = ctx.message || String(code); if (!res.headersSent) { ctx.type = 'text'; ctx.length = Buffer.byteLength(body); } return res.end(body); } // 通过判断body类型来调用，这里的res.end就是最终向客户端返回数据的动作 if (Buffer.isBuffer(body)) return res.end(body); if ('string' == typeof body) return res.end(body); if (body instanceof Stream) return body.pipe(res); // 返回为json数据 body = JSON.stringify(body); if (!res.headersSent) { ctx.length = Buffer.byteLength(body); } res.end(body); } respond 函数是 handleRequest 成功处理的回调，内部做了合理性校验，诸如状态码，内容的类型判断，最后向客户端返回数据。 结语以上就是我们对 application.js 文件的分析，通过上面的分析，我们已经可以大概得知 Koa 处理请求的过程：当请求到来的时候，会通过 req 和 res 来创建一个 context (ctx) ，然后执行中间件。","tags":[{"name":"Nodejs","slug":"Nodejs","permalink":"http://coder.liusixin.cn/tags/Nodejs/"},{"name":"Koa2","slug":"Koa2","permalink":"http://coder.liusixin.cn/tags/Koa2/"}]},{"title":"Javascript 高级技巧","date":"2018-02-28T09:14:32.000Z","path":"posts/4bd5734d/","text":"前言 安全的类型检测 惰性载入函数 柯里化 防篡改对象 冻结对象 定时器 函数节流 安全的类型检测是怎么安全地检测一个变量的类型，例如判断一个变量是否为一个数组。一般是使用 instanceof let data = [1, 2, 3]; console.log(data instanceof Array); //true 但是这种方式有一个弊端，就是在 iframe 里面判断一个父窗口的变量的时候会不准确。 Array !== window.parent.Array; 这个其实很好解释，它们分别是两个函数（父窗口定义的和子窗口定义的），内存地址不一样，Object 等式判断不成立，而window.parent.arrayData.constructor 返回的是父窗口的 Array, 比较的时候是在子窗口，使用的是子窗口的 Array, 这两个 Array 不相等，所以导致判断不成立。 使用 Object.prototype.toString 判断 var toString = Object.prototype.toString; toString.call([1, 2, 3]); // [object Array] toString.call({}); // [object Object] toString.call(function() {}); // [object Function] toString.call(''); // [object String] toString.call(1); // [object Number] toString.call(null); // [object Null] toString.call(undefined); // [object Undefined] 可以用这个函数安全地判断变量是不是数组。 注意要使用 call, 而不是直接调用，call 的第一个参数是 context 执行上下文，把数组传给它作为执行上下文。 var toString = Object.prototype.toString; class Person {} console.log(toString.call(Person)); // [object Function] console.log(toString.call(new Person())); // [object Object] 可以看到 es6 的 class 也是用 function 实现的原型，也就是说 class 和 function 本质上是一样的，只是写法上不一样。 惰性载入函数UA 判断 有时候我们需要做一些兼容性判断，比如 UA 的判断。 // UA的类型 getUAType: function() { let ua = window.navigator.userAgent; if (ua.match(/renren/i)) return O; else if (ua.match(/MicroMessenger/i)) return 1; else if (ua.match(/weibo/i)) return 2; return -1; } 这个函数的作用是判断用户是在哪个环境打开的网页，以便于统计哪个渠道的效果比较好。 这种类型的判断有一个特点，就是它的结果是固定的，不管执行判断多少次，都会返回相同的结果，用户的 UA 在这个网页不可能会发生变化（除了调试设定的之外）。所以为了优化，我们采用惰性函数优化下代码： var pageData = { getUAType: function() { let ua = window.navigator.userAgent; if (ua.match(/renren/i)) { pageData.getUAType = () => 0; return O; } else if (ua.match(/MicroMessenger/i)) { pageData.getUAType = () => 1; return 1; } else if (ua.match(/weibo/i)) { pageData.getUAType = () => 2; return 2; } return -1; } }; 每次判断之后把 getUAType 这个函数重新赋值，变成一个新的 function, 而这个 function 直接返回一个确定的变量，这样在下一次获取就可以跳过判断了，这就是惰性函数的作用。 更简单的实现，直接用变量存起来 let ua = window.navigator.userAgent; let UAType = ua.match(/renren/i) ? 0 : ua.match(/MicroMessenger/i) ? 1 : ua.match(/weibo/i) ? 2 : -1; 连函数都不用写了，缺点是即使没有使用到 UAType 这个变量，也会执行一次判断，但是我们认为这个变量被用到的概率还是很高的。 localStorage 兼容处理 我们再举一个比较有用的例子，由于 Safari 的无痕浏览会禁掉本地存储，因此需要写一个兼容性判断 Data.localStorageEnabled = true; // Safari的无痕浏览会禁用 localStorage try { window.localStorage.trySetData = 1; } catch (e) { Data.localStorageEnabled = false; } function setLocalData(key, value) { if (Data.localStorageEnabled) { window.localStorage[key] = value; } else { util.setCookie('_L_' + key, value, 1000); } } 在设置本地数据的时候，需要判断一下是不是支持本地存储，如果是的话就用 localStorage ,否则改用 cookie。 可以用惰性函数改造一下: setLocalData: function(key, value) { if (Data.localStorageEnabled) { util.setLocalData = function(key, value) { return window.localStorage[key]; } } else { util.setLocalData = function(key, value) { return util.getCookie(\"_L_\" + key); } } return util.setLocalData(key, value); } 函数绑定 有时候要把一个函数当作参数传递给另一个函数执行， 此时函数的执行上下文往往会发生变化 class DrawTool { constructor() { this.points = []; } init() { $map.on('click', this.handleMouseClick); } handleMouseClick(event) { this.points.push(event.latLng); } } click 事件的执行回调里面 this 不是指向了 DrawTool 的实例了，所以里面的 this.points 将会返回 undefined。 第一种解决方法是使用闭包，先把 this 缓存起来 init() { let that = this; $map.on('click', that.handleMouseClick); } 使用箭头函数： $map.on('click', event => this.handleMouseClick(event)); 箭头函数的 this 还是指向父级的上下文，因此这里不用自已创建一个闭包，直接用 this 就可以。 第二种是 ES5 的 bind 函数绑定 $map.on('click', this.handleMouseClick.bind(this)); bind 函数其实实现起来非常简单： Function.prototype.bind = function(context) { return () => this.call(context); }; 柯里化 柯里化就是一个函数的返回结果当成另一个函数的入参执行，就是函数和参数值结合产生一个新的函数。 function add(a, b) { return a + b; } let add1 = add.curry(1); console.log(add1(5)); // 6 console.log(add1(2)); // 3 要实现这样一个 curry 的函数，它的重点是要返回一个函数，这个函数有一些闭包的变量记录了创建时的默认参数，然后执行这个返回函数的时候，把新传进来的参数和默认参数拼一下变成完整参数列表去调用原本的函数。来看代码： Function.prototype.curry = function() { let slice = Array.prototype.slice; let defaultArgs = slice.call(arguments); let that = this; return function() { return that.apply(this, defaultArgs.concat(slice.call(arguments))); }; }; 现在举一下柯里化一个有用的例子，当需要把一个数组降序排序的时候: let data = [1, 5, 2, 3, 10]; data.sort((a, b) => b - a); // [10, 5, 3, 2, 1] 给 sort 传一个函数的参数，但是如果你的降序操作比较多，每次都写－个函数参数还是有点烦的，因此可以用柯里化把这个参数固化起来 Array.prototype.sortDescending = Array.prototype.sort.curry((a, b) => b - a); let data = [1, 5, 2, 3, 10]; data.sortDescending(); console.log(data); // [10, 5, 3, 2, 1] 防止篡改对象1. Object.seal 防止新增和删除属性let person = { name: 'liusixin' }; Object.seal(person); delete person.name; // 不能删 console.log(person.name); // 输出liusixin person.age = 18; // 不能加 console.log(person.age); // 输出undefined 当把一个对象 seal 之后，将不能添加和删除属性。 注意：当使用严格模式将会抛异常 2. Object.freeze 冻结对象这个方法是不能改属性值 let person = { name: 'liusixin' }; Object.freeze(person); person.name = 'lsx'; // 不能修改 console.log(person.name); // 输出lsx 同时可以使用 Object.isFrozen、Object.isSealed、Object.isExtensible 判断当前对象的状态。 3. defineProperty 冻结单个属性设置 enumable/writable为 false, 那么这个属性将不可遍历和写。 let person = { name: 'liusixin' }; Object.defineProperty(person, 'grade', { enumerable: false, value: 3 }); for (var key in person) { console.log(key); // name console.log(person.grade); // 3 } 定时器我们知道在 C/C++/Java 等语言都是有 sleep 函数的，但是 JS 没有。那么怎样实现一个 JS 版的 sleep 函数呢？ sleep 函数的作用是让线程进入休眠，当到了指定时间后再重新唤起。你不能写个 while 循环然后不断地判断当前时间和开始时间的差值是不是到了指定时间，因为这样会占用 CPU, 就不是休眠了。 我们可以使用 setTimeout + 回调 function sleep(millionSeconds, callback) { setTimeout(callback, millionSeconds); } // sleep 2秒 sleep(2000, () => console.log('sleep recover')); 但是回调如果过多的话会造成回调地狱，可读性差，我们用 Promise 改写 function sleep(millionSeconds) { return new Promise(resolve => { setTimeout(resolve, millionSeconds); }); } // sleep 2秒 sleep(2000).then(() => console.log('sleep recover')); async/await 改写 function sleep(millionSeconds) { return new Promise(resolve => { setTimeout(resolve, millionSeconds); }); } async function init() { await sleep(2000); console.log('sleep recover'); } init(); 相对于简单的 Promise 版本，sleep 的实现还是没变。不过在调用 sleep 的前面加一个 await，这样只有 sleep 这个异步完成了，才会接着执行下面的代码。同时需要把代码逻辑包在一个 async 标记的函数里面，这个函数会返回一个 Promise 对象，当里面的异步都执行完了就可以 then 了。 init().then(() => console.log('init finished')); 关于定时器还有－个很重要的话题，那就是 setTimeout 和 setlnterval 的区别: setTimeout 是在当前执行单元都执行完才开始计时，而 setlnterval 是在设定完计时器后就立马计时。 let scriptBegin = Date.now(); fun1(); fun2(); // 需要执行20ms的工作单元 function act(functionName) { console.log(functionName, Date.now() - scriptBegin); let begin = Date.now(); while (Date.now() - begin &lt; 20); } function fun1() { let fun3 = () => act('fun3'); setTimeout(fun3, 0); act('fun1'); } function fun2() { act('fun2 - 1'); var fun4 = () => act('fun4'); setInterval(fun4, 20); act('fun2 - 2'); } 这段代码的执行模型是这样的： 打印结果： 函数节流 throttling节流的目的是为了不想触发执行得太快，比如： 监听 input 触发搜索； 监听 resize 做响应式调整； 监听 mousemove 调整位置。 function throttle(method, context) { clearTimeout(method.tId); method.tId = setTimeout(function() { method.call(context); }, 100); } 每次执行都要 setTimeout 一下，如果触发得很快就把上一次的 setTimeout 清掉重新 setTimeout, 这样就不会执行很快了。 但是这样有个问题，这个回调函数可能永远不会执行，因为它一直在触发，一直在清掉 tId, 这就尴尬了 -_- ，上面代码的本意应该是 1OOms 内最多触发一次，而实际情况是可能永远不会执行。这种实现应该叫防抖，不是节流。 把上面的代码稍微改造一下： function throttle(method, context) { if (method.tId) return; method.tId = setTimeout(function() { method.call(context); method.tId = 0; }, 100); } 这个实现就是正确的，每 1OOms 最多执行一次回调，原理是在 setTimeout 里面把 tId 给置成 0, 这样能让下一次的触发执行。大概每 1OOms 就执行一次，这样就达到我们的目的。 但是这样有一个小问题，就是每次执行都是要延迟 1OOms, 有时候用户可能就是最大化了窗口，只触发了一次 resize 事件，但是这次还是得延迟 1OOms 才能执行，我们再优化下代码： function throttle(method, context) { // 如果是第一次触发， 立刻执行 if (typeof method.tId === 'undefined') { method.call(context); } if (method.tId) return; method.tId = setTimeout(function() { method.call(context); method.tId = 0; }, 100); } 先判断是否为第一次触发，如果是的话立刻执行。这样就解决了上面提到的问题，但是这个实现还是有问题，因为它只是全局的第一次，用户最大化之后，隔了一会又取消最大化了就又有延迟了，并且第一次触发会执行两次。继续优化： function throttle(method, context) { if (!method.tId) { method.call(context); method.tId = 0; setTimeout(() => (method.tId = 0), 100); } } 每次触发的时候立刻执行，然后再设定一个计时器，把 tId 置成 0。这个实现比之前的实现还要简洁，并且能够解决延迟的问题。 但还是有一个问题就是最后 1OOms 的信息将会被丢弃，一般应该是希望最后的那次触发能够执行，因为那个才是最终的状态。 防抖是只执行重复操作的最后一次，而节流是每多少单位时间内只执行一次。","tags":[{"name":"javascript","slug":"javascript","permalink":"http://coder.liusixin.cn/tags/javascript/"},{"name":"函数式编程","slug":"函数式编程","permalink":"http://coder.liusixin.cn/tags/函数式编程/"}]},{"title":"理解移动端click及自定义事件","date":"2018-02-21T13:03:38.000Z","path":"posts/8a8d16c9/","text":"前言大家都知道移动端有 300ms 点击延迟，移动端尽量不要使用 click，因为 click 会比较迟钝，尽量使用 touchstart。但是 touchstart 也会有一个问题， 用户在滑动页面的时候要是不小心碰到了相关元素也会触发 touchstart。 首先为什么移动端的 click 会迟钝呢？因为移动端要判断是否是双击，所以单击之后不能够立刻触发 click, 要等 300ms, 直到确认不是双击了才触发 click。所以就导致了 click 有延迟。 解决延迟在 2014 年的 Chrome32 版本已经把这个延迟去掉了，如果有一个 meta 标签 &lt;meta name=\"viewport\" content=\"width=device-width\"> 把 viewport 设置成设备的实际像素，那么就不会有这 300ms 的延迟。 如果设置 initial-scale=1.0, 在 Chrome 上是可以生效的， 但是 Safari 不会 &lt;meta name=\"viewport\" content=\"width=initial-scale=1.0\"> 还有第三种办法是设置 css html { touch-action: manipulation; } 这样也可以取消掉 300ms 的延迟，Chrome 和 Safari 都可以生效。 click/touch 触发顺序要弄明白 click 的延迟原因，我们先要搞清楚 click 是在什么时候触发，并研究下它的触发顺序。 &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"> &lt;title>移动端click及自定义事件&lt;/title>\\ &lt;/head> &lt;body> &lt;div id=\"target\" style=\"height:100px;background-color:red\">hello, world&lt;/div> &lt;script> ! function() { var target = document.getElementById(\"target\"); var body = document.querySelector(\"body\"); var touchstartTime = 0; function log(event) { if(event.type === \"touchstart\") touchstartTime = Date.now(); console.log(event.type, Date.now() - touchstartTime); } target.onclick = log; target.ontouchstart = log; target.ontouchend = log; target.ontouchmove = log; target.onmouseover = log; target.onmousedown = log; target.onmouseup = log; }(); &lt;/script> &lt;/body> &lt;/html> 在浏览器下测试 从结果上看，click 是最后出发的，并且有 300ms 延迟，之所有实际结果会比 300ms 大是因为浏览器内核运行也会消耗时间。 然后我们加上 viewport 的 meta 标签，再看打印结果 可以看到， 300ms 的延迟没有了。 这里用加上 css 的 touch-action: manipulation;属性也会有一样的效果。 tap 事件的实现知道了 click 是在 touchend 之后触发的， 那么我们来尝试一下实现一个 tap 事件。 这里有两个库是可以快速实现 tap 无延迟的效果，一个是 zepto, 另一个是 fastclick。其中 zepto 有一个自定义事件 tap, 它是一个没有延迟的 click 事件。而 fastclick 是在 touchend 之后生成一个 click 事件，并立即触发这个 click, 再取消原本的 click 事件。他们原理都是一样的，都是在 touchend 之后触发，一个是触发它自己定义的 tap 事件，一个是触发原生 click。 还有一个关键的问题是如果用户是上下滑动也会频繁触发 tap 事件。怎么判定用户是单击还是在上下滑呢? Zepto：位移偏差 记录下 touchstart 的初始位移， 然后 touchend 的位移减掉初始位移的偏差如果在 30 以内，则认为用户是单击，大于 30 就认为是滑动。 fastclick：时间偏差 分别记录 touchstart 和 touchend 的时间戳， 如果它们的时间差大于 700 毫秒，则认为是滑动操作，否则是单击操作。 现在我们来实现一个按位移偏差判断的 tap。 要实现一个自定义事件，有两种方式，第一种是像 jQuery/Zepto 一样，自己封装一个事件机制，第二种是调用原生的 document.createEvent, 然后再执行 div.dispatchEvent(event), 这里我们使用第一种方式 先写一个选择器 var $ = function(selector) { var dom = null; if (typeof selector === 'string') { dom = document.querySelectorAll(selector); } else if (selector instanceof HTMLElement) { dom = selector; } return new $Element(dom); }; window.$ = $; 选择器的名称用＄， 它是一个函数，传进来的参数为选择器或者 DOM 元素，如果是字符串的选择器，则调用 querySelectorAll 去获取 DOM 元素，如果它已经是一个 DOM 则不用处理，最后返回一个 $Element 封装的实例，类似于 jQuery 对象。 现在来实现这个 $Element 的类 class $Element { constructor(_doms) { var doms = _doms.constructor === Array || _doms.constructor === NodeList ? _doms : [_doms]; this.doms = doms; this.init(); for (var i = 0; i &lt; doms.length; i++) { this[i] = doms[i]; // 把 this 当作一个数组， DOM 元素当作这个数组的元素。 这样就可以通过索引获取 DOM 元素 if (!doms[i].listeners) { doms[i].listeners = {}; } } } } $Element 的构造函数里面，先判断参数的类型，如果它不是一个数组或是用 querySelectorAll 返回的 NodeList 类型，则构造一个 DOM 数组。然后给这些 DOM 对象添加一个 listeners 的属性，用来存放事件的回调函数。 一般不推荐给原生对象添加东西。但是从简单考虑，这里先用这样的方法。 上面 this[i] = doms[i]; 这步注释已经写明，然后就可以通过以下方式获取 var value = $('input')[0].value; 它是一个伪数组，是一个 $Element 实例，又有 length, 可以通过 index 获取元素，这部分代码也让我们知道了 arguments 实例、jQuery 对象这种伪数组是怎么来的。 上面代码还调用了一个 init, 这个 init 函数用来添加 tap 事件。 init() { for (var i = 0; i &lt; this.doms.length; i++){ if(!this.doms[i].listeners) { this.initTapEvent(this.doms[i]); } } } 还需要提供事件绑定和触发的 API on(eventType, callback) { for (var i = 0; i &lt; this.doms.length; i++) { var dom = this.doms[i]; if (!dom.listeners[eventType]) { dom.listeners[eventType] = []; } dom.listeners[eventType].push(callback); } } on 函数会给 DOM 的 listeners 属性添加相应事件的回调， 每种事件类型都用一个数组存储。 触发的代码 trigger(eventType, event){ for(var i = 0; i &lt; this.doms.length; i++) { $Element.dispatchEvent(this.doms[i], eventType, event); } } static dispatchEvent(dom, eventType, event){ var listeners = dom.listeners[eventType]; if(listeners){ for(var i = 0; i &lt; listeners.length; i++) { listeners[i].call(dom, event); } } } 根据不同的事件类型去取回调函数的数组，依次执行。 现在重点来说一下怎么添加一个 tap 事件， 即上面的 initTapEvent 函数 initTapEvent(dom) { var x1 = 0, x2 = 0, y1 = 0, y2 = 0; dom.addEventListener(\"touchstart\", function(event) { }); dom.addEventListener(\"touchmove\", function(event) { }); dom.addEventListener(\"touchend\", function(event) { }); } 实现的思路是这样的， 在 touchstart 的时候记录 x1 和 y1 的位置 dom.addEventListener('touchstart', function(event) { var touch = event.touches[0]; x1 = x2 = touch.pageX; y1 = y2 = touch.pageY; }); 如果你用两根手指的话， 那么 event.touches.length 就是 2, 如果是 3 根则为 3, 进而分别获得到每根手指的位置，由于我们是单点，所以就获取第一个手指的位置即可。pageX/pageY 是相对于当前 HTML 页面的位置，而 clientX 和 clientY 是相对于视图窗口的位置。 然后在 touchmove 的时候获取到最新的移动位置 dom.addEventListener('touchmove', function(event) { var touch = event.touches[0]; x2 = touch.pageX; y2 = touch.pageY; }); 最后 touchend 的时候，比较位移偏差 dom.addEventListener('touchend', function(event) { if (Math.abs(x2 - x1) &lt; 10 &amp;&amp; Math.abs(y2 - y1) &lt; 10) { $Element.dispatchEvent(dom, 'tap', new $Event(x1, y1)); } y2 = x2 = 0; }); 如果两者的位移差小千 10, 则认为是 tap 事件，并触发这个事件。这里封装了定义事件 class $Event { constructor(pageX, pageY) { this.pageX = pageX; this.pageY = pageY; } } 然后就可以使用这个 tap 事件 $('#target').on('tap', function(event) { console.log('tap', event.pageX, event.pageY); }); 当单击目标区域的时候就会执行 tap 回调，而上下滑动的时候则不会触发。 再比较一下 tap 和原生 click 的触发时间的差别，需要给自定义事件添加一个 click dom.addEventListener('click', function(event) { $Element.dispatchEvent(dom, 'click', new $Event(event.pageX, event.pageY)); }); 我们用一个 tapTime 记录一下时间 var tapTime = 0; $('#target').on('tap', function(event) { tapTime = Date.now(); console.log('tap', tapTime); }); $('#target').on('click', function(event) { console.log('click time diff', Date.now() - tapTime); }); click 会大概慢 200ms, 可能是因为它前面还要触发 mouse 的事件。 这样我们就实现了一个自定义 tap 事件，fastclick 是使用原生的 Event, 在 touchend 的回调函数里面执行。 touch = event.changedTouches[O]; // Synthesise a click event, with an extra attribute so it can be tracked clickEvent = document.createEvent('MouseEvents'); clickEvent.initMouseEvent( this.determineEventType(targetElement), true, true, window, 1, touch.screenX, touch.screenY, touch.clientX, touch.clientY, false, false, false, false, 0, null ); clickEvent.forwardedTouchEvent = true; targetElement.dispatchEvent(clickEvent); 然后再调用 event.preventDefault 禁掉原本的 click 事件的触发。它里面还做了其他一些兼容性的处理。 这个时候如果要做一个放大的事件，可以在 touchstart 里面获取 event.touches 两根手指的初始位置，保存初始化手指的距离，然后在 touchmove 里面再次获取新位置，计算新的距离减掉老的距离，如果是正数则说明是放大，反之缩小，放大和缩小的尺度也是可以取一个相对值。手机 Safari 有一个 gesturestart/gesturechange/gestureend 事件，在 gesturechange 的 event 里面有一个放大比例 scale 的属性。 摇一摇事件HTML5 新增了一个 devicemotion 的事件，可以使用手机的重力感应 window.ondevicemotion = function(event) { var gravity = event.accelerationIncludingGravity; console.log(gravity.x, gravity.y, gravity.z); }; x, y, z 表示三个方向的重力加速度 x 是手机短边，y 是长边，z 是和手机屏幕垂直的方向，当把手机平着放的时候，由于 x、y 和地平线平行， 所以 g(x) = g(y) = 0, 而 z 和地平线垂直， 所以 g(z) = 9.8 左右， 同理当把手机竖着放的时候，g(x) = g(z) = 0, 而 g(y) = -9.8。 devicemotion 事件会不断地触发，而且触发得很快。当我们把手机拿起来摇一摇的时候 y 轴和 x 轴的变化范围从 -45° 到 +45°, 即这个区间是：delta = 9.8 * sin(45°) * 2 = 13.8。即只要 x 轴和 y 轴的 g 值变化超过 13.8, 我们就认为发生了摇一摇事件。 根据上面的分析，我们就可以写出代码： const EMPTY_VALUE = 100; const THREAD_HOLD = 13.8; var minX = EMPTY_VALUE, minY = EMPTY_VALUE; window.ondevicemotion = function(event) { var gravity = event.accelerationIncludingGravity, x = gravity.x, y = gravity.y; if (x &lt; minX) minX = x; if (y &lt; minY) minY = y; if (Math.abs(x - minX) > THREAD_HOLD &amp;&amp; Math.abs(y - minY) > THREAD_HOLD) { console.log('shake'); var event = new CustomEvent('shake'); window.dispatchEvent(event); minX = minY = EMPTY_VALUE; } }; window.addEventListener('shake', function() { console.log('window shake callback was called'); }); 用一个 minX 和 minY 记录最小的值，每次 devicemotion 触发的时候就判断当前的 g 值与最小值的差值是否超过了阈值，如果是的话就创建一个 CustomEvent 的实例，然后 dispatch 给 window, window 上监听的 onshake 事件就会触发了。 这样就实现了一个摇一摇 shake 事件。如果太难触发可以把阈值改小一点。 总结本文比较了移动端 touch 事件和 click 事件的区别， 以及怎么去掉 click 事件的 300ms 延迟，怎么实现一个快速响应的 tap 事件，怎么封装和触发自定义事件，还有摇一摇的原理是怎么样的， 怎么实现一个摇一摇的 shake 事件。 上面用一个 $Element 的类，由它负责决定是否触发 tap, 而调用者不需要关心 tap 事件触发的细节，这个 $Element 就相当于一个事件代理，或者也可以把 tap 当作一个门面。所以它是一个代理模式或门面模式。","tags":[{"name":"javascript","slug":"javascript","permalink":"http://coder.liusixin.cn/tags/javascript/"},{"name":"HTML5","slug":"HTML5","permalink":"http://coder.liusixin.cn/tags/HTML5/"}]},{"title":"记一次 React SSR 服务端渲染基础搭建过程","date":"2018-02-14T17:02:30.000Z","path":"posts/7ab5ac9a/","text":"文章思路来源于 慕课网: Webpack+React 全栈工程架构项目实战精讲 要做服务端渲染，首先我们要明白为什么做，它的优劣势如何？随着前后分离项目普及，单页应用越来越流行，然而一些问题也随之而来： 单页应用渲染由 js 完成（客户端渲染），浏览器最初获取的是一个空的 html。 SEO 由于内容都是 js 生成的，这中间就存在了一个 js 获取数据渲染页面的过程，相较于后端模板渲染完 html 再发送给浏览器，存在首页白屏问题，用户体验差。 首屏渲染白屏 所谓 ssr，和之前的传统的多页面网站服务器端渲染不是同一个层次，在现有架构不变的情况下，即后端依旧只是提供 api 服务，前端人员依旧通过 ajax 请求数据，同时要达到传统多页应用的首屏加载速度以及 seo 优化。 现在最常见的做法是引入一层中间层 node 难点在于： 数据同步 路由跳转 SEO 信息 如何在开发时方便的进行服务端渲染的测试（模块热更新） 最近在接触 React 服务端渲染时看到了慕课上的这堂课，自己也看了一遍，以此总结一下，也发现自己在这部分内容的不足之处。想玩转服务端渲染，门槛相当来说也不低，需要有： react 全家桶的一些基础知识(react-router、redux 或 mobx 等) webpack 基础 node 基础 node 框架使用经验 express 或 koa es6 基础 如果拥有以上技能，配出一个服务端渲染不会很难 工程开发环境搭建工程目录- build: webpack配置文件夹（客户端/服务端） - webpack.config.base.js 公共配置文件 - webpack.config.client.js 客户端webpack配置文件 - webpack.config.server.js 服务端webpack配置文件 - client: 源码文件夹 - App.jsx 入口组件 - app.js 客户端入口js文件 - server-entry 服务端入口js文件 - template html模板 - node_modules: 依赖模块 - server： 服务端文件 - server.js: express启动文件 - util 工具方法类文件 - dev-static 服务端开发环境运行文件 - babelrc： babel配置文件 - .editorconfig：编辑器配置文件 - package.json package.json 依赖： { \"dependencies\": { \"axios\": \"^0.17.1\", \"express\": \"^4.16.2\", \"react\": \"^16.2.0\", \"react-dom\": \"^16.2.0\" }, \"devDependencies\": { \"babel-core\": \"^6.26.0\", \"babel-loader\": \"^7.1.2\", \"babel-preset-es2015\": \"^6.24.1\", \"babel-preset-es2015-loose\": \"^8.0.0\", \"babel-preset-react\": \"^6.24.1\", \"cross-env\": \"^5.1.3\", // 用于命令行启动webpack设置dev或者prod环境 \"html-webpack-plugin\": \"^2.30.1\", // 生成html文件并自动注入jswebpack插件 \"http-proxy-middleware\": \"^0.17.4\", // express端口转发中间件 \"memory-fs\": \"^0.4.1\", // 第三方fs模块,内存读写] \"react-hot-loader\": \"^4.0.0-beta.13\", // react热替换插件 用于维持react组件开发状态 \"rimraf\": \"^2.6.2\", // 删除文件夹用的npm包 \"webpack-dev-server\": \"^2.11.0\", // 前端开发环境服务webpack插件 \"webpack\": \"^3.10.0\", \"webpack-merge\": \"^3.0.0\" } } npm scripts： \"build:client\": \"webpack --config build/webpack.config.client.js\", \"build:server\": \"webpack --config build/webpack.config.server.js\", \"dev:client\": \"cross-env NODE_ENV=development webpack-dev-server --config build/webpack.config.client.js\", \"dev:server\": \"cross-env NODE_ENV=development node server/server.js\", \"clear\": \"rimraf dist\", \"build\": \"npm run clear &amp;&amp; npm run build:client &amp;&amp; npm run build:server\" 客户端相关入口 js 文件 import React from 'react'; import ReactDOM from 'react-dom'; import { AppContainer } from 'react-hot-loader'; import App from './App.jsx'; // ReactDOM.hydrate( &lt;App />, document.getElementById('root')); const root = document.getElementById('root'); const render = Component => { const renderMethod = module.hot ? ReactDOM.render : ReactDOM.hydrate; // ReactDOM.hydrate( renderMethod( &lt;AppContainer> &lt;Component /> &lt;/AppContainer>, root ); }; render(App); if (module.hot) { module.hot.accept('./App.jsx', () => { const NextApp = require('./App.jsx').default; // ReactDOM.hydrate( &lt;NextApp />, document.getElementById('root')); render(NextApp); }); } 客户端 webpack 配置 const path = require('path'); const webpack = require('webpack'); const HTMLWebpackPlugin = require('html-webpack-plugin'); // 生成html页面，同时可以将生成的js注入该html的插件 const isDev = process.env.NODE_ENV === 'development'; // 判断当前环境 根据环境不同采取不同的webpack配置 在命令行中设置当前环境 要通过cross-env这个包来保证linux mac win三个平台配置一致 const config = { entry: { app: path.join(__dirname, '../client/index.js') }, output: { filename: '[name].[hash].js', path: path.join(__dirname, '../dist'), // 静态资源最终访问路径 = output.publicPath + 资源loader或插件等配置路径 距离：html中引用js 由 ‘/app.js’ 变为 // '/public/app.js' publicPath: '/public/' }, module: { rules: [ // jsx文件通过babel-loader进行处理 核心库：babel-core 插件：babel-preset-es2015 // babel-preset-es2015-loose babel-preset-react 配置文件在根目录.babelrc中 { test: /.jsx$/, loader: 'babel-loader' }, // node_modules下的js代码不可以用babel编译，所以我们js和jsx分开写 { test: /.js$/, loader: 'babel-loader', exclude: [path.join(__dirname, '../node_modules')] } ] }, plugins: [ new HTMLWebpackPlugin({ // 根据模板生成html文件 template: path.join(__dirname, '../client/template.html') }) ] }; if (isDev) { config.entry = { app: ['react-hot-loader/patch', path.join(__dirname, '../client/index.js')] }; config.devServer = { // '0,0,0,0'表示我们可以用任何方式进行访问 如localhost 127.0.0.1 以及外网ip 若配置为'localhost' // 或'127.0.0.1'别人无法从外网进行调试 host: '0.0.0.0', // 起服务的端口 port: '8888', // 起服务的目录，此处与output一致，此处有坑(要考虑publicPath，还要知晓webpack-dev-server生成的文件在内存中，若项目中已经有 // 了dist则以项目中的dist为准，所以删掉dist吧) contentBase: path.join(__dirname, '../dist'), // 热更新 如果不配置webpack-dev-server会在文件修改后全局刷新而非局部替换 hot: true, overlay: { // 如果打包过程中出现错误在浏览器中渲染一层overlay进行展示 errors: true }, // 在此处设置与output相同的publicPath,把静态资源文件放在public文件夹下 // 使得output.publicPath得以正常运行，其实这里的publicPath更像是output.path publicPath: '/public/', // 解决刷新404问题（服务端没有前端路由指向的文件） 全都返回index.html historyApiFallback: { index: '/public/index.html' } }; config.plugins.push(new webpack.HotModuleReplacementPlugin()); } module.exports = config; 服务端相关服务端渲染需要两个文件 html 模板 js 文件 将这两部分内容通过 react 服务端渲染方法结合为渲染好的 html 返回给浏览器，便完成了服务端渲染 入口 js 文件 import React from 'react'; import App from './App.jsx'; export default &lt;App />; 服务端 webpack 配置 // 服务端渲染的webpack配置文件 const path = require('path'); module.exports = { // 打包出来的js代码执行在哪个环境 target: 'node', entry: { app: path.join(__dirname, '../client/server-entry.js') }, output: { // 服务端没有浏览器缓存 hash没必要，同时要自己手动引入js filename: 'server-entry.js', path: path.join(__dirname, '../dist'), publicPath: '/public', libraryTarget: 'commonjs2' }, module: { rules: [ { test: /.jsx$/, loader: 'babel-loader' }, { test: /.js$/, loader: 'babel-loader', exclude: [path.join(__dirname, '../node_modules')] } ] } }; express 有了 js，再去取到硬盘上的 html 我们就实现了一个基础的服务端渲染 demo，暂不考虑开发时的热更新等等 server/server.js const express = require('express'); const ReactSSR = require('react-dom/server'); const fs = require('fs'); const path = require('path'); const isDev = process.env.NODE_ENV === 'development'; const app = express(); if (!isDev) { // production环境 const serverEntry = require('../dist/server-entry').default; const template = fs.readFileSync( path.join(__dirname, '../dist/index.html'), 'utf8' ); // 将dist目录下的所有文件都托管在public文件夹下 app.use('/public', express.static(path.join(__dirname, '../dist'))); app.get('*', function(req, res) { // 服务端渲染 const appString = ReactSSR.renderToString(serverEntry); // 替换模板并返回 为啥是&lt;!-- app --> 因为template.html根节点里面的注释，用来占位的 res.send(template.replace('&lt;!-- app -->', appString)); }); } else { // devlopment环境 const devStatic = require('./util/dev-static'); devStatic(app); } app.listen(3333, function() { console.log('===================================='); console.log('server is listenging on 3333'); console.log('===================================='); }); 接下来，我们只需要： webpack 打包（服务端） 启动 express 服务 就可以在 localhost:3333 端口访问到服务端渲染好的页面了，但是这里有一个问题没解决： 每一次进行改动都需要进行打包，无法热更新 我们知道，和生产环境不一样，开发时，webpack-dev-server 是将打包文件放在内存之中而不是直接写文件在硬盘上，读写内存是比读写硬盘快得多的，这样我们修改源文件，反应速度就大大增加了，所以我们服务端也遵循这样的思路引入了 memory-fs 客户端开发的环境都搭建好了，我们就依赖客户端环境来进行热更新岂不妙哉？所以我们引入了 http-proxy-middleware 中间件，这样在客户端 webpack-dev-server 启动的条件下，我们的可以实时地获得起更新的内容。 服务端渲染需要的的 js 通过作为 node 模块的 webpack 的方式来进行监听打包（不能直接 require 进来，需要通过比较 hack 的方式读取为字符串转成 js），那需要的 html 呢，并没有直接写在硬盘上，但是客户端环境是已经启动了的，我们通过 axios 去拿到即可。 /server/util/dev-static.js // 该文件为开发时服务端渲染的配置 可以理解为为了实现 快速 热更新 打包 的目的 const axios = require('axios'); // 在这里使用webpack，作为node的一个模块，而非命令行使用 const webpack = require('webpack'); const path = require('path'); // 第三方fs模块，api同node一致，不过是将内容写进内存 -快速 const MemoryFs = require('memory-fs'); // 静态文件代理 为了publicPath与热更新 const proxy = require('http-proxy-middleware'); const ReactDomServer = require('react-dom/server'); // 服务端wenpack配置文件 const serverConfig = require('../../build/webpack.config.server'); // 使用http请求去读取webpack-dev-server中的模板[所以依赖npm run dev:client 热更新也依赖 :p] const getTemplate = () => { return new Promise((resolve, reject) => { axios .get('http://localhost:8888/public/index.html') .then(res => { resolve(res.data); }) .catch(reject); }); }; // hack 将字符串转为模块 参考：http://www.ruanyifeng.com/blog/2015/05/require.html // 获取module的构造函数 const Module = module.constructor; let serverBundle; const mfs = new MemoryFs(); // 启动webpack compiler serverCompiler = webpack(serverConfig); // webpack提供给我们的配置项，此处将其配置为 通过mfs进行读写（内存） serverCompiler.outputFileSystem = mfs; // 监听entry处的文件是否有变动 若有变动重新打包 serverCompiler.watch({}, (err, stats) => { if (err) throw err; stats = stats.toJson(); // 打印错误和警告信息 stats.errors.forEach(err => { console.error(err); }); stats.warnings.forEach(warn => { console.warn(warn); }); // 打包的文件所在路径 const bundlePath = path.join( serverConfig.output.path, serverConfig.output.filename ); // 获取打包完成的js文件（注：文件是在内存中而非硬盘中，类比webpack-dev-server的文件） // 此时获得的是字符串，并非可执行的js，我们需要进行转换 const bundle = mfs.readFileSync(bundlePath, 'utf-8'); // 创建一个空模块 const m = new Module(); // 编译字符串 要指定名字 m._compile(bundle, 'server-entry.js'); // 暴露出去 .default : require => es6 module serverBundle = m.exports.default; }); module.exports = function(app) { // 将 `/public` 的请求全部代理到webpack-dev-server启动的服务 思考 express.static为啥不能用 // 我们要借用webpack-dev=server的热更新 热更新就不是服务端渲染了 就第一次是 app.use('/public', proxy({ target: 'http://localhost:8888' })); app.get('*', function(req, res) { getTemplate().then(template => { const content = ReactDomServer.renderToString(serverBundle); res.send(template.replace('&lt;!-- app -->', content)); }); }); }; 这样服务端的一个基础环境就搭建好了。","tags":[{"name":"React","slug":"React","permalink":"http://coder.liusixin.cn/tags/React/"}]},{"title":"前端本地文件操作与上传","date":"2018-02-03T16:38:10.000Z","path":"posts/31d18908/","text":"前言前端无法像原生 APP 一样直接操作本地文件，需要通过用户触发， 用户可通过以下三种方式操作触发： 通过 input type=&quot;file&quot; 选择本地文件 通过拖拽的方式把文件拖过来 在编辑框里面复制粘贴 实践input[type=”file”] 方式第一种是最常用的手段， 通常还会自定义一个按钮，然后盖在它上面，因为 type=&quot;file&quot; 的 input 不容易改变样式。 &lt;form> &lt;input type=\"file\" id=\"file-input\" name=\"fileContent\"> &lt;/form> 用 FormData 获取整个表单的内容 $('#file-input').on('change', function() { console.log(`file name is ${this.value}`); let formData = new FormData(this.form); formData.append('fileName', this.value); console.log(formData); }); 把 input 的 value 和 formData 打印出来是这样的 可以看到文件路径不是真实的路径，浏览器无法获取到文件的真实存放位置。同时 FormData 打印出来是一个空的 Object, 但并不是说它的内容是空的，只是它对前端是透明的，无法查看、修改、删除里面的内容，只能 append 添加字段。 FormData 无法得到文件的内容， 而使用 FileReader 可以读取整个文件的内容。 用户选择文件之后， input.files 就可以得到用户选中的文件 $('#file-input').on('change', function() { const fileReader = new FileReader(); const fileType = this.files[0].type; fileReader.onload = function() { if (/^image/.test(fileType)) { // 读取结果在fileReader.result里面 $(`&lt;img src=\"${this.result}\">`).appendTo('body'); } }; // 打印原始File对象 console.log(this.files[0]); // base64方式读取 fileReader.readAsDataURL(this.files[0]); }); 它是一个 window.File 的实例，包含了文件修改时间、文件名、文件大小、文件的 mime 类型等。如果需要限制上传文件的大小就可以通过判断 size 属性是否超出范围，单位是字节，判断是否为图片文件就可以通过 type 类型是否以 image 开头。上面使用了一个正则判断，但是 Web 不是所有的图片都能通过 img 标签展示出来， 通常是 jpg/jpeg/png/gif 这四种，我们优化一下代码: /^image\\/[jpeg|jpg|png|gif]/.test(this.type); 然后实例化一个 FileReader, 调用它的 readAsDataURL并把 File 对象传给它， 监听它的 onload 事件，load 完读取的结果就在它的 result 属性里了。它是一个 base64 格式的， 可直接赋值给一个 img 的 src。 使用 FileReader 除了可读取为 base64 之外，还能读取为以下格式 // 按base64的方式读取，结果是base64, 任何文件都可转成base64的形式 fileReader.readAsDataURL(this.files[0]); // 以二进制字符串方式读取，结果是二进制内容的utf-8形式，巳被废弃了 fileReader.readAsBinaryString(this.files[0]); // 以原始二进制方式读取，读取结杲可直接转成整数数组 fileReader.readAsArrayBuffer(this.files[0]); 其他的主要是能读取为 ArrayBuffer, 它是一个原始二进制格式的结果。把 ArrayBuffer 打印出来是这样的 可以看到，它对前端人员也是透明的，不能够直接读取里面的内容， 但可以通过ArrayBuffer.length 得到长度，还能转成整型数组，从而知道文件的原始二进制内容 let buffer = fileReader.result; // 依次每字节8位读取， 放到一个整数数组 let view = new Uint8Array(buffer); console.log(view); 通过拖拽的方式&lt;div class=\"img-container\"> drop your image here &lt;/div> 然后监听它的拖拽事件 $('.img-container') .on('dragover', function(event) { event.preventDefault(); }) .on('drop', function(event) { event.preventDefault(); const fileReader = new FileReader(); //数据在event的dataTransfer对象里 let file = event.originalEvent.dataTransfer.files[0]; //然后就可以使用FileReader进行操作 fileReader.readAsDataURL(file); console.log(fileReader); //或者是添加到一个FormData let formData = new FormData(); formData.append('fileContent', file); console.log(formData); }); 数据在 drop 事件的 event.dataTransfer.files 里面， 拿到这个 File 对象之后就可以和输入框进行一样的操作了，即使用 FileReader 读取，或者是新建一个空的 formData, 然后把它 append 到 formData 里面。 粘贴的方式通常是在一个编辑框里操作，如把 div 的 contenteditable设置为 true &lt;div id=\"editor\" contenteditable=\"true\"> hello, paste your image here &lt;/div> 粘贴的数据是在 event.clipboardData.files 里面 $('#editor').on('paste', function(event) { let file = event.originalEvent.clipboardData.files[0]; }); 但是 Safari 的粘贴不是通过 event 传递的，而是直接在输入框里面添加一张图片，它新建了一个 img 标签， 并把 img 的 src 指向一个 blob 的本地数据。什么是 blob 呢，如何读取 blob 的内容呢？ blob 是一种类文件的存储格式 (Blob 派生了 File), 它可以存储几乎任何格式的内容 let data = { hello: 'world' }; let blob = new Blob([JSON.stringify(data)], { type: 'application/json' }); 为了获取本地的 blob 数据，我们可以用 ajax 发个本地的请求： $('#editor').on('paste', function(event) { // 需要setTimeout 0等图片出来了再处理 setTimeout(() => { let img = $(this).find('img[src ^=\"blob\"]')[0]; console.log(img.src); // 用－个xhr获取blob数据 let xhr = new XMLHttpRequest(); xhr.open('GET', img.src); // 改变mime类型 xhr.responseType = 'blob'; xhr.onload = function() { // response就是一个Blob对象 console.log(this.response); }; xhr.send(); }, 0); }); 这样能得到它的大小和类型，但是具体内容也是不可见的，它有一个 slice 的方法，可用千切割大文件。和 File 一样，可以使用 FileReader 读取它的内容 function readBlob(blobImg) { let fileReader = new FileReader(); fileReader.onload = function() { console.log(this.result); }; fileReader.onerror = function(err) { console.log(err); }; fileReader.readAsDataURL(blobImg); } xhr.onload = function() { // response就是一个Blob对象 readBlob(this.response); console.log(this.response); }; xhr.send(); 除此之外，还能使用 window.URL 读取， 这是一个新的 API, 经常和 Service Worker 配套使用， 因为 Service Worker 里面常常要解析 url。 function readBlob(blobImg) { let urlCreator = window.URL || window.webkitURL; // 得到base64结果 let imageUrl = urlCreator.createObjectURL(this.response); return imageUrl; } 关于 src 使用的是 blob 链接的，除了上面提到的 img 之外， 另外一个很常见的是 video 标签。 这种数据不是直接在本地的，而是通过持续请求视频数据，然后再通过 blob 这个容器媒介添加到 video 里面，它也是通过 URL 的 API 创建的。 let mediaSource = new MediaSource(); video.src = URL.createObjectURL(mediaSource); let sourceBuffer = mediaSource.addSourceBuffer( 'video/mp4; codecs=\"avc1.42E01E,mp4a.40.2\"' ); sourceBuffer.appendBuffer(buf); 上面， 我们使用了三种方式获取文件内容，最后得到： FormData 格式 FileReader 读取得到的 base64 或者 ArrayBuffer 二进制格式 如果直接就是一个 FormData 了， 那么直接用 AJAX 发出去就行了， 不用做任何处理。 let form = document.querySelector('form'); let formData = new FormData(form); formData.append('fileName', 'photo.png'); let xhr = new XMLHttpRequest(); // 假设上传文件的接口叫upload xhr.open('POST', '/upload'); xhr.send(formData); 如果用 jQuery 的话， 要设置两个属性为 false $.ajax({ url: '/upload', type: 'POST', data: formData, processData: false, //不处理数据 contentType: false //不设置内容类型 }); 因为 jQuery 会自动对内容进行转义，并且根据 data 自动设置请求 mime 类型，这里告诉 jQuery 直接用 xhr.send 发出去就行了。 从请求数据结果可以看到它的编码格式是 multipart/form-data, 就是上传文件 form 表单写的 enctype &lt;form enctype=\"multipart/form-data\" method=\"post\"> &lt;input type=\"file\" name=\"fileContent\"> &lt;/form> 如果 xhr.send 是 FormData 类型，它会自动设置 enctype, 如果你用默认表单提交上传文件的话就得在 form 上面设置这个属性，因为上传文件只能使用 POST 的这种编码。 常用的 POST 编码是 application/x-www-form-urlencoded, 它和 GET 一样，发送的数据里面，参数和参数之间使用＆连接 key1=value1&amp;key2=value2 特殊字符做转义，这个数据 POST 是放在请求 body 里的，而 GET 是拼在 url 上面的，如果用 jq 的话，jq 会帮你拼并做转义。 而上传文件用的这种 multipart/form-data, 参数和参数之间是一个相同的字符串隔开的，上面的是使用： -----WebKitFormBoundary72yvM25iSPYZ4a3F 这个字符通常会取得比较长、而且随机，因为要保证正常的内容里面不会出现这个字符串，这样内容的特殊字符就不用做转义了。 请求的 contentType 被浏览器设置成： Content-Type: multipart/form-data; boundary=-----WebKitFormBoundary72yvM25iSPYZ4a3F 后端服务通过这个就知道怎么解析这么一段数据了（通常是使用框架处理，而具体的接口不需要关心应该怎么解析）。 如果读取结果是 ArrayBuffer 的话，也是可以直接用 xhr.send 发送出去，但是一般我们不会直接把一个文件的内容发出去，而是用某个字段名等于文件内容的方式。如果你读取为 ArrayBuffer 再上传的话其实作用不是很大，还不如直接用 formData 添加一个 File 对象的内容，因为上面三种方式都可以拿到 File 对象。如果一开始就是一个 ArrayBuffer 了，那么可以转成 blob 然后再 append 到 FormData 里面。 使用比较多的应该是 base64, 因为前端经常要处理图片，读取为 base64 之后就可以把它画到一个 canvas 里面，然后就可以做一些处理，如压缩、裁剪、旋转等。 最后再用 canvas 导出一个 base64 格式的图片， 那怎么上传 base64 格式的呢？ 第一种是拼一个表单上传的 multipart/form-data 的格式， 再用 xhr.sendAsBinary 发出去 let base64Data = base64Data.replace(/^data:image\\/[^;]+;base64,/, ''); let boundary = '----------boundaryasoifvlkasldvavoadv'; xhr.sendAsBinary( [ // name=data boundary, 'Content一Disposition: form-data; name=\"data\"; filename=\"' + fileName + '\"', 'Content-Type: ' + 'image/' + fileType, '', atob(base64Data), boundary, //name=imageType boundary, 'Content-Disposition: forrn-data; name=\"imageType\"', '', fileType, boundary + '--' ].join('\\r\\n') ); 上面代码使用了 window.atob 的 api, 它可以把 base64 还原成原始内容的字符串表示。 btoa 是把内容转化成 base64 编码，而 atob 是把 base64 还原。在调 atob 之前，需要把表示内容格式的不属千 base64 内容的字符串去掉，即上面代码第一行的 replace 处理。 这样就和使用 formData 类似了，但是由于 sendAsBinary 巳经被 deprecated 了， 所以新代码不建议再使用这种方式。 可以把 base64 转化成 blob, 然后再 append 到一个 formData 里面，下面的函数可以把 base64 转成 blob function b64toBlob(b64Data, contentType, sliceSize) { contentType = contentType || ''; sliceSize = sliceSize || 512; var byteCharacters = atob(b64Data); var byteArrays = []; for (var offset = O; offset &lt; byteCharacters.length; offset += sliceSize) { var slice = byteCharacters.slice(offset, offset + sliceSize); var byteNumbers = new Array(slice.length); for (var i = O; i &lt; slice.length; i++) { byteNumbers[i] = slice.charCodeAt(i); } var byteArray = new Uint8Array(byteNumbers); byteArrays.push(byteArray); } var blob = new Blob(byteArrays, { type: contentType }); return blob; } 然后就可以 append 到 formData 里面 let blob = b64toBlob(b64Data, 'image/png'); let formData = new FormData(); formData.append('fileContent', blob); 这样就不用自己去拼一个 multipart/form-data 的格式数据了。 上面处理和上传文件的 API 可以兼容到 IElO+, 如果要兼容老的浏览器应该怎么办呢？ 可以借助一个 iframe, 原理是默认的 form 表单提交会刷新页面， 或者跳到 target 指定的那个 url, 但是如果把 iframe 的 target 指向一个 iframe, 那么刷新的就是 iframe, 返回结果也会显示在 iframe, 然后获取这个 iframe 的内容就可得到上传接口返回的结果。 let iframe = document.createElement('iframe'); iframe.display = 'none'; iframe.name = 'form-iframe'; document.body.appendChild(iframe); // 改变form的target form.target = 'form-iframe'; iframe.onload = function() { // 获取iframe的内容 即服务返回的数据 let responseText = this.contentDocument.body.textContent || this.contentWindow.document.body.textContent; }; form.submit(); form.submit 会触发表单提交，当请求完成（成功或者失败）之后就会触发 iframe 的 onload 事件，然后在 onload 事件获取返回的数据，如果请求失败，则 iframe 里的内容就为空（可以用这个判断请求有没有成功）。 使用 iframe 没有办法获取上传进度，使用 xhr 可以获取当前上传的进度。 xhr.upload.onprogress = function(event) { if (event.lengthComputable) { // 当前上传进度的百分比 duringCallback((event.loaded / event.total) * lOO); } }; 总结本文列举了 3 种交互方式的读取方式 通过 input 控件在 input.files 可以得到 File 文件对象 通过拖拽的是在 drop 事件的 event.dataTransfer.files 里面 通过粘贴的 paste 事件在 event.clipboardData.files 里面 Safari 是在编辑器里面插入一个 src 指向本地的 img 标签，可以通过发送一个请求加载本地的 blob 数据，然后再通过 FileReader 读取，或者直接 append 到 formData 里面。得到的 File 对象就可以直接添加到 FormData 里面，如果需要先读取 base64 格式做处理的，可以把处理后的 base64 转化为 blob 数据再 append 到 formData 里面。对于老浏览器，可以使用一个 iframe 解决表单提交刷新页面或者跳页的问题。 补充 如果要上传多个文件，只要给 input 加个 multiple 的属性即可。 网盘的断点续传是怎么实现的？ 使用 blob 分割大文件上传 let fileReader = new FileReader(); file = this.files[0]; console.log(`总共发送${file.size}字节`); const ONE_MB = 1024 * 1024; let sendedBytes = O; fileReader.onload = function() { // 发送分割的片段 xhr.open(); xhr.send(this.result); sendedBytes += ONE_MB; if (sendedBytes &lt; file.size) { // File的slice方法继承于Blob let blob = file.slice(sendedBytes, sendedBytes + ONE_MB); fileReader.readAsArrayBuffer(blob); } }; let blob = file.slice(O, ONE_MB); console.log(blob instanceof Blob); //true fileReader.readAsArrayBuffer(blob); 这段代码把一个文件分割成 1MB 的 blob 片段依次上传，如果上传一半突然断了的话下一次再重新上传的时候，服务端会告知上一次已经接收的数据量，我们可以根据后端告知的这些字节数去换算一下需要从哪个 blob 片段开始上传。这样就实现断点续传了。还有一个问题就是怎么知道用户又选了同一个文件呢？或者怎么知道这个文件有没有被它修改过了？可以通过计算文件内容的哈希值作为一个文件的标志。","tags":[{"name":"javascript","slug":"javascript","permalink":"http://coder.liusixin.cn/tags/javascript/"},{"name":"HTML5","slug":"HTML5","permalink":"http://coder.liusixin.cn/tags/HTML5/"}]},{"title":"搭建jenkins+docker+nodejs项目的持续集成","date":"2018-01-24T02:20:27.000Z","path":"posts/2429b53d/","text":"前言 “Docker 是一个为开发者和运维管理员搭建的开放平台软件， 可以在这 个平台上创建、 管理和运行生产应用。 Docker Hub 是一个云端服务， 可以用 它共享应用或自动化工作流。 Docker 能够从组件快速开发应用， 并且可以轻松地创建开发环境、 测试环境和生产环境。” 通俗地说， Docker 是一个开源的应用容器引擎， 可以让开发者打包自 己的应用及依赖包到一个可移植的容器中， 然后发布到任何流行的 Linux 机器上， 也可以实现虚拟化。 Docker 容器完全使用沙箱机制， 独立于硬件、语言、框架、 打包系统， 相互之间不会有任何接口， 几乎没有任何性能开销， 便可以很容易地在机器和数据中心中运行。 最重要的是， 它不依赖于任何语言、 框架或系统。 Docker 的基本命令这里 docker 的安装和启动就不介绍了， 网上有很多教程。 通过 docker images 查看是否安装成功。 常用命令 $ docker -h 1. 获取镜像$ sudo docker pull NAME [:TAG] # 命令示例： $ sudo docker pull centos:latest 2. 启动 Containe 盒子$ sudo docker run [OPTIONS] IMAGE [COMMAND] [ARG...] # 简单示例： $ sudo docker run -t 一i centos /bin/bash 3. 查看镜像列表$ sudo docker images [OPTIONS] [NAME] # 命令示例： $ sudo docker images centos 4. 查看容器列表$ sudo docker ps [OPTIONS] # 查看所有运行中或者停止运行的盒子的命令示例： $ sudo docker ps -a 5. 删除镜像$ sudo docker rmi IMAGE [IMAGE...] # 命令示例： $ sudo docker rmi centos:latest 6. 移除一个或多个容器实例$ sudo docker rm [OPTIONS] CONTAINER [CONTAINER...] # 移除所有未运行的容器的命令示例： $ sudo docker rm sudo docker ps -aq 7. 停止一个正在运行的容器$ sudo docker kill [OPT工ONS] CONTAINER [CONTAINER...] # 命令示例： $ sudo docker kill 026e 8. 重启一个正在运行的容器$ sudo docker restart [OPTIONS] CONTAINER [CONTAINER...] # 命令示例： $ sudo docker restart 026e 9. 启动一个已经停止的容器$ sudo docker start [OPTIONS] CONTAINER [CONTAINER...] # 命令示例： $ sudo docker start 026e 连接 Containernsenter 是一个小的工具， 通过使用 nsenter 可以进入一个已经存在的 Container 中， 尽管这个 Container 没有安装 SSH Server 或者其他类似软件。 nsenter 项目的地址为: https://github.com/jpetazzo/nsenter 通过命令来安装 nsenter $ sudo docker run -v /usr/local/bin:/target jpetazzo/nsenter 我们先要找出需要进入的 Container 的 pid PID=$(docker inspect --format {{.State.Pid}} ) # 命令实例： $ sudo docker inspect --format {{.State.Pid}} bdb6103da992 4904 这里我们得到了 id 为 9479 的 Container 的 pid 号为 7026, 这句话有点拗口，其实我们只需关心 7026 这个 pid 号就可以了。 我们根据刚才获得的 pid 就能顺利进入 Container 的内部了。 $ sudo nsenter --target $PID --mount --uts --ipc --net --pid # 这里我们把$PID替换为 4904 即可 $ sudo nsenter --target 4904 --mount --uts --ipc --net --pid 发布应用我们简单制作一个 Node.js 包含 Express 环境的镜像，通过 pm2 来启动 Web 应用，然后发布到 Docker 云上；我们还会使用 Redis 数据库来暂存用户的访问次数；在 Node.js 应用前端，我们需要放置一个 Nginx 作为反向代理。 首先，我们把需要用到的 Image 镜像统统下载到本地并启动 $ sudo docker pull redis:latest $ sudo docker pull node:latest 在本地创建一个部署 Node.js 应用的目录，然后初始化package.json $ mkdir /var/node/docker_node 在创建我们的应用之前，我们从 node 这个镜像基础上开始制作自己的镜像，这个镜像只是比 node 镜像多了一个 pm2 命令。 $ sudo docker run -i -t node /bin/bash ＃ 进入Container的bash $ npm install pm2 -g $ pm2 -v ＃考虑国内的网络 再装下cnpm更靠谱些 $ npm install cnpm -g --registry=https://registry.npm.taobao.org ＃从Container的bash退出 $ exit 这样我们就成功地在 node 这个镜像的基础上安装了 pm2, 然后把这个 Container 保存为镜像，这样以后要用到带 pm2 的 Node.js 镜像时，只需下载它即可。 首先要登陆下 docker hub，账号自行创建，登录成功之后 ＃查看所有Container, 找到刚才的id $ sudo docker ps -a ＃登录成功之后 把Container提交为Images $ sudo docker commit bdb6103da992 fordreamxkhl/node_pm2 ＃然后查看Images列表 $ sudo docker images node_pm2 ＃把镜像提交到云上 $ sudo docker push fordreamxkhl/node_pm2 这样新的镜像就保存到了 Docker 云上，然后我们把本地的fordreamxkhl/node_pm2 删除，试着从云上下载这个镜像。 $ sudo docker rmi fordreamxkhl/node_pm2 $ sudo docker images fordreamxkhl/node_pm2 ＃会发现是空的，然后我们从云上pull $ sudo docker pull fordreamxkhl/node_pm2 ＃稍等片刻即可下载完毕 接下来我们通过 Redis 镜像启动一个 Redis 的 Container $ sudo docker run --name redis-server -d redis redis-server --appendonly yes 然后编写 Node.js 代码来实现这个计数访问应用的功能。 在 /var/node/docker_node 目录下创建如下package.json文件(这里对依赖包写上版本号是比较稳妥的方式，可以免去因为依赖包升级而造成的应用不稳定的情况) { \"name\": \"docker_node\", \"version\": \"1.0.0\", \"main\": \"app.js\", \"engines\": { \"node\": \">=0.10.0\" }, \"dependencies\": { \"express\": \"^4.10.2\", \"redis\": \"^0.12.1\" } } 然后我们创建 app.js, 启动并监听 8000 端口，同时通过 Redis 记录访问次数 var express = require('express'); var redis = require('redis'); var app = express(); // 从环境变量里读取Redis服务器的ip地址 var redisHost = process.env['REDIS_PORT_6379_TCP_ADDR']; var redisPort = process.env['REDIS_PORT_6379_TCP_PORT']; var reidsClient = redis.createClient(redisPort, redisHost); app.get('/', function(req, res) { console.log('get request'); reidsClient.get('access_count', function(err, countNum) { if (err) { return res.send('get access count error'); } if (!countNum) { countNum = 1; } else { countNum = parseInt(countNum) + 1; } reidsClient.set('access_count', countNum, function(err) { if (err) { return res.send('set access count error'); } res.send(countNum.toString()); }); }); }); app.listen(8000); 我们先启动一个 Container 把依赖包装一下 $ sudo docker run --rm -i -t -v /var/node/docker_node:/var/node/docker_node -w /var/node/docker_node/ fordreamxkhl/node_pm2 npm install -w 表示命令执行的当前工作目录，屏幕会打印依赖包的安装过程，等所有 Node.js 的包安装完成后，这个 Container 会自动退出，然后我们进入 /var/node/docker_node/ 目录， 就可以看到 node_modules 文件夹，说明我们的依赖包安装完毕了。 如果出现 EACCESS 的权限错误，那么可以执行如下命令， 许可 SELinux 的工作状态，不过这只是临时修改，重启系统后会恢复。 su -c \"setenforce 0\" 代码开发完毕，基于刚才我们提交的 fordreamxkhl/node_pm2 镜像，我们要启动一个运行这个程序的 Container, 要求这个 Container 有端口映射、文件挂载，并同时加载 Redis 的那个 Container ＃ 挂载pm2的日志输出 $ mkdir /var/log/pm2 ＃ 使用pm2启动app应用，但是会有问题 $ sudo docker run -d --name \"nodeCountAccess\" -p 8000:8000 -v /var/node/docker_node:/var/node/docker_node -v /var/log/pm2:/root/.pm2/logs/ --link redis-server:redis -w /var/node/docker_node/ fordreamxkhl/node_pm2 pm2 start app.js 但是我们在执行docker ps后会发现这个 Container 并没有启动，因为我们利用 pm2 的守护进程方式启动了应用，所以 Container 会认为进程已经运行结束，所以自已退出了，这时我们让 pm2 以非守护进程的方式运行在 Container 里即可 $ sudo docker run -d --name \"nodeCountAccess\" -p 8000:8000 -v /var/node/docker_node:/var/node/docker_node -v /var/log/pm2:/root/.pm2/logs/ --link redis-server:redis -w /var/node/docker_node/ fordreamxkhl/node_pm2 pm2 start --no-daemon app.js 可以看到nodeCountAccess这个名字的 Container 在运行了， 使用浏览器打开主机的 8000 端口，也能看到访问的计数次数。 接下来开始配置 Nginx 的反向代理 由于使用 Docker 的 Container 的 IP 地址是动态变化的，若我们想 要使用 Nginx 容器来做反向代理，那么配置写起来会比较困难，这里我们就暂不使用 Docker 容器来管理 Nginx 了，而是使用本地 Nginx。 我们修改 nginx 的配置文件 worker_processes 1; events { worker_connections 1024; } http { include mime.types; default_type application/octet-stream; server_names_hash_bucket_size 64; access_log off; sendfile on; keepalive_timeout 65; server { listen 3001; location / { proxy_pass http://127.0.0.1:8000; proxy_redirect default; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection $http_connection; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $http_host; } } } 重启 nginx，然后打开浏览器，输入主机 IP:3001 就可以正常访问我们之前启动的 Node.js 访问计数应用。 Jenkins 的持续集成Jeknins 是一款由 Java 开发的开源软件项目， 旨在提供一个开放易用的软件平台，使持续集成变成可能，它的前身就是大名鼎鼎的 Hundson。Hundson 是收费的商用版本，Jenkins 是它的一个免费开源的分支，所以我们选择使用 Jenkins。 那什么是持续集成呢？以下概念摘自 IBM 团队的定义： “随着软件开发复杂度的不断提高，团队开发成员间如何更好地协同工作以确保软件开发的质量已经慢慢成为开发过程中不可回避的问题，持续集成正是针对这类问题的一种软件开发实践。它倡导团队开发成员必须经常集成他们的工作，甚至每天都可能发生多次集成。而每次的集成都是通过自动化的构建来验证的，包括自动编译、发布和测试，从而尽快发现集成错误，让团队能够更快地开发内聚的软件。” 待续集成的核心价值在于如下几点： 持续集成中的任何一个环节都是自动完成的，无须太多的人工干预，有利千减少重复过程，以节省时间、费用和工作量。 持续集成保障了每个时间点上团队成员提交的代码是能成功集成 的。也就是说，在任何时间点都能第一时间发现软件的集成问题，使任意时间发布可部署的软件成为可能。 持续集成还利于软件本身的发展趋势，这点在需求不明确或者频繁性变更的情景中尤其重要，持续集成的质量能帮助团队进行有效决策，同时建立团队开发产品的信心。 通过 Docker 安装和启动 Jenkins$ docker pull jenkins:latest 拉取镜像之后，我们先创建目录，然后就可以启动 Jenkins 的 Container 了，我们要把 Jenkins 的文件存储地址挂载到主机上，以免 Jenkins 服务器重装或者迁移造成数据丢失。另外，Jenkins 会搭建在内网的服务器上，而非生产服务器，如果外网能直接访问， 那么可能会造成一定的风险。 ＃ 创建本地的Jenkins配置文件目录 $ mkdir /var/jenkins_home $ sudo docker run -d --name myjenkins -p 39001:8080 -v /var/jenkins_home:/var/jenkins_home jenkins 这样我们就顺利启动了 Jenkins 的服务，8080 端口是 Jenkins 的默认监听端口，我们把它映射到了本地主机的 39001 端口，要注意把搭建 Jenkins 服务器的 iptables 关闭，一切顺利的话，我们就可以看到 Jenkins 的欢迎页面了。 配置 Jenkins 并自动化部署 Node.js 项目我们需要对 Jenkins 进行一些简单的配置，才能让它自动化地部署应用。 进入系统管理一&gt;管理插件一&gt;可选插件，安装这些插件 Git Plugin (This plugin integrates GIT with Jenkins) Publish Over SSH (Send build artifacts over SSH) 安装完成后重启 Jenkins, 一般安装完毕后会自动重启，如果自动重启失败，那么可以进入 Jenkins 的目录/restart 下手动重启。 ＃ 进入目录手动重启 http://39.104.124.220:39001/restart 如果可选插件列表为空，那么进入 ＂高级” 选项卡，单击 “立即获取“ 按钮，就可以获取可选插件列表了。 重启完成之后，进入系统管理一&gt;系统设置 来对插件进行简单的设置，增加远程的服务器配置。 填入我们待发布的生产服务器的 IP 地址、SSH 端口及用户名、密码等信息。如果远程服务器是通过 key 来登录的，那么还需要把 key 的存放路径写上。 配置完成之后，我们开始创建一个新的项目。 创建项目名 node_access_count, 选择创建一个自由风格的软件项目，单击”ok”按钮，就进入了此项目的创建页面。 在配置页，我们找到＂源码管理”选项，然后填入 GitHub 上的源码地址。 单击 Add 按钮，添加 GitHub 账号，我们就是通过这个账号来拉取源代码的。 把配置页向下滚动，在 “构建“ 一栏处，单击下拉莱单，选择Execute shell。 发布一个 Node.js 程序由于不需要编译， 所以大致的流程如下。 Jenkins 从代码库(SYN 或 Git)获取最新代码。 本地将所需的代码打包，需要排除一些文件，比如.git 文件等。 把代码包通过 SSH 发送到远程的服务器上。 停止远程服务器的服务，删除远程服务器上的代码，解压缩新的代码包。 通过新的package.json安装依赖包，然后重新启动服务。 从代码库获取最新代码是 Jenkins 自动执行的，每次构建都会去做，所以我们不必去配置，接着我们开始第一步：打包最新代码。我们在文本框中输入如下命令，先删除之前的 tar 包，然后重新打包代码。 rm -rf /var/jenkins_home/jobs/node_access_count/node_access_count.tar.gz tar -zcvf /tmp/node_access_count.tar.gz -C /var/jenkins_home/jobs/node_access_count/workspace/docker—node . --exclude=\"*.git\" mv /tmp/node_access_count.tar.gz /var/jenkins_home/jobs/node_access_count/workspace/ 然后我们需要把代码包发送到远程的生产服务器上，这时需要选择 Send files.. 选项。 在Source files一行中，填写我们要发送到远程服务器的文件，我们把刚才打包的文件名node_access_count.tar.gz填入，这里的工作路径是本项目下的 workspace, 在这里是 /var/jenkins_home/jobs/node_access_count/workspace/。 在Remote directory一行中， 填写发送代码包的远程保存地址，我们在这里写入 var/, 我们创建这台服务器时填入的远程默认地址是 &quot;/&quot;, 所以我们发送到这台服务器上的代码包node_access_count.tar.gz会被保存在/var/node_access_count.tar.gz路径下。 接下来先把旧的代码删除，然后解压缩新的代码，并安装依赖包和重启服务，我们在Exec command一栏中填入如下命令。 docker rm -f nodeCountAccess mkdir /var/node mkdir /var/node/docker_node mkdir /var/log/pm2 rm -rf /var/node/docker_node/app.js rm -rf /var/node/docker_node/package.json tar -xvf /var/node_access_count.tar.gz -C /var/node/docker_node docker run --rm -v /var/node/docker_node:/var/node/docker_node -w /var/node/docker_node/ fordreamxkhl/node_pm2 npm install docker run -d --name \"nodeCountAccess\" -p 8000:8000 -v /var/node/docker_node:/var/node/docker_node -v /var/log/pm2:/root/.pm2/logs/ --link redis-server:redis -w /var/node/docker_node/fordreamxkhl/node_pm2 pm2 start --no-daemon app.js rm -rf /var/node_access_count.tar.gz docker rm -f nodeCountAccess: 我们会强制删除之前运行的一个 Container, 第一次发布时会触发一个“没有这个Container&quot;的错误，不用管它。 两个rm操作则是删除原来项目的源代码，但是保留node_modules文件夹，免去了我们只改代码，重复去获取依赖包而导致发布程序时间过长的问题。 mkdir /var/node/docker_node, 第一次启动会自动创建目录，如果已经存在，则不用管。 tar 表示把源码解压缩到指定目录。 两个docker run... 先是执行 npm install 安装依赖包，然后将整个应用启动起来，注意这里我们启动的这个命令不要带上 -i -t参数，否则 Jenkins 命令是无法退出的，直到超时报错。 最后执行删除发送过来的代码包的操作。 如果服务器在国内，那么我们需要将Exec timeout (ms)设置得长一些，这样在 Git 操作和 npm 操作时便不会因为超时而报错。 至此，我们的项目配置完毕，这时我们可以点击 “立即构建” 按钮，就可以看到构建历史中小球在闪烁并构建进度条。如果构建出错，那么构建历史中就会有红色小球出现，成功的话就是蓝色小球，黄色小球表示构建时虽然有错误，但最终还是成功的，不过这也是我们需要注意的。 参考文献 https://www.docker.com/whatisdocker http://www.cbinews.com/software/news/2015-01-20/228094.htm https://www.ibm.com/developerworks/cn/java/j-lo-jenkins/","tags":[{"name":"工程化","slug":"工程化","permalink":"http://coder.liusixin.cn/tags/工程化/"},{"name":"Nodejs","slug":"Nodejs","permalink":"http://coder.liusixin.cn/tags/Nodejs/"},{"name":"Docker","slug":"Docker","permalink":"http://coder.liusixin.cn/tags/Docker/"},{"name":"持续集成","slug":"持续集成","permalink":"http://coder.liusixin.cn/tags/持续集成/"}]},{"title":"Javascript 原型与原型链浅析","date":"2018-01-17T11:06:18.000Z","path":"posts/84b9f49b/","text":"关于这个知识点以前也有写过，这次拿出来专门写一篇加深下记忆 原型与原型链原型其实就是一个对象，其他的对象可以通过它来实现属性的继承。而且，任何一个对象，都可以成为原型。而且所有的对象，默认情况下都有一个原型。 毕竟原型本身也就是对象，所以每一个原型自身也有其自身的原型。出了一个例外，那就是原型链的顶端–null。 一个对象的真正原型是被对象内部[[Prototype]]所持有，ECMA 引入了标准对象原型访问器，Object.getPropertyOf(object) var proto = {}; var obj = Object.create(proto); Object.getPrototypeOf(obj) === proto; // true 当然，我们也可以通过非标准的访问器__proto__来获取实例的原型。 原型的真正魅力在于多个实例之间公用一个通用原型的时候，原型对象的属性一旦被定义，就可以被多个引用他的实例所继承。这种操作在性能和维护方面的意义也是不言而喻的。 不使用原型的例子var decimalDigits = 2, tax = 5; function add(x, y) { return x + y; } function subtract(x, y) { return x - y; } //alert(add(1, 3)); 原型使用方式一var Calculator = function(decimalDigits, tax) { this.decimalDigits = decimalDigits; this.tax = tax; }; Calculator.prototype = { add: function(x, y) { return x + y; }, subtract: function(x, y) { return x - y; } }; //alert((new Calculator()).add(1, 3)); 原型使用方式二Calculator.prototype = (function() { add = function(x, y) { return x + y; }; subtract = function(x, y) { return x - y; }; return { add: add, subtract: subtract }; })(); //alert((new Calculator()).add(11, 3)); 很明显方式二的写法更好一点，因为它封装了 function，通过 return 形式暴露出简单的使用名称，达到了 private/public 的效果 当然，我们也可以分步声明,可以像给对象添加属性的方式那样来添加原型上的方法 var BaseCalculator = function() { //为每个实例都声明一个小数位数 this.decimalDigits = 2; }; //使用原型给BaseCalculator扩展2个对象方法 BaseCalculator.prototype.add = function(x, y) { return x + y; }; BaseCalculator.prototype.subtract = function(x, y) { return x - y; }; 重写原型在使用第三方 JS 类库的时候，往往有时候他们定义的原型方法是不能满足我们的需要，但是又离不开这个类库，所以这时候我们就需要重写他们的原型中的一个或者多个属性或 function，我们可以通过继续声明的同样的 add 代码的形式来达到覆盖重写前面的 add 功能，代码如下： //覆盖前面Calculator的add() function Calculator.prototype.add = function(x, y) { return x + y + this.tax; }; var calc = new Calculator(); alert(calc.add(1, 1)); 但是有一点需要注意：那就是重写的代码需要放在最后，这样才能覆盖前面的代码。 原型链function Foo() { this.value = [1, 2, 4]; } Foo.prototype = { method: function() {} }; function Bar() {} // 设置Bar的prototype属性为Foo的实例对象 Bar.prototype = new Foo(); Bar.prototype.foo = 'Hello World'; // 修正Bar.prototype.constructor为Bar本身 Bar.prototype.constructor = Bar; var test = new Bar() // 创建Bar的一个新实例 // 原型链 test[Bar的实例] Bar.prototype[Foo的实例] { foo: 'Hello World' } Foo.prototype { method: ... }; Object.prototype { toString: ... /* etc. */ }; 上面的例子中，test 对象从 Bar.prototype 和 Foo.prototype 继承下来；因此，它能访问 Foo 的原型方法 method。同时，它也能够访问那个定义在原型上的 Foo 实例属性 value。需要注意的是 new Bar() 不会创造出一个新的 Foo 实例，而是重复使用它原型上的那个实例；因此，所有的 Bar 实例都会共享相同的 value 属性。 hasOwnPropertyhasOwnProperty 是 Object.prototype 的一个方法，它能判断一个对象是否包含自定义属性而不是原型链上的属性，因为 hasOwnProperty 是 JavaScript 中唯一一个处理属性但是不查找原型链的函数。 // 修改Object.prototype Object.prototype.bar = 1; var foo = { goo: undefined }; foo.bar; // 1 'bar' in foo; // true foo.hasOwnProperty('bar'); // false foo.hasOwnProperty('goo'); // true 只有 hasOwnProperty 可以给出正确和期望的结果，这在遍历对象的属性时会很有用。 没有其它方法可以用来排除原型链上的属性，而不是定义在对象自身上的属性。 但有个恶心的地方是：JavaScript 不会保护 hasOwnProperty 被非法占用，因此如果一个对象碰巧存在这个属性，就需要使用外部的 hasOwnProperty 函数来获取正确的结果。 var foo = { hasOwnProperty: function() { return false; }, bar: 'Here be dragons' }; foo.hasOwnProperty('bar'); // 总是返回 false // 使用{}对象的 hasOwnProperty，并将其上下为设置为foo {}.hasOwnProperty.call(foo, 'bar'); // true 当检查对象上某个属性是否存在时，hasOwnProperty 是唯一可用的方法。同时在使用 for in loop 遍历对象时，推荐总是使用 hasOwnProperty 方法，这将会避免原型对象扩展带来的干扰。","tags":[{"name":"javascript","slug":"javascript","permalink":"http://coder.liusixin.cn/tags/javascript/"}]},{"title":"你不知道的Javascript--this指针","date":"2018-01-10T13:50:04.000Z","path":"posts/9853017/","text":"阅读 你不知道的 JavaScript 上卷 整理的关于 this 问题的总结 前言this 关键字是 JavaScript 中最复杂的机制之一，它不是一个特殊的关键字，被自动定义在所有的函数作用域中。 来看一个例子 function identify() { console.log(this.name); return this.name.toUpperCase(); } function speak() { var gretting = 'Hello I am ' + identify.call(this); console.log(gretting); } var me = { name: 'Liusixin' }; var you = { name: 'xinxin' }; identify.call(me); identify.call(you); speak.call(me); speak.call(you); 运行结果如下 关于 this 的误解this 值得是它自己通常人们都会认为 this 就是指向函数本身，至于为什么在函数中引用他自己呢，可能就是因为递归这种情况的存在吧。但是这里，我想说，this 并不是指向函数本身的 function foo(num) { console.log('foo:' + num); this.count++; } foo.count = 0; for (var i = 0; i &lt; 10; i++) { foo(i); } console.log(foo.count); 通过运行上面的代码我们可以看到，foo 函数的确是被调用了十次，但是 this.count 似乎并没有加到 foo.count 上。也就是说，函数中的 this.count 并不是 foo.count。 所以，这里我们一定要记住一个，就是函数中的 this 并不是指向函数本身的。上面的代码修改如下： function foo(num) { console.log('foo:' + num); this.count++; } foo.count = 0; for (var i = 0; i &lt; 10; i++) { foo.call(foo, i); } console.log(foo.count); 运行如上代码，此时我们就可以看到 foo 函数中的 count 的确已经变成 10 了 this 值得是他的作用域另一种对 this 的误解是它不知怎么指向函数的作用域，其实从某种意义上来说他是正确的，但是从另一种意义上来说，这的确是一种误解。 明确的说，this 不会以任何方式指向函数的词法作用域，作用域好像是一个将所有可用标识符作为属性的对象，这从内部来说他是对的，但是 JavaScript 代码不能访问这个作用域“对象”，因为它是引擎内部的实现。 function foo() { var a = 2; this.bar(); } function bar() { console.log(this.a); } foo(); // undefined 首先，this.bar()访问 bar 函数，的确他做到了。虽然只是碰巧而已。然而，写下这段代码的开发者试图使用 this 在 foo 和 bar 的词法作用域中建立一座桥，是的 bar 可以访问 foo 内部变量作用域 a。当然，这是不可能的，不可能使用 this 引用在词法作用域中查找东西。 什么是 this记住，this 不是在编写时候绑定的，而是在运行时绑定的上下文执行环境。this 绑定和函数声明无关，反而和函数被调用的方式有关系。 当一个函数被调用的时候，会建立一个活动记录，也成为执行环境。这个记录包含函数是从何处（call-stack）被调用的，函数是 如何 被调用的，被传递了什么参数等信息。这个记录的属性之一，就是在函数执行期间将被使用的 this 引用。 彻底明白 this 到底指向谁调用点为了彻底弄明白 this 的指向问题，我们还必须明白什么是调用点，即一个函数被调用的位置。考虑调用栈（即使我们到达当前执行位置而被调用的所有方法堆栈）是非常重要的，我们关心的调用点就是当前执行函数的之前的调用 function baz() { // 调用栈是: `baz` // 我们的调用点是global scope（全局作用域） console.log('baz'); bar(); // &lt;-- `bar`的调用点 } function bar() { // 调用栈是: `baz` -> `bar` // 我们的调用点位于`baz` console.log('bar'); foo(); // &lt;-- `foo`的call-site } function foo() { // 调用栈是: `baz` -> `bar` -> `foo` // 我们的调用点位于`bar` console.log('foo'); } baz(); // &lt;-- `baz`的调用点 来点规则，有规可寻我们必须考察调用点，来判断下面即将要说的四中规则哪一种适用。先独立解释下四中规则的每一种，然后再来说明下如果多种规则适用调用点时他们的优先级。 默认绑定 所谓的默认绑定，就是独立函数的调用形式。 function foo() { console.log(this.a); } var a = 2; foo(); // 2 为什么会是 2 呢，因为在调用 foo 的时候，JavaScript 对 this 实施了默认绑定，所以 this 就指向了全局对象。 我们怎么知道这里适用 默认绑定 ？我们考察调用点来看看 foo()是如何被调用的。在我们的代码段中，foo()是被一个直白的，毫无修饰的函数引用调用的。没有其他的我们将要展示的规则适用于这里，所以 默认绑定 在这里适用。 需要注意的是，对于严格模式来说，默认绑定全局对象是不合法的，this 被置为 undefined。但是一个很微妙的事情是，即便是所有的 this 绑定规则都是基于调用点的，如果 foo 的内容没有严格模式下，默认绑定也是合法的。 隐含绑定 调用点是否有一个环境对象，也成为拥有者和容器对象。 function foo() { console.log(this.a); } var obj = { a: 2, foo: foo }; obj.foo(); // 2 foo 被声明，然后被 obj 添加到其属性上，无论foo()是否一开始就在 obj 上被声明，还是后来作为引用添加（如上面代码所示），都是这个 函数 被 obj 所“拥有”或“包含”。 这里需要注意的是，只有对象属性引用链的最后一层才影响调用点 function foo() { console.log(this.a); } var obj2 = { a: 42, foo: foo }; var obj1 = { a: 2, obj2: obj2 }; obj1.obj2.foo(); // 42 隐含绑定丢死 this 绑定最让人头疼的地方就是隐含绑定丢失了他的绑定，其实明确了调用位置，这个也不是难点。直接看代码 function foo() { console.log(this.a); } var obj = { a: 2, foo: foo }; var bar = obj.foo; // 函数引用！ var a = 'oops, global'; // `a`也是一个全局对象的属性 bar(); // \"oops, global\" 所以如上的调用模式，我们又退回到了默认绑定模式。 接着看 function foo() { console.log(this.a); } function doFoo(fn) { // `fn` 只不过`foo`的另一个引用 fn(); // &lt;-- 调用点! } var obj = { a: 2, foo: foo }; var a = 'oops, global'; // `a`也是一个全局对象的属性 doFoo(obj.foo); // \"oops, global\" 参数传递，仅仅是一种隐含的赋值，而且因为我们是传递一个函数，他是一个隐含的引用赋值，所以最终结果和我们前一段代码一样。 所以，在回调函数中丢失 this 绑定是一件很常见的事情，但是还有另一种情况，接受我们回调的函数故意改变 this 的值。那些很受欢迎的事件处理 JavaScript 包就十分喜欢强制你的回调的 this 指向触发事件的 DOM 元素。 不管哪一种意外改变 this 的方式，你都不能真正地控制你的回调函数引用将如何被执行，所以你（还）没有办法控制调用点给你一个故意的绑定。我们很快就会看到一个方法，通过 固定 this 来解决这个问题。 如上，我们一定要清除的是引用和调用。记住，找 this，我们只看调用，别被引用所迷惑 明确绑定 在 JavaScript 中，我们可以强制制定一个函数在运行时候的 this 值。是的，call 和 apply，他们的作用就是扩充函数赖以生存的作用域。 function foo() { console.log(this.a); } var obj = { a: 2 }; foo.call(obj); // 2 上面代码，我们使用 foo，强制将 foo 的 this 指定为 obj 如果你传递一个简单原始类型值（string，boolean，或 number 类型）作为 this 绑定，那么这个原始类型值会被包装在它的对象类型中（分别是 new String(..)，new Boolean(..)，或 new Number(..)）。这通常称为“boxing（封箱）”。 但是，单独的依靠明确绑定仍然不能为我们先前提到的问题，提供很好的解决方案，也就是函数丢失自己原本的 this 绑定。 硬性绑定 function foo() { console.log(this.a); } var obj = { a: 2 }; var bar = function() { foo.call(obj); }; bar(); // 2 setTimeout(bar, 100); // 2 // `bar`将`foo`的`this`硬绑定到`obj` // 所以它不可以被覆盖 bar.call(window); // 2 我们创建了一个函数bar()，在它的内部手动调用foo.call(obj)，由此强制 this 绑定到 obj 并调用 foo。无论你过后怎样调用函数 bar，它总是手动使用 obj 调用 foo。这种绑定即明确又坚定，所以我们称之为 硬绑定（hard binding） new 绑定 这个比较简单，当函数前面加入 new 关键字调用的时候，其实就是当做构造函数调用的。其内部其实完成了如下事情： 一个新的对象会被创建 这个新创建的对象会被接入原型链 这个新创建的对象会被设置为函数调用的 this 绑定 除非函数返回一个他自己的其他对象，这个被 new 调用的函数将自动返回一个新创建的对象 总结 函数是否在 new 中调用，如果是的话 this 绑定的是新创建的对象 var bar = new Foo(); 函数是否通过 call、apply 或者其他硬性调用，如果是的话，this 绑定的是指定的对象 var bar = foo.call(obj); 函数是否在某一个上下文对象中调用,如果是的话，this 绑定的是那个上下文对象 var bar = obj.foo(); 如果都不是的话，使用默认绑定，如果在严格模式下，就绑定到 undefined，注意这里是方法里面的严格声明。否则绑定到全局对象 var bar = foo(); 绑定例外第一种情况就是将 null 和 undefined 传给 call、apply、bind 等函数，然后此时 this 采用的绑定规则是默认绑定 第二种情况这里举个例子，也是面试中常常会出现的例子 function foo() { console.log(this.a); } var a = 2; var o = { a: 3, foo: foo }; var p = { a: 4 }; (p.foo = o.foo)(); // 2 如上调用，其实 foo 采用的也是默认绑定，这里我们需要知道的是，p.foo = o.foo 的返回值是目标函数的引用，所以最后一句其实就是 foo() es6 中的箭头函数es6 中的箭头函数比较简单，由于箭头函数并不是 function 关键字定义的，所以箭头函数不适用 this 的这四中规则，而是根据外层函数或者全局作用域来决定 this function foo() { // 返回一个arrow function return a => { // 这里的`this`是词法上从`foo()`采用 console.log(this.a); }; } var obj1 = { a: 2 }; var obj2 = { a: 3 }; var bar = foo.call(obj1); bar.call(obj2); // 2 这里 foo 内部创建的箭头函数会自动获取 foo 的 this。 经典面试题如果能把这两个题搞清楚的话，可以说所有的关于 this 指向的问题都难不倒你了，go on！ 第一题 var a = 10; var foo = { a: 20, bar: function() { var a = 30; console.log(this); return this.a; } }; foo.bar(); foo.bar(); (foo.bar = foo.bar)(); (foo.bar, foo.bar)(); 这个题的答案是怎么分析的呢: 第一个不多说了 第二个也不多做解释，引用没有变 第三个需要解释一下，经过赋值，运算符运算后，都是纯粹的函数，不是对象方法的引用。所以函数指向的 this 都是 windows 的 第四个，首先要清楚逗号表示什么，一张图说明一切 答案：20 20 10 10 第二题 var number = 2; var obj = { number: 4, /*匿名函数自调*/ fn1: (function() { var number; this.number *= 2; number = number * 2; number = 3; return function() { var num = this.number; this.number *= 2; console.log(num); number *= 3; alert(number); }; })(), db2: function() { this.number *= 2; } }; var fn1 = obj.fn1; alert(number); fn1(); obj.fn1(); alert(window.number); alert(obj.number); 这个题目有点长，解释这个题，我们需要分步骤去理解它，我们先给题目做个标注 var number = 2; var obj = { number: 4, fn1: (function() { // 匿名函数1 var number; this.number *= 2; // (1) number = number * 2; // (2) number = 3; return function() { // 匿名函数(2) var num = this.number; this.number *= 2; console.log(num); number *= 3; alert(number); }; })(), db2: function() { this.number *= 2; } }; var fn1 = obj.fn1; // (3) alert(number); // (4) fn1(); // (5) obj.fn1(); // (6) alert(window.number); alert(obj.number); 当定义obj的时候执行了匿名函数1，此时处于全局作用域内，因此上下文 this 是 window。执行完语句(1)导致全局变量number的值变为 4；执行语句(2)时临时变量number还没有被赋值，所以是 NaN，但下一句会将其赋值为 3；最后，匿名函数1返回了匿名函数2，因此obj.fn1=匿名函数2。（注意匿名函数 2 里面会用到临时变量number） 来到语句(3)，这句会把fn1这个变量赋值为obj.fn1，也就是匿名函数2 由于全局变量number已经在语句(1)中变为了 4，所以语句(4)弹出的对话框结果为 4 语句(5)执行的是fn1()，它与执行obj.fn1()的区别是两者 this 不一样。前者为 null，而后者 this 为 obj。但是又由于 JS 规定，this 为 null 时相当于全局对象 window，所以这句代码执行时函数的 this 为 window。在匿名函数2里会将全局变量number更新为 8，同时将匿名函数 1 中被闭包的临时变量number更新为 9 语句(6)的效果在上面已经分析过了，this 是 obj，所以obj.number更新为 8，闭包的number更新为 27 答案：弹出 4 9 27 8 8","tags":[{"name":"javascript","slug":"javascript","permalink":"http://coder.liusixin.cn/tags/javascript/"}]},{"title":"使用canvas制作粒子效果全屏背景","date":"2018-01-05T13:38:18.000Z","path":"posts/efd83ca1/","text":"前言要制作一个可以作为背景的特效，那么首要的条件就是这是全屏的背景，充满整个屏幕。 为了使背景贴合好看，一般来说都是纯色或者渐变的。 渐变背景网站 uigradients 这个网站可以自己生成渐变色，你的配色也可以跟大家分享，可以保存为图片，也可以导出为 CSS 样式。 实现随机粒子粒子特效的特点 数量多 运动 随机 我们来使用 Canvas 实现随机粒子效果。各项参数都是随机生成的。 创建全屏 Canvas首先，我们需要一个全屏的 Canvas 画布。 &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>Title&lt;/title> &lt;style> html, body { margin: 0; overflow: hidden; width: 100%; height: 100%; cursor: none; background: black; } &lt;/style> &lt;/head> &lt;body> &lt;canvas id=\"canvas\">&lt;/canvas> &lt;script> var ctx = document.getElementById('canvas'), content = ctx.getContext('2d'), round = [], WIDTH, HEIGHT; WIDTH = document.documentElement.clientWidth; HEIGHT = document.documentElement.clientHeight; ctx.width = WIDTH; ctx.height = HEIGHT; &lt;/script> &lt;/body> &lt;/html> 我们使用 WIDTH、HEIGHT 两个常量储存屏幕宽度和高度。 设置 Round_item 类在创建了一个全屏的 Canvas 之后，再来创建单个的 Round_item 类。 首先我们 Round_item 类需要有什么参数呢？ 位置随机 透明度随机 半径随机的圆 为了区分不同的圆，我们还应该设置一个唯一的 index 参数。 所以我们需要的参数有： x 坐标 y 坐标 半径 透明度 index 根据上面这些可以得出我们的 Round_item 类： function Round_item(index, x, y) { this.index = index; this.x = x; this.y = y; this.r = Math.random() * 2 + 1; var alpha = (Math.floor(Math.random() * 10) + 1) / 10 / 2; this.color = 'rgba(255,255,255,' + alpha + ')'; } 这里我们使用了构造函数的方式来创建单个的圆，我们还需要一个变量 initRoundPopulation 来设置 round 的个数，然后我们便可以通过 for 循环创建出 initRoundPopulation 个圆。 设置 draw() 方法在设置了单个的 Round_item 类之后，我们还要给每一个 round 设置 draw() 方法，所以我们需要将 draw() 方法设置在 Round_item 的原型中，这样我们创建出来的每一个 Round_item 实例对象都拥有了 draw() 方法。 Round_item.prototype.draw = function() { content.fillStyle = this.color; content.shadowBlur = this.r * 2; content.beginPath(); content.arc(this.x, this.y, this.r, 0, 2 * Math.PI, false); content.closePath(); content.fill(); }; 设置初始化 init() 函数然后我们就需要设置初始化 init() 函数了，在 init() 函数中，我们的主要任务是创建单个的 round，然后使用其 draw() 方法。 function init() { for (var i = 0; i &lt; initRoundPopulation; i++) { round[i] = new Round_item(i, Math.random() * WIDTH, Math.random() * HEIGHT); round[i].draw(); } } 至此，我们已经完成了随机粒子的实现，完整的代码如下： &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>Title&lt;/title> &lt;style> html, body { margin: 0; overflow: hidden; width: 100%; height: 100%; cursor: none; background: black; } &lt;/style> &lt;/head> &lt;body> &lt;canvas id=\"canvas\">&lt;/canvas> &lt;script> var ctx = document.getElementById('canvas'), content = ctx.getContext('2d'), round = [], WIDTH, HEIGHT, initRoundPopulation = 80; WIDTH = document.documentElement.clientWidth; HEIGHT = document.documentElement.clientHeight; ctx.width = WIDTH; ctx.height = HEIGHT; function Round_item(index, x, y) { this.index = index; this.x = x; this.y = y; this.r = Math.random() * 2 + 1; var alpha = (Math.floor(Math.random() * 10) + 1) / 10 / 2; this.color = \"rgba(255,255,255,\" + alpha + \")\"; } Round_item.prototype.draw = function () { content.fillStyle = this.color; content.shadowBlur = this.r * 2; content.beginPath(); content.arc(this.x, this.y, this.r, 0, 2 * Math.PI, false); content.closePath(); content.fill(); }; function init() { for (var i = 0; i &lt; initRoundPopulation; i++) { round[i] = new Round_item(i, Math.random() * WIDTH, Math.random() * HEIGHT); round[i].draw(); } } init(); &lt;/script> &lt;/body> &lt;/html> 让随机粒子运动animate() 函数Canvas 制作动画是一个不断擦除再重绘的过程，我们需要一个 animate() 函数，这个函数的作用是帮助我们形成动画，我们在这个函数中首先需要清除当前屏幕，这里的清除函数用到的是 content.clearRect() 方法。 context.clearRect(x,y,width,height); x：要清除的矩形左上角的 x 坐标 y：要清除的矩形左上角的 y 坐标 width：要清除的矩形的宽度 height：要清除的矩形的高度 需要清除的区域是整个屏幕，所以 content.clearRect() 的参数就是 content.clearRect(0, 0, WIDTH, HEIGHT);，这里我们就用到了之前获取的屏幕宽度和高度的常量：WIDTH 和 HEIGHT。这样我们就将屏幕上的所有内容都清除了。 清除之后需要重新绘制，重新绘制的图形是需要和原图形之间有一定的关系，先让粒子匀速上升，也就是 y 坐标在不断地变化，既然是匀速的，那么也就是在相同的时间位移是相同的。 将粒子位移的变化函数 move() 写在 Round_item 的原型上。 重绘完图形之后，还需要不断地进行清除再重绘。 \b 首先想到的是的 setTimeout() 方法，但是 setTimeout 和 setInterval 有个问题，了解 js 运行机制的应该明白，它们的时间间隔参数实际上只是指定了把动画添加到线程队列中以等待执行的时间。如果队列前面已经加入了其他任务，那动画代码就要等前面的任务完成后再执行。 我们需要使用另外一个函数 —— requestAnimationFrame() 。 window.requestAnimationFrame() 方法告诉浏览器，你希望执行动画，并请求浏览器调用指定的函数在下一次重绘之前更新动画。该方法使用一个回调函数作为参数，这个回调函数会在浏览器重绘之前调用。 requestAnimationFrame 采用系统时间间隔，保持最佳绘制效率，不会因为间隔时间过短，造成过度绘制，增加开销；也不会因为间隔时间太长，使动画卡顿不流畅，让各种网页动画效果能够有一个统一的刷新机制，从而节省系统资源，提高系统性能，改善视觉效果。 所以我们就使用 requestAnimationFrame() 函数递归的调用 animate() 函数来实现动画的效果。 function animate() { content.clearRect(0, 0, WIDTH, HEIGHT); for (var i in round) { round[i].move(); } requestAnimationFrame(animate); } 创建 move() 函数将 move() 方法写在 Round_item 的原型上，这样我们创建的每一个 round 都具有了 move() 方法。 在 move() 方法中，我们只需要改变 round 的 y 坐标即可，并且设置边界条件，当 y 坐标的值小于 -10（也可以是其他负值），代表该 round 已经超出了屏幕，这个时候我们要将其移动到屏幕的最底端，这样才能保证我们创建的粒子数不变，一直是 initRoundPopulation 的值。 这样就是一个粒子在不断地上升，上升到了最顶端再移动到最底端的循环过程，看起来像是有源源不断的粒子，但其实总数是不变的。 在 y 坐标的变化之后，我们还需要使用新的 y 坐标再来重新绘制一下该 round。 Round_item.prototype.move = function () { this.y -= 0.15; if (this.y &lt;= -10) { this.y = HEIGHT + 10; } this.draw(); } 在 init() 中加入 animate()我们想要实现动画的效果，还需要在 init() 中加入 animate() 函数。 完整实现代码: &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>Title&lt;/title> &lt;style> html, body { margin: 0; overflow: hidden; width: 100%; height: 100%; cursor: none; background: black; } &lt;/style> &lt;/head> &lt;body> &lt;canvas id=\"canvas\">&lt;/canvas> &lt;script> var ctx = document.getElementById('canvas'), content = ctx.getContext('2d'), round = [], WIDTH, HEIGHT, initRoundPopulation = 80; WIDTH = document.documentElement.clientWidth; HEIGHT = document.documentElement.clientHeight; ctx.width = WIDTH; ctx.height = HEIGHT; function Round_item(index, x, y) { this.index = index; this.x = x; this.y = y; this.r = Math.random() * 2 + 1; var alpha = (Math.floor(Math.random() * 10) + 1) / 10 / 2; this.color = \"rgba(255,255,255,\" + alpha + \")\"; } Round_item.prototype.draw = function () { content.fillStyle = this.color; content.shadowBlur = this.r * 2; content.beginPath(); content.arc(this.x, this.y, this.r, 0, 2 * Math.PI, false); content.closePath(); content.fill(); }; function animate() { content.clearRect(0, 0, WIDTH, HEIGHT); for (var i in round) { round[i].move(); } requestAnimationFrame(animate) } Round_item.prototype.move = function () { this.y -= 0.15; if (this.y &lt;= -10) { this.y = HEIGHT + 10; } this.draw(); }; function init() { for (var i = 0; i &lt; initRoundPopulation; i++) { round[i] = new Round_item(i, Math.random() * WIDTH, Math.random() * HEIGHT); round[i].draw(); } animate(); } init(); &lt;/script> &lt;/body> &lt;/html>","tags":[{"name":"javascript","slug":"javascript","permalink":"http://coder.liusixin.cn/tags/javascript/"},{"name":"canvas","slug":"canvas","permalink":"http://coder.liusixin.cn/tags/canvas/"},{"name":"CSS","slug":"CSS","permalink":"http://coder.liusixin.cn/tags/CSS/"}]},{"title":"canvas 特效整理","date":"2017-12-28T16:17:34.000Z","path":"posts/3fe3d9b9/","text":"特效网站： https://codepen.io 烟花效果 1 源码网址：烟花效果 1 烟花效果 2 出处：京东一活动源码 源码地址：烟花效果 1 烟花效果 3 源码网址：烟花效果 3 烟花效果 4 源码网址：烟花效果 4 烟花效果 5 源码网址：烟花效果 5 烟花效果 6 源码网址：烟花效果 6 烟花效果 7 源码网址：烟花效果 7 粒子效果 1 源码网址：粒子效果 1","tags":[{"name":"canvas","slug":"canvas","permalink":"http://coder.liusixin.cn/tags/canvas/"}]},{"title":"关于闭包及变量回收问题","date":"2017-12-20T08:38:00.000Z","path":"posts/b709886a/","text":"文章转自 otakustay 的关于闭包及变量回收问题 本文的诞生，源自近期打算做的一个关于 javascript 中的闭包的专题，由于需要解析闭包对垃圾回收的影响，特此针对不同的 javascript 引擎，做了相关的测试。 为了能从本文中得到需要的知识，看本文前，请明确自己知道闭包的概念，并对垃圾回收的常用算法有一定的了解。 问题的提出假设有如下的代码： function outer() { var largeObject = LargeObject.fromSize('100MB'); return function() { console.log('inner'); }; } var inner = outer(); 在这一段代码中，outer函数和inner函数间会形成一个闭包，致使inner函数能够访问到largeObject，但是显然inner并没有访问largeObject，那么在闭包中的largeObject对象是否能被回收呢？ 如果引入更复杂的情况： function outer() { var largeObject = LargeObject.fromSize('100MB'); var anotherLargeObject = LargeObject.fromSize('100MB'); return function() { largeObject.work(); console.log('inner'); }; } var inner = outer(); 首先一个显然的概念是 largeObject肯定不能被回收 ，因为inner确实地需要使用它。但是anotherLargeObject又能不能被回收呢？它将跟随largeObject一起始终存在，还是和largeObject分离，独立地被回收呢？ 测试方法带着这个疑问，对现有的几款现代 javascript 引擎分别进行了测试，参与测试的有： IE8 自带的 JScript.dll IE9 自带的 Chakra Opera 11.60 自带的 Carakan Chrome 16.0.912.63 自带的 V8（3.6.6.11） Firefox 9.0.1 自带的 SpiderMonkey 测试的基本方案是，使用类似以下的代码： function outer() { var largeObject = LargeObject.fromSize('100MB'); return function() { debugger; }; } var inner = outer(); 通过各浏览器的开发者工具（Developer Tools、Firebug、Dragonfly 等），在断点处停止 javascript 的执行，并通过控制台或本地变量查看功能检查largeObject的值，如果其值存在，则认为 GC 并没有回收该对象。 对于部分浏览器（特别是 IE），考虑到对脚本执行有 2 种模式（执行模式和调试模式，IE 通过开发者工具的 Script 面板中的“Start Debugging”按钮切换），在调试模式下才会命中断点，但是调试模式下可能存在不同的引擎优化方案，因此采用内存比对的方式进行测试。即打开资源浏览器，在var inner = outer();一行后强制执行一次垃圾回收（IE 使用window.CollectGarbage()；Opera 使用window.opera.collect();），查看内存的变化。如果内存始终有 100MB 的占用，没有明显的下降现象，则认为 GC 并没有回收该对象。 对于用例的设计，由于从 ECMAScript 标准中可以得知，所有的变量访问是通过一个 LexicalEnvironment 对象进行的，因此目标在于在不同的 LexicalEnvironment 结构下进行测试。从标准中，搜索LexicalEnvironment不难得出能够改变 LexicalEnvironment 结构的情况有以下几种： 进入一个函数。 进入一段 eval 代码。 使用 with 语句。 使用 catch 语句。 因此以下将针对这 4 种情况，进行多用例的测试。 测试过程级结果基本测试使用代码 function outer() { var largeObject = LargeObject.fromSize('100MB'); return function() { debugger; }; } var inner = outer(); inner(); 测试结果 JScript.dll - 不回收，内存无下降趋势。 Chakra - 回收，内存会恢复到outer函数执行前的状态。 Carakan - 不回收，内存无下降趋势。 V8 - 回收，访问largeObject抛出 ReferenceError。 SpiderMonkey - 回收，访问largeObject得到undefined。 结论 当一个函数outer返回另一个函数inner时，Chakra、V8 和 SpiderMonkey 会对outer中声明，但inner中不使用的变量进行回收，其中 V8 直接将变量从 LexicalEnvironment 上解除绑定，而 SpiderMonkey 仅仅将变量的值设为undefined，并不解除绑定。 多个变量的情况使用代码 function outer() { var largeObject = LargeObject.fromSize('100MB'); var anotherLargeObject = LargeObject.fromSize('100MB'); return function() { largeObject; debugger; }; } var inner = outer(); inner(); 测试结果 JScript.dll - 不回收，内存无下降趋势。 Chakra - 回收anotherLargeObject，内存会回到outer调用前并增加 100MB 左右。 Carakan - 不回收，内存无下降趋势。 V8 - 回收，访问largeObject能得到正确的值，访问anotherLargeObject抛出 ReferenceError。 SpiderMonkey - 回收，访问largeObject能得到正确的值，访问anotherLargeObject得到undefined。 结论 当一个 LexicalEnvironment 上存在多个变量绑定时，Chakra、V8 和 SpiderMonkey 会针对不同的变量判断是否有被使用，该判断方法是扫描返回的函数inner的源码来实现的，随后会将没有被inner使用的变量从 LexicalEnvironment 中解除绑定（同样的，SpiderMonkey 不解除绑定，仅赋值为undefined），而剩下的变量继续保留。 eval 的影响使用代码 function outer() { var largeObject = LargeObject.fromSize('100MB'); return function() { eval(''); debugger; }; } var inner = outer(); inner(); 测试结果 JScript.dll - 不回收，内存无下降趋势。 Chakra - 不回收，内存无下降趋势。 Carakan - 不回收，内存无下降趋势。 V8 - 不回收，访问largeObject可得到正确的值。 SpiderMonkey - 不回收，访问largeObject可得到正确的值。 结论 如果返回的inner函数中有使用eval函数，则不 LexicalEnvironment 中的任何变量进行解除绑定的操作，保留所有变量的绑定，以避免产生不可预期的结果。 间接调用 eval使用代码 function outer() { var largeObject = LargeObject.fromSize('100MB'); return function() { window.eval(''); debugger; }; } var inner = outer(); inner(); 测试结果 JScript.dll - 不回收，内存无下降趋势。 Chakra - 回收，内存会恢复到outer函数执行前的状态。 Carakan - 不回收，内存无下降趋势。 V8 - 回收，访问largeObject抛出 ReferenceError。 SpiderMonkey - 回收，访问largeObject得到undefined。 结论 由于 ECMAScript 规定间接调用eval时，代码将在全局作用域下执行，是无法访问到largeObject变量的。因此对于间接调用eval的情况，各 javascript 引擎将按标准的方式进行处理，无视该间接调用eval的存在。 同样的，对于new Function(&#39;return largeObject;&#39;)这种情形，由于标准规定new Function创建的函数的[[Scope]]是全局的 LexicalEnvironment，因此也无法访问到largeObject，所有引擎都参照间接调用eval的方式，选择无视Function构造函数的调用。 多个嵌套函数使用代码 function outer() { var largeObject = LargeObject.fromSize('100MB'); function help() { largeObject; // eval(''); } return function() { debugger; }; } var inner = outer(); inner(); 测试结果 JScript.dll - 不回收，内存无下降趋势。 Chakra - 不回收，内存无下降趋势。 Carakan - 不回收，内存无下降趋势。 V8 - 不回收，访问largeObject可得到正确的值。 SpiderMonkey - 不回收，访问largeObject可得到正确的值。 结论 不仅仅是被返回的inner函数，如果在outer函数中定义的嵌套的help函数中使用了largeObject变量（或直接调用eval），也同样会造成largeObject变量无法回收。因此 javascript 引擎扫描的不仅仅是inner函数的源码，同样扫描了其他所有嵌套函数的源码，以判断是否可以解除某个特定变量的绑定。 使用with表达式使用代码 function outer() { var largeObject = LargeObject.fromSize('100MB'); var scope = { o: LargeObject.fromSize('100MB') }; with (scope) { return function() { debugger; }; } } var inner = outer(); inner(); 测试结果 JScript.dll - 不回收，内存无下降趋势。 Chakra - 回收largeObject，但不回收scope.o，内存恢复至 outer 函数被调用前并增加 100MB 左右（无法得知scope是否被回收）。 Carakan - 不回收，内存无下降趋势。 V8 - 不回收，访问largeObject和scope以及 o 均可得到正确的值。 SpiderMonkey - 回收largeObject和scope，访问该 2 个变量均得到undefined，不回收o，可得到正确的值。 结论 当有with表达式时，V8 将会放弃所有变量的回收，保留 LexicalEnvironment 中所有变量的绑定。而 SpiderMonkey 则会保留由with表达式生成的新的 LexicalEnvironment 中的所有变量的绑定，而对于outer函数生成的 LexicalEnvironment，按标准的方式进行处理，尽可能解除其中的变量绑定。 使用 catch 表达式使用代码 function outer() { var largeObject = LargeObject.fromSize('100MB'); try { throw { o: LargeObject.fromSize('100MB'); } } catch (ex) { return function() { debugger; }; } } var inner = outer(); inner(); 测试结果 JScript.dll – 不回收，内存无下降趋势。 Chakra – 回收largeObject和ex，内存会恢复到outer函数被调用前的状态。 Carakan – 不回收，内存无下降趋势。 V8 – 仅回收largeObject，访问largeObject抛出 ReferenceError，但仍可访问到ex。 SpiderMonkey – 仅回收largeObject，访问largeObject得到undefined，但仍可访问到ex。 结论 catch表达式虽然会增加一个 LexicalEnvironment，但对闭包内变量的绑定解除算法几乎没有影响，这源于catch生成的 LexicalEnvironment 仅仅是追加了被 catch 的 Error 对象一个绑定，是可控的（相对的with则不可控），因此对变量回收的影响也可以控制和优化。但对于新生成并添加了 Error 对象的 LexicalEnvironment，V8 和 SpiderMonkey 均不会进一步优化回收，而 Chakra 则会对该 LexicalEnvironment 进行处理，如果其中的 Error 对象可以回收，则会解除其绑定。 嵌套函数中声明的同名变量使用代码 function outer() { var largeObject = LargeObject.fromSize('100MB'); return function(largeObject /* 或在函数体内声明 */) { // var largeObject; }; } var inner = outer(); inner(); 测试结果 JScript.dll – 不回收，内存无下降趋势。 Chakra – 回收，内存会恢复到outer函数被调用前的状态。 Carakan – 不回收，内存无下降趋势。 V8 – 回收，内存会恢复到outer函数被调用前的状态。 SpiderMonkey – 回收，内存会恢复到outer函数被调用前的状态。 结论 嵌套函数中有与外层函数同名的变量或参数时，不会影响到外层函数中该变量的回收优化。即 javascript 引擎会排除FormalParameterList和所有VariableDeclaration表达式中的Identifier，再扫描所有Identifier来分析变量的可回收性。 总体结论首先一个较为明确的结论是，以下内容会影响到闭包内变量的回收： 嵌套的函数中是否有使用该变量。 嵌套的函数中是否有直接调用eval。 是否使用了with表达式。 Chakra、V8 和 SpiderMonkey 将受以上因素的影响，表现出不尽相同又较为相似的回收策略，而 JScript.dll 和 Carakan 则完全没有这方面的优化，会完整保留整个 LexicalEnvironment 中的所有变量绑定，造成一定的内存消耗。 由于对闭包内变量有回收优化策略的 Chakra、V8 和 SpiderMonkey 引擎的行为较为相似，因此可以总结如下，当返回一个函数fn时： 如果fn的[[Scope]]是 ObjectEnvironment（with表达式生成 ObjectEnvironment，函数和catch表达式生成 DeclarativeEnvironment），则： 如果是 V8 引擎，则退出全过程。 如果是 SpiderMonkey，则处理该 ObjectEnvironment 的外层 LexicalEnvironment。 获取当前 LexicalEnvironment 下的所有类型为 Function 的对象，对于每一个 Function 对象，分析其 FunctionBody： 如果 FunctionBody 中含有直接调用 eval，则退出全过程。 否则得到所有的 Identifier。 对于每一个 Identifier，设其为name，根据查找变量引用的规则，从 LexicalEnvironment 中找出名称为name的绑定binding。 对binding添加notSwap属性，其值为true。 检查当前 LexicalEnvironment 中的每一个变量绑定，如果该绑定有notSwap属性且值为true，则： 如果是 V8 引擎，删除该绑定。 如果是 SpiderMonkey，将该绑定的值设为undefined，将删除notSwap属性。 对于Chakra引擎，暂无法得知是按V8的模式还是按SpiderMonkey的模式进行。 从以上测试及结论来看，V8 确实是一个优秀的 javascript 引擎，在这一方面的优化相当到位。而 SpiderMonkey 则采取一种更为友好的方式，不直接删除变量的绑定，而是将值赋为undefined，也许是 SpiderMonkey 团队考虑到有一些极端特殊的情况，依旧有可能导致使用到该变量，因此保证至少不会抛出 ReferenceError 打断代码的执行。而 IE9 的 Chakra 相比 IE8 的 JScript.dll 进步非常大，细节上的处理也很优秀。Opera 的 Carakan 在这一方面则相对落后，完全没有对闭包内的变量回收进行优化，选择了最为稳妥但略显浪费的方式。 此外，所有带有优化策略的浏览器，都在内在开销和速度之间选择了一个平衡点，这也正是为什么“多个嵌套函数”这一测试用例中，虽然inner没有再使用largeObject对象，甚至在inner中的断点处，连help函数对象也已经解除绑定，却没有解除largeObject的绑定。基于这种现象，可以推测各引擎均只选择检查一层的关联性，即不去处理inner -&gt; help -&gt; largeObject这样深度的引用关系，只找inner -&gt; largeObject和help -&gt; largeObject并做一个合集来处理，以提高效率。也许这种方式依旧存在内存开销的浪费，但同时 CPU 资源也是非常贵重的，如何掌握这之间的平衡，便是 javascript 引擎的选择。 此外，根据部分开发者的测试，Chakra 甚至有资格被称为现有最快速的 javascript 引擎，微软也一直在努力，而开发者更不应该一味地谩骂和嘲笑 IE。我们可以嘲笑 IE6 的落后，可以看不到低版本的 IE 曾经为互联网的发展做过的贡献，可以在这些历史产品已经没落的今天无情地给予打击，却最最不应该将整个 IE 系列一视同仁，挂上“垃圾”的名号。客观地去看待，去评价，正是一个技术人员应该具备的最基本的准则和素养。","tags":[{"name":"javascript","slug":"javascript","permalink":"http://coder.liusixin.cn/tags/javascript/"},{"name":"技术杂谈","slug":"技术杂谈","permalink":"http://coder.liusixin.cn/tags/技术杂谈/"},{"name":"V8","slug":"V8","permalink":"http://coder.liusixin.cn/tags/V8/"}]},{"title":"前端单元测试与自动化测试实践","date":"2017-12-17T14:42:04.000Z","path":"posts/609ebfab/","text":"前言常用的测试框架有 Karma、mocha, 其中 Karma 是一个以浏览器为引擎的测试，而 mocha 用的是 Node.js, 淘宝推出了一个类 Karma 的开源框架叫 Totoro。 由于 Karma 是使用真实的浏览器环境，并且可以测试兼容性，我们采用 Karma 作为框架。 常用的断言库： Node.js 的 assert Jasmine expect Chai 和 Karma 比较配套的是 Jasmine。 安装 Karma + Jasminenpm i karma jasmine-core karma-jasmine karma-chrome-launcher -D npm i karma -g 安装一个全局的 karma 命令，然后执行 karma init 生成 karrna.config.js karma init 一路回车就好 然后新建一个 src 目录写源文件（src/util.js) var util = { reverse(str) { return str .split('') .reverse() .join(''); } }; 然后写测试文件(test/util-test.js) describe('reverse', function() { it('reverse word', function() { expect(util.reverse('abc')).toEqual('cba'); }); }); 接下来把文件添加到 karma.config.js 里面 module.exports = function(config) { config.set({ ... // list of files / patterns to load in the browser files: [ 'test/*.js', 'src/*.js' ], ... }) } 告诉它要在浏览器加载哪些文件，然后运行 karma start 执行测试，如果遇到报 karma 的模块找不到的情况，则可以把找不到的模块安装成全局的。 成功运行后，终端将会输出测试结果 浏览器也会打出结果 我们修改下代码再看下不通过的情况 describe('reverse', function() { it('reverse word', function() { expect(util.reverse('abc')).toEqual('abc'); }); }); 这样就实现了一个最基本的单元测试，现在来看一下测试的覆盖率。 测试覆盖率报告一般测试的覆盖率要越高越好，Karma 支持查看测试代码的覆盖率， 安装一个包： npm install karma-coverage -D 然后在 karma.config.js 里面添加配置 preprocessors: { 'src/*.js': ['coverage'] }, // add coverageReporter: { type: 'html', dir: 'coverage/' }, reporters: ['progress', 'coverage'], 添加一个预处理，告诉它 src 下的源文件需要用 coverage 预处理一下，然后生成的 report 放在 coverage 目录下面，用 HTML 的形式。 重新运行 karma start, 将会生成 HTML 文件，打开这个 HTML 文件就可以看到覆盖率报告。 覆蓝率为 100%, 我们给源 util 添加一个逻辑分支 var util = { reverse(str) { if (str.length &lt;= 1) return str; return str .split('') .reverse() .join(''); } }; 然后再看覆盖率报告 可以看到，分支变成了 50% 再添加一个分支: var util = { reverse(str) { if (typeof str !== 'string') throw 'util.reverse should pass a string argument'; if (str.length &lt;= 1) return str; else return str .split('') .reverse() .join(''); } }; 点进 util 也可以看到哪些代码没有覆盖到: 在 util-test.js 里面添加测试代码 describe('reverse', function() { it('reverse word', function() { expect(util.reverse('abc')).toEqual('cba'); }); it('reverse字符串长度为1时返回自已', function() { expect(util.reverse('a')).toBe('a'); }); it('reverse传值不是字符串时会抛异常', function() { expect(function() { util.reverse(null); }).toThrow(); }); }); 这时候看到覆盖率就成 100%了。 覆盖率实现原理从浏览器加载的 util.js 中可以看到一段代码 可以看到总共被改成了 4 个分支，每个分支如果有执行就会顺带着执行 ＋＋ 操作。这样它就可以统计到有多少代码被执行到了。 Jasmine 提供的断言 API 除了上面 toEqual/toBe/toThrow 之外， 具体还有 expect(result).toBeDefined(); expect(result).toBeGreaterThan(3); expect(result).toBeLessThan(0); expect(thing).toBeNaN(); expect(string).toContain(substring); expect('my string').toMatch(/^my/); 自动化测试自动化测试一般用 E2E 测试，即端到端测试。它的工具也有几种 PhontomJS 无界面浏览器 Senlenium 打开电脑的浏览器运行，支持多语言操控 Protractor 是 Senlenium 的一个 JS 容器 我们使用 Protractor, 因为它提供了－些方便的操控浏览器的 API 以及断言库。 首先安装 protractor: npm i protractor -g webdriver-manager update webdriver-manager start 然后写一个 conf.js exports.config = { seleniumAddress: 'http://localhost:4444/wd/hub', specs: ['test-spec.js'] }; test-spec.js describe('site', function() { it('登录框正常使用', function() { browser.waitForAngularEnabled(false); browser.get('https://test.com'); expect(browser.getTitle()).toEqual('Search Listings in Las Vegas - tes'); $$('nav .sign-icon + li.sign-in').click(); expect($$('.sign-log').count()).toEqual(1); $$('.sign-log input[name=account]').sendKeys('yin@abc.com'); $$('.sign-log input[name=password]').sendKeys('3345983893'); $$('.sign-log input[type=submit]').click(); browser.driver.sleep(1000); expect($$('.sign-log').count()).toEqual(0); }); }); 我们测试登录框能否正常使用，先调 browser.get 打开一个网页，在 load 完成之后会继续执行下面的逻辑：先单击导航的 sign-in 弹出登录框，然后往两个输入框填入账号密码，再点提交按钮，让浏览器等待 1s, 最后检测弹框是否消失了。因为注册完会刷新页面。 然后运行 protractor start, 它就会打开浏览器，自动打开网页，按照我们的设定执行。 总结首先看一下工程目录 - website - karma.config.js - unit-test - index.js - mock - middleware.js - home.js - test - sign-log-test.js - util-test.js - coverage - html/index.html - e2e-test - conf.js - spec - test-login.js 要尽可能地提高覆盖率，并且测试要尽可能稳定，理想状态是多个版本迭代还能待续使用，每次上线前或者改完代码后都可以跑一下单元测试。对一些复杂、关键的操作使用自动化测试。 自动化测试写起来比较简单，就是比较烦琐。","tags":[{"name":"javascript","slug":"javascript","permalink":"http://coder.liusixin.cn/tags/javascript/"},{"name":"测试","slug":"测试","permalink":"http://coder.liusixin.cn/tags/测试/"},{"name":"工程化","slug":"工程化","permalink":"http://coder.liusixin.cn/tags/工程化/"}]},{"title":"用评论消息框讲解状态模式","date":"2017-12-16T03:57:00.000Z","path":"posts/1bc12c23/","text":"前言 要实现一个评论的消息框， 要求是当字数为 0 或者超过 120 的时候，评论按钮不可单击，并且剩余字数会跟着变。 以微博评论框为例: 用一个 state 来保存当前的状态，然后当用户输入的时候，这个 state 的数据会跟着变，同时更新评论按钮的状态。 var commentBox = { init() { // 初始化一个state this.state = {}; commentBox.bindEvent(); }, setState(key, value) { this.state[key] = value; }, changeSubmit() { // 通过获取当前state $(\"#submit\")[0].disabled = commentBox.state.text.length === 0 || commentBox.state.text.length > 120; }, showLeftTextCount() { $(\"#text-count\").text(120 - this.state.text.length); }, bindEvent() { $(\".cmt-textarea\").on('input', function() { // 改变当前state commentBox.setState({\"text\", this.value}); commentBox.changeSubmit(); commentBox.showLeftTextCount(); }) } } 我们再稍加修改，在在上面 setState 的时候， 自动去更新 DOM。 var commentBox = { ... setState(key, value) { this.state[key] = value; commentBox.changeSubmit(); commentBox.showLeftTextCount(); }, ... bindEvent() { $(\".cmt-textarea\").on('input', function() { // 改变当前state commentBox.setState({\"text\", this.value}); }) } } 还可以再做得更智能，状态变的时候自动去比较当前状态所渲染的虚拟 DOM 和真实 DOM 的区别，自动去改变真实 DOM: var commentBox = { setState(key, value) { this.state[key] = value; renderDom($('.comment')); }, renderDom($currentDom) { diffAndChange($currentDom, renderVirtualDom(commentBox.state)); } }; ('&lt;input type=\"submit\" disabled={{this.state.text.length === 0 || this.state.text.length > 140}} />'); 这里其实就是 React 的设计原型，不同的状态有不同的表现行为，所以可以认为是一个状态模式，并且通过状态去驱动 DOM 的更改。","tags":[{"name":"javascript","slug":"javascript","permalink":"http://coder.liusixin.cn/tags/javascript/"},{"name":"设计模式","slug":"设计模式","permalink":"http://coder.liusixin.cn/tags/设计模式/"}]},{"title":"JavaScript设计模式--行为型设计模式","date":"2017-12-10T14:58:42.000Z","path":"posts/ac9a6cb1/","text":"该系列参考自 《JavaScript 设计模式》 以及 汤姆大叔的博文 深入理解 JavaScript 系列 前言 模板方法模式 观察者模式 状态模式 策略模式 职责链模式 命令模式 访问者模式 中介者模式 备忘录模式 迭代器模式 解释器模式 一. 模板方法模式 父类中定义一组算法操作骨架，而将一些实现步骤延伸到子类中，使得子类在不改变父类算法结构的同时可重新定义算法某些实现步骤。 模板方法模式主要由两部分组成： 抽象父类 具体实现子类 演示这里我们直接拿网上最常用的例子来举例说明 Coffee or Tea 把水煮沸 用沸水浸泡茶叶 把茶水倒进杯子 加柠檬 /* 抽象父类：饮料 */ var Beverage = function() {}; // (1) 把水煮沸 Beverage.prototype.boilWater = function() { console.log('把水煮沸'); }; // (2) 沸水浸泡 Beverage.prototype.brew = function() { throw new Error('子类必须重写brew方法'); }; // (3) 倒进杯子 Beverage.prototype.pourInCup = function() { throw new Error('子类必须重写pourInCup方法'); }; // (4) 加调料 Beverage.prototype.addCondiments = function() { throw new Error('子类必须重写addCondiments方法'); }; /* 模板方法 */ Beverage.prototype.init = function() { this.boilWater(); this.brew(); this.pourInCup(); this.addCondiments(); }; /* 实现子类 Coffee*/ var Coffee = function() {}; Coffee.prototype = new Beverage(); // 重写非公有方法 Coffee.prototype.brew = function() { console.log('用沸水冲泡咖啡'); }; Coffee.prototype.pourInCup = function() { console.log('把咖啡倒进杯子'); }; Coffee.prototype.addCondiments = function() { console.log('加牛奶'); }; var coffee = new Coffee(); coffee.init(); 通过模板方法模式，在父类中封装了子类的算法框架。这些算法框架在正常状态下是适用大多数子类的，但也会出现“个性”子类。 如上述流程，加调料是可选的。 钩子方法可以解决这个问题，放置钩子是隔离变化的一种常见手段。 /* 添加钩子方法 */ Beverage.prototype.customerWantsCondiments = function() { return true; }; Beverage.prototype.init = function() { this.boilWater(); this.brew(); this.pourInCup(); if (this.customerWantsCondiments()) { this.addCondiments(); } }; /* 实现子类 Tea*/ var Tea = function() {}; Tea.prototype = new Beverage(); // 重写非公有方法 Tea.prototype.brew = function() { console.log('用沸水冲泡茶'); }; Tea.prototype.pourInCup = function() { console.log('把茶倒进杯子'); }; Tea.prototype.addCondiments = function() { console.log('加牛奶'); }; Tea.prototype.customerWantsCondiments = function() { return window.confirm('需要添加调料吗？'); }; var tea = new Tea(); tea.init(); 二. 观察者模式 又被称为发布订阅模式，或者消息机制。定义了一种依赖关系，解决了主体对象和观察者之间功能的耦合 其实他就是定义了一种一对多的关系，让多个观察者对象同时监听某一个主体对象，这个主体对象的状态发生变化时，就会通知所有的观察者对象，使得他们能够自动更新自己。 观察者对象的好处： 支持简单的广播通信，自动通知所有已经订阅过的对象。 页面载入后目标对象很容易与观察者存在一种动态关联，增加了灵活性。 目标对象与观察者之间的抽象耦合关系能够单独扩展以及重用。 演示js 通过对观察者模式的实现是通过回调函数的方式 我们来先定义一个 pubsub 对象，其内部包含了 3 个方法：订阅、退订、发布 // 创建一个观察者 var Observe = (function() { var _message = {}; return { register: function(type, fn) { //注册信息接口 if (typeof _message[type] === 'undefined') { _message[type] = [fn]; } else { _message[type].push(fn); } }, fire: function(type, args) { //发布消息接口 if (!_message[type]) return; //消息信息 var event = { type: type, args: args || {} }, i = 0, len = _message[type].length; for (; i &lt; len; i++) { //一次执行注册过的方法 _message[type][i].call(this, event); } }, remove: function(type, fn) { //移除消息接口 if (_message[type] instanceof Array) { var i = _message[type].length - 1; for (; i > -0; i--) { _message[type][i] === fn &amp;&amp; _message[type].splice(i, 1); } } } }; })(); Observe.register('test', function(e) { console.log(e.type, e.args.msg); }); Observe.register('test', function(e) { console.log(e.type, 'Liusixin'); }); Observe.fire('test', { msg: 'test test' }); 三. 状态模式 当一个对象内部状态发生变化的时候，会导致起行为变化，看起来就像改变了对象 状态模式定义了一个对象，这个对象可以通过管理其内部状态从而是其行为发生变化。状态模式是一个非常出色的设计模式，主要由两个角色构成 环境类：拥有一个状态成员，可以修改其状态并做出反应 状态类：表示一种状态，包含相应的处理方法 演示一个简单的例子，我们可以将不同的判断结构封装在一个状态对象内，然后该状态对象返回一个可被调用的状态方法，用于调用对象内部某个方法。 var ResultState = (function() { var States = { state0: function() { console.log('这是第一种结果'); }, state1: function() { console.log('这是第二种结果'); }, state2: function() { console.log('这是第三种结果'); }, state3: function() { console.log('这是第四种结果'); } }; //获取某一种状态并执行相应的方法 function show(result) { States['state' + result] &amp;&amp; States['state' + result](); } return { show: show }; })(); ResultState.show(4); 上面代码只是一个雏形，对于状态模式主要目的就是将条件判断的不同结构，转化为状态对象的内部状态，既然是状态对象的内部状态，所以一般是作为状态对象的私有变量，然后提供一个能够调用状态对象内部状态的接口方法对象 四. 策略模式 将定义的一组算法封装起来，使其相互之间可以替代。封装的算法具有一定的独立性，不会随着客户端变化而变化 从结构上看，他和状态模式非常的相似，也是在内部封装一个对象，然后通过返回的借口对象实现对内部对象的调用，不同的是，策略模式不需要管理状态，状态之间没有依赖关系，策略之间可以相互替换，在策略对象内部保存的是一些相对独立的一些算法。 五. 职责链模式 解决请求发送者和接受者之间的耦合，通过职责链上多个对象分解请求流程，实现请求在多个对象之间的传递，直到最后一个对象完成请求的处理。 职责链模式的优点是：请求发送者只需要直到链中的第一个节点，从而解耦了发送者和一组接收者之间的强联系。此外，使用了职责链模式之后，链中的节点对象可以灵活地拆分重组，增加或者删除 一个节点，以及改变节点在链中的位置都是轻而易举的。 职责链模式的缺点是：首先不能保证某个请求一定会被链中的某个节点处理，这种情况系下可以在链尾增加一个保底的接受者节点来处理这种即将离开链尾的请求。其次，职责链模式使得程序中多了一些节点对象，可能在某一次的请求传递过程中，大部分的节点并没有起到实质性的作用，从性能的角度考虑，应当避免过长的职责链带来的性能损耗。 场景假设有这么一种场景：一个售卖手机的电商网站，经过分别交纳 500 元定金和 200 元定金的两轮预订之后（订单在此时已经生成），现在进入了正式购买阶段。 公司针对支付过定金的客户有一定的优惠，正式购买之后，已经支付过 500 元定金的用户会收到 100 元优惠券，200 元定金的用户可以收到 50 元优惠券，没有支付过定金的只能进入普通购买方式，也就是没有优惠券。相关的字段有这么几种： oederType: 订单类型，为 1 代表 500 元定金用户，2 代表 200 元定金用户，3 为普通购买用户； //职责链模式 var order500 = function(orderType, pay, stock) { if (orderType == 1 &amp;&amp; pay === true) { console.log('500元定金预约，得到100元优惠券'); } else { return 'nextSuccessor'; } }; var order200 = function(orderType, pay, stock) { if (orderType === 2 &amp;&amp; pay === true) { console.log('200元定金预约，得到50优惠券'); } else { return 'nextSuccessor'; } }; var orderNormal = function(orderType, pay, stock) { if (stock > 0) { console.log('普通购买，无优惠券'); } else { return 'nextSuccessor'; } }; 接下来需要把函数包装进职责链节点： //职责链包装 var Chain = function(fn) { this.fn = fn; this.nextSuccessor = null; }; Chain.prototype.setNextSuccessor = function(successor) { return (this.nextSuccessor = successor); }; Chain.prototype.passRequest = function() { var ret = this.fn.apply(this, arguments); if (ret == 'nextSuccessor') { //console.log(this.nextSuccessor.fn.name); return ( this.nextSuccessor &amp;&amp; this.nextSuccessor.passRequest.apply(this.nextSuccessor, arguments) ); //启动这一步启动递归了 } return ret; }; //测试 var chainOrder500 = new Chain(order500); var chainOrder200 = new Chain(order200); var chainOrderNormal = new Chain(orderNormal); chainOrder500.setNextSuccessor(chainOrder200); chainOrder200.setNextSuccessor(chainOrderNormal); //将请求传递给第一个节点即可 chainOrder500.passRequest(1, true, 100); //输出 500元定金，得到100元优惠券 chainOrder500.passRequest(2, true, 100); //输出200元定金，得到50元优惠券 chainOrder500.passRequest(1, false, 0); //输出 手机库存不足 六. 命令模式 用来对方法调用进行参数化处理和传送，经过这样处理过的方法调用可以在任何需要的时候执行。也就是说该模式旨在将函数的调用、请求和操作封装成一个单一的对象，然后对这个对象进行一些列的处理。他也可以用来消除调用操作的对象和实现操作的对象之间的耦合。这为各种具体的类的更换带来了极大的灵活性。 //1.一个连有炮兵和步兵，司令可以下命令调动军队打仗 var lian = {}; lian.paobing = function(pao_num) { console.log(pao_num + '门炮准备战斗'); }; lian.bubing = function(bubing_num) { console.log(bubing_num + '人准备战斗'); }; lian.lianzhang = function(mingling) { lian[mingling.type](mingling.num); }; //司令下命令 lian.lianzhang({ type: 'paobing', num: 10 }); lian.lianzhang({ type: 'bubing', num: 100 }); 七. 访问者模式 针对于对象结构中的元素，定义在不改变对象的前提下访问结构中元素的方法 在访问者模式中，主要包括下面几个角色 抽象访问者：抽象类或者接口，声明访问者可以访问哪些元素，具体到程序中就是 visit 方法中的参数定义哪些对象是可以被访问的。 访问者：实现抽象访问者所声明的方法，它影响到访问者访问到一个类后该干什么，要做什么事情。 抽象元素类：接口或者抽象类，声明接受哪一类访问者访问，程序上是通过 accept 方法中的参数来定义的。抽象元素一般有两类方法，一部分是本身的业务逻辑，另外就是允许接收哪类访问者来访问。 元素类：实现抽象元素类所声明的 accept 方法，通常都是visitor.visit(this)，基本上已经形成一种定式了。 结构对象：一个元素的容器，一般包含一个容纳多个不同类、不同接口的容器，如 List、Set、Map 等，在项目中一般很少抽象出这个角色。 // 访问者 function Visitor() { this.visit = function(concreteElement) { concreteElement.doSomething(); }; } // 元素类 function ConceteElement() { this.doSomething = function() { console.log('这是一个具体元素'); }; this.accept = function(visitor) { visitor.visit(this); }; } // Client var ele = new ConceteElement(); var v = new Visitor(); ele.accept(v);","tags":[{"name":"javascript","slug":"javascript","permalink":"http://coder.liusixin.cn/tags/javascript/"},{"name":"编程笔记","slug":"编程笔记","permalink":"http://coder.liusixin.cn/tags/编程笔记/"},{"name":"设计模式","slug":"设计模式","permalink":"http://coder.liusixin.cn/tags/设计模式/"}]},{"title":"JS你所不知道的奇淫技巧","date":"2017-11-27T13:49:27.000Z","path":"posts/336c09e/","text":"总结下 js 在日常使用中更简洁，更易读的写法 操作符的妙用1.利用按位与“&amp;”判断奇偶数按位与运算的逻辑是这样： 0001 &amp; 0011 = 0001，也就是两个位都是 1，才是 1，其它位都是 0。我们经常要做一个条件，判断一个数的奇偶性，会这样写： function fn(n) { if(n % 2 === 1) { //奇数 } else { //偶数 } } 2.利用按位与运算，则可以简写为这样：function fn(n) { if(n &amp; 1) { //奇数 } else { //偶数 } } 3.利用按位或“|”取整按位或运算的逻辑是这样： 0001 | 0011 = 0011，也就是两个位都是 0，才是 0，其它位都 1。 0 | 0 //0 0 | 1 //1 1 | 0 //1 1 | 1 //1 3 | 5 //7 即 0000 0011 | 0000 0101 = 0000 0111 因此，3|5的值得7 按位或|有一个作用，通过搭配 0 进行运算可以用来实现数字取整。 1.1 | 0 //1 -2.0 | 0 //-2 //非数字，则根据值强转为 0 或者 1 再取整，不过这种没啥意义 null | 0 //0 true | 0 //1 Tips: 其实浮点数是不支持位运算的，所以会先把 1.1 转成整数 1 再进行位运算，就好像是对浮点数向下求整。所以 1 | 0 的结果就是 1。 还有一个就是在设计 vue 组件的时候，也常用到的地方如下：（具体为啥这么用，我也说不清楚，没研究过原理，知道的同学可以告诉我）。 export default { //... 其它参数 props { params: Object | Array //只要其中任意一个满足条件即可 } } 4.利用按位非“~”简化表达式普及一下~运算符，这个符号学名叫“按位非”，它是一个一元运算符。按位非操作符由一个波浪线（~）表示，按位非就是求二进制的反码。不管什么值使用了这个运算符，结果总是一个数字。按位非运算符，简单的理解就是改变运算数的符号并减去 1。 ~5 //-6 ~0 //-1 ~-2 //1 ~true //-2 这里true被强转为1 ~null //-1 这里null被强转为0 ~undefined //-1 这里undefined被强转为0 利用这个原理，我们可以在实际工作中这样应用： var str = 'hello world!' if(str.indexOf('w') != -1) { /*...*/ } //或者 if(str.indexOf('w') > -1) { /*...*/ } //根据str.indexOf('w')的值，无外乎两种情况： -1, 0及正整数， //则，从-1到正整数中，经过按位运算~之后，则为：0或者任意负数， //实际表示为：false与true //上面的条件语句，可以改为： if(~str.indexOf('w')) { /*...*/ } Tips: 按位运算，简单的地方，可以使用。但一些比较复杂的、难理解的，我觉得应该尽量少用，因为会给阅读者带来困难，也会给自己带来麻烦。 5.左移&lt;&lt;求 2 的 n 次方//二进制运算： 01 &lt;&lt; 2 //0100，十进制为4 //实际运用可以这样： 1 &lt;&lt; 2 //4 即2的平方 1 &lt;&lt; 3 //8 即2的立方 1 &lt;&lt; 4 //16 即2的4次方 6.无符号右移&gt;&gt;&gt;判断数的正负正数的无符号右移与有符号右移结果是一样的。负数的无符号右移会把符号位也一起移动，而且无符号右移会把负数的二进制码当成正数的二进制码。即： 1 >>> 0 //1 2 >>> 0 //2 4 >>> 0 //4 4 >>> 1 //2 4 >>> 2 //1 -4 >>> 0 //4294967292 -4 >>> 1 //2147483646 -2 >>> 0 //4294967294 -1 >>> 0 //4294967295 观察上面的例子，我们得出一个结论，正数右移 0 位，值不变，而负数右移 0 位，值已经变化了。即可以通过这种关系判断一个数的正负： function isPos(n) { return n === n >>> 0 } isPos(-1) //false isPos(1) //true 7.利用&amp;&amp;连结条件与表达式通常，我们为了给一个变量赋值，正常的逻辑是：if 语句判断，通过 if 逻辑控制语句，则赋值成功。利用&amp;&amp;符号，则可以直接在前面写上条件语句，后面写上执行语句。 var a; if(true) { a = 10 } //也可以写成 var a; true &amp;&amp; (a = 10); //或者 var a = true &amp;&amp; 10; //这种情况尽量不要使用，因为如果条件不成立，则会给a赋上一个false值。 //常见使用： function fn(obj) { obj &amp;&amp; (return true); return false; } var a = b = c = true, d; a &amp;&amp; b &amp;&amp; c &amp;&amp; (d = 10); console.log(d) //10 Tips: 对于&amp;&amp;，需要注意以下几点： 对于布尔值，逻辑与是非常简单的，只要有一个 false，就返回 false； 对于不是布尔值的情况则：如果第一个操作数是对象，则返回第二个数如果第二个操作数是对象，则只有在第一个操作数的求值结果为 true 的情况下才会返回该对象；如果第两个操作数都是对象，则返回第二个数操作数如果有一个操作数是 null，则返回 null如果有一个操作数是 NaN，则返回第 NaN如果第一个操作数是 undefined，则返回 undefined 8.利用||取值（设置默认值）通常，我们声明一个变量，可能要根据条件进行赋值。正常的逻辑是：if … else if … else 或者使用 switch 这两种语句块。 var a, b; if(b === 0) { a = 1 } else if(b === 1) { a = 2 } else { a = 3 } //或者 var a, b = 1; switch(b) { case 0: a = 1; break; case 1: a = 2; break; default: a = 3; break; } 如果直接使用||或运算符，则按从左到右，取第一个非空的一个值，否则直接使用 false 作为值使用。 var b = 4; var a = (b === 0 &amp;&amp; 1) || (b === 1 &amp;&amp; 2) || 3; // 3 //常用到的或运算取值方式一般是在函数里面。 function doSomething(obj) { var o = obj || {} //如果obj不存在，则使用默认值 var oo; o &amp;&amp; (oo = obj || {}) //结合与运算，作变判断的前置条件 } Tips: 关于||，需要注意以下几点： 对于布尔值，逻辑或是非常简单的，只要有一个 true，就返回 true； 对于不是布尔值的情况则：如果第一个操作数是对象，则返第一个操作数如果第一个操作数的求值结果为 false，则返回第二个操作数如果两个操作数都是对象，则返回第一个操作数如果两个操作数是 null，则返回 null如果两个操作数是 NaN，则返回 NaN如果两个操作数是 undefined，则返回 undefined 9.利用~ ~取整如果要将一个小数取整数部分，正常的逻辑是：parseInt()强转为整数方法，或者 Math.floor()向下取整。其实，使用~ ~操作符可以更快速的取整。 parseInt(12.55) //12 Math.floor(12.55) //12 ~ ~12.55 //12 其实，除了取整的作用，它还可以达到强转数字的作用，比如： ~ ~true //1 ~ ~false //0 ~ ~[] //0 ~ ~{} //0 ~ ~undefined //0 ~ ~!undefined //1 ~ ~null //0 ~ ~!null //1 Tips: 虽然~ ~用起来比较骚气，但是为了可读性，本人还是建议使用 Math.floor()更为稳妥，谁知道领导 review 代码的时候，会不会说你过于装逼，要被喷死。 10.利用+将字符串转为数字如果要将一个表现字符串的数字转化为真正的数字，正常逻辑是：Number()或者 parseInt()、parseFloat()实现转化。实际上，我们还可以更简捷，只需要在前面添加一个+就可以了。当然，你也可以用-来实现，只不过，这样子，则值就成了负数。 Number('123') //123 parseInt('123') //123 parseFloat('123') //123 parseFloat('123.0') //123 parseFloat('123.0') //123 parseFloat('123.1') //123.1 //只要使用+，则可以实现数字的转化 +'123' //123 +'12.22' //12 -'12.1' //-12.1 //如果要取整并且转数字的话，使用~~ ~~'123.33' //123 实际上，+也适用于 Date 对象。 var date = new Date //Fri Oct 27 2017 14:38:49 GMT+0800 (中国标准时间) date.getTime() //1509086332914 //使用+直接输出时间缀 +new Date //1509086332914 11.利用!逻辑非强转布尔值逻辑非会将所有值，转为布尔值： !{} //false 一个空对象，实际上是一个引用，属于存在的引用地址值 ![] //false 存在引用地址值 !'' //true !0 //true !'hello' //false !null //true !NaN //true !undefined //true 利用逻辑非运算符，可以省去一些多余的判断。比如经常要判断一个值非空： var a, b; if(a !== undefined &amp;&amp; a !== null &amp;&amp; a !== '' &amp;&amp; a !== {} &amp;&amp; a!== 0 &amp;&amp; a!== undefined) { b = true; } 实际上，如果像这面这种判断，只需要一个逻辑非。 var a, b; !a &amp;&amp; (b = true); 12.利用!!实现变量检测如果要将一个值强转为布尔类型，正常的逻辑是：Boolean()强转为布尔值。 Boolean(123) //true Boolean('hello') //true Boolean('false') //true Boolean(null) //false Boolean(undefined) //false Boolean('undefined') //true 然而，通过!!两个非逻辑符，则可以将一个值强转为布尔值。 !!123 //true !!'hello' //true !!'false' //true !!null //false !!undefined //false !!0 //false 注意，0也会转为false，在数字中，只有0会转为false，其它非0值，都会转为true !!'' //false !!NaN //false Tips: 任意的 javascript 的值都可以转换成布尔值。这些值会被转换成 false：undefined,null,0,-0,NaN,””，而其它都变强转为 true。通常，利用!!符号来检测一个变量是否存在。 ###表达式的妙用 1.自执行函数函数，只是声明，并不能直接执行，需要调用才会执行。而如果，变成了表达式，则会自动执行。自执行函数，则是利用了表达式的这种特性。那些匿名函数附近使用括号或一些一元运算符来引导解析器，指明运算符附近是一个表达式。按照这个理解，可以举出五类，超过十几种的让匿名函数表达式立即调用的写法： ( function() {}() ); ( function() {} )(); [ function() {}() ]; ~ function() {}(); ! function() {}(); + function() {}(); - function() {}(); delete function() {}(); typeof function() {}(); void function() {}(); new function() {}(); new function() {}; var f = function() {}(); 1, function() {}(); 1 ^ function() {}(); 1 > function() {}(); Tips：另外值得再次注意的是，括号的含混使用——它可以用来执行一个函数，还可以做为分组运算符来对表达式求值。比如使用圆括号或方括号的话，可以在行首加一个分号，避免被用做函数执行或下标运算： ;( function() {}() ) ;(function(){})() 2.isNaN 判断是否为合法数字isNaN(x) 函数用于检查其参数是否是非数字值。如果 x 是特殊的非数字值 NaN（或者能被转换为这样的值），返回的值就是 true。如果 x 是其他值,则返回 false。经常，我们在页面功能模块开发过程中，拿到的交互数据，有很大可能是字符串形式的“数字”。这时，我们如果要做计算，就得先判断是否合法的数字。 isNaN('111') //false isNaN(111) //false isNaN(12.2) //false isNaN('12.2') //false isNaN('aa11') //true isNaN(undefined) //true 一切非数字，返回都是true Tips: 我们可以这样总结，只要是表现得像数字（字符串形式，或者真正数字）的都可以检测出是属于“数字”,否则属于不合法数字。 3.缓存 Array.length写 for 循环的时候，经常是这样： var arr = [1,2,3] for(var i = 0; i &lt; arr.length; i++) {/**/} 在处理一个很大的数组循环时，对性能的影响将是非常大的。为了提升运行性能，需要将数组使用一个变量缓存起来使用。 for(var i = 0, len = arr.length; i &lt; len; i++){/**/} 4.判断属于是否存在于对象中a、使用 in 运算符 var obj = { a: 11 } 'a' in obj //true 'b' in obj //false b、使用!! var obj = { a: 11 } !!obj.a //true !!obj.b //false //或者使用undefined来判断，但是可能也会属于值本身就是undefined，这样子就判断不出来了。 obj.a !== undefined //true obj.b !== undefined //false c、hasOwnProperty()方法 var obj = { a: 11 } obj.hasOwnProperty('a') //true obj.hasOwnProperty('b') //false //该方法只能判断自有属性是否存在，对于继承属性会返回false。 5.获取数组最后一个元素获取数组最后一个元素的方式有多种，常用的有 array.pop 或者 array[array.length - 1]方式。实际上，还可使用 Array.slice(-1) var arr = [1,2,3,4,5] arr.pop() //5 此方法会改变数组的结构，不推荐 arr[arr.length - 1] //5 arr.slice(-1)[0] //5 不需要计算数组的长度，直接拿到最后一个元素 6.数组截断数组有时候需要设置一个上限，或者删除数组中的一些元素，使用 array.length = [长度值] 这种方式非常有用。 var arr = [1,2,3,4,5] arr.slice(0,3) console.log(arr) //[1,2,3] arr = arr.splice(0,3) //splice方法会改变数组结构 console.log(arr) //[1,2,3] //直接设置长度值 arr.length = 3 console.log(arr) //[1,2,3] //还可以实现数组的清空操作 arr.length = 0; //arr => [] 7.数组合并合并数组常用的方法是：concat。不过现有一种更快速的合并方式：Array.push.apply(arr1,arr2) var arr1 = [1,2,3], arr2 = [4,5]; arr1 = arr1.concat(arr2) //常规方式 //或者 arr1 = arr1.push.apply(arr1,arr2); //装逼方式，但运行速度更快！ console.log(arr1) //[1,2,3,4,5] 两种方式都可以达到合并的结果 8.类数组利用数组的方法类数组拥有 length 属性，但不具有数组所具有的方法。为了方便操作，常需要将其转化为数组结构。 var arrLike = { '0': 'a', '1': 'b', length: 2 }; //下标为 '0' '1'才符合数组的数据结构 Array.prototype.join.call(arrLike, '-'); //a-b 模拟数组的join()方法,使用-分隔。 Array.prototype.slice.call(arrLike); //['a','b'] //模拟数组slice方法，返回一个新的数组 function fn() { var args = Array.prototype.slice.call(arguments); //获取所有参数的列表 } 9.利用 arguments.callee 实现递归普通的递归方法是这样写的： function fn(n) { if(n &lt;= 1) { return 1 } else { return n * fn(n - 1) } } 但是当这个函数变成了一个匿名函数时，我们就可以利用 callee 来递归这个函数。 function fn(n) { if(n &lt;= 1) { return 1 } else { return n * arguments.callee(n - 1) } } Tips: 这个方法虽然好用，但是有一点值得注意，ECMAScript4 中为了限制 js 的灵活度，让 js 变得严格，新增了严格模式，在严格模式中我们被禁止不使用 var 来直接声明一个全局变量，当然这不是重点，重点是 arguments.callee 这个属性也被禁止了。 10.给回调函数传递参数经常，函数一般是可以当作参数来使用。但是有时候，一些函数自身需要带参，这时候，把函数当参数使用的话，就显得比较麻烦。一般的处理方法是，通过附加的传参的办法。 function callback(obj) { console.log(obj) } function fn(callback, obj) { callback(obj) } 但是有些时候，函数的参数限定了，只能传一个回调函数，这时，这种附加传参的显得无力了。采用闭包的方式可以解决此问题。 function callback(obj) { return function() { console.log(obj) } } document.body.addEventListener('click',callback('hello')); //执行callback('hello')，则返回的是一个函数 11.利用正则表达式处理实际问题a、获取有价值部分 经常，在项目中，可能会获取到一些带有带有各种干扰因素的值。而我们需要提取相应的数字部分，可以使用正则表达式获取。 var val = \"98.8元/斤\"; val.replace(/[^(0-9).]/ig,'') //98.8 2、获取 URL 中的 value 值 经常，我们会从 url 中获取到 location.search，但却是一个字符串，然后还需要将这个字符串进行分拆才能得到想要的值，而使用正则，则快速方便得多。 //假设当前url为：https://www.baidu.com?name=jawil&amp;age=23 //普通实现： function fn(key) { var obj = {} var searchStr = window.location.search.substring(1); searchStr.split('&amp;').forEach(function(item) { var arr = item.split('='); obj[arr[0]] = arr[1]; }); return obj[key] } console.log(fn('name')) //jawil console.log(fn('age')) //23 //使用正则实现： function fn(key) { var reg = new RegExp(\"(^|&amp;)\"+ key +\"=([^&amp;]*)(&amp;|$)\"); //url正则表达式 var flag = window.location.search.substring(1).match(reg); return flag != null ? unescape(flag[2]) : null; } console.log(fn('name')) //jawil 3、格式化数字 通常，我们需要将一个大的数字 19456212 转化为 19,456,212 这种样子。使用正则表达式可以很好的处理： var num = 19456212.85; num.toLocaleString() //19,456,212.85 toLocaleString()会根据你机器的本地环境来返回字符串，它和toString()返回的值在不同的本地环境下使用的符号会有微妙的变化 //为了保险起见，可以使用方法实现 function fn(s, n) { n = n > 0 &amp;&amp; n &lt;= 20 ? n : 2; s = parseFloat((s + '').replace(/[^\\d\\.-]/g, '')).toFixed(n) + ''; var l = s.split('.')[0].split('').reverse(), r = s.split('.')[1]; t = ''; for (i = 0; i &lt; l.length; i++) { t += l[i] + ((i + 1) % 3 == 0 &amp;&amp; (i + 1) != l.length ? ',' : ''); } return t.split('').reverse().join('') + '.' + r; } console.log(fn(19456212.85)) //19,456,212.85","tags":[{"name":"javascript","slug":"javascript","permalink":"http://coder.liusixin.cn/tags/javascript/"}]},{"title":"前后端漏洞分析与安全防御总结","date":"2017-11-22T05:22:00.000Z","path":"posts/a76d942d/","text":"web 安全主要分以下几个层面 代码层面 架构层面 运维层面 本来主要围绕架构层面进行展开，如何写一个没有漏洞的网站。了解安全问题的原因，避免开发带漏洞的代码，如何开发安全的 web 项目。具体会遇到以下的安全问题，我们以此来研究及如何防御 安全问题 用户身份被盗用 用户密码泄露 用户资料被盗取 网站数据库泄露 其它 主要攻击手段分为以下几种 跨站脚本攻击 xss（cross site scripting） 跨站请求伪造攻击 CSRF（cross site request forgy） 前端 cookie 安全性 点击劫持攻击 传输过程安全问题 用户密码安全问题 SQL 注入攻击 信息泄露和社会工程学 其它安全问题 1. 跨站脚本攻击 xss跨站脚本（cross site script）为了避免与样式 css 混淆，所以简称为 XSS。 XSS 是一种经常出现在 web 应用中的计算机安全漏洞，也是 web 中最主流的攻击方式。那么什么是 XSS 呢？ XSS 是指恶意攻击者利用网站没有对用户提交数据进行转义处理或者过滤不足的缺点，进而添加一些代码，嵌入到 web 页面中去。使别的用户访问都会执行相应的嵌入代码。从而盗取用户资料、利用用户身份进行某种动作或者对访问者进行病毒侵害的一种攻击方式。 攻击原理: 客户端提交的数据本来就是应用所需要的，但是恶意攻击者利用网站对客户端提交数据的信任，在数据中插入一些符号以及 javascript 代码，那么这些数据将会成为应用代码中的一部分了。那么攻击者就可以肆无忌惮地展开攻击。 攻击危害: 获取页面数据 - 偷取网站任意数据 获取 cookies - 偷取用户资料 劫持前端逻辑 - 偷取用户密码和登录态 发送请求 - 欺骗用户 1.1 XSS 攻击分类:主要分为两大类 反射型（url 参数直接注入） 存储型（存储到 DB 后读取时注入） 了解即可，不必细究，XSS 根源就是没完全过滤客户端提交的数据 1.1.1 反射型 xss 攻击又称为非持久性跨站点脚本攻击，它是最常见的类型的 XSS。漏洞产生的原因是攻击者注入的数据反映在响应中。一个典型的非持久性 XSS 包含一个带 XSS 攻击向量的链接(即每次攻击需要用户的点击)。 正常发送消息： http://www.test.com/message.php?send=Hello,World！ 接收者将会接收信息并显示Hello,Word 非正常发送消息： http://www.test.com/message.php?send=&lt;script&gt;alert(‘danger!’)&lt;/script&gt;！ 接收者接收消息显示的时候将会弹出警告窗口 1.1.2 存贮型 xss 攻击又称为持久型跨站点脚本，它一般发生在 XSS 攻击向量(一般指 XSS 攻击代码)存储在网站数据库，当一个页面被用户打开的时候执行。每当用户打开浏览器,脚本执行。持久的 XSS 相比非持久性 XSS 攻击危害性更大,因为每当用户打开页面，查看内容时脚本将自动执行。谷歌的 orkut 曾经就遭受到 XSS。 从名字就可了解到存储型 XSS 攻击就是将攻击代码存入数据库中，然后客户端打开时就执行这些攻击代码。例如留言板 留言板表单中的表单域：&lt;input type=“text” name=“content” value=“这里是用户填写的数据”&gt; 正常操作： 用户是提交相应留言信息；将数据存储到数据库；其他用户访问留言板，应用去数据并显示。 非正常操作： 攻击者在value填写&lt;script&gt;alert(‘attach!’)&lt;/script&gt;【或者html其他标签（破坏样式。。。）、一段攻击型代码】； 将数据存储到数据库中； 其他用户取出数据显示的时候，将会执行这些攻击性代码 XSS 攻击注入点: HTML 节点内容 &lt;div>&lt;script type=\"text/javascript\">alert(1)&lt;/script>&lt;/div> HTML 属性 &lt;img src=\"1\" onerror=\"alert(1)\" alt=\"\"> JavasSript 代码 &lt;script type=\"text/javascript\">var data=\"##{data}\";var data=\"hello\";alert(1);\"\";&lt;/script> 富文本 得保留 HTML HTML 有 XSS 攻击风险 1.2 防御 XSS 浏览器自带防御 html 转义（针对 html 标签和属性） js 脚本转换 富文本过滤（一般在输入的时候） CSP（content security policy）- 最好解决方案 1.2.1 浏览器自带防御只针对反射型（html 内容或 html 属性），并不是所有浏览器都支持 1.2.2 html 转义var escapeHtml = function(str) { if (!str) return ''; str.replace(/&amp;/g, '&amp;amp;'); //只能在最前面，会对下面做转义 str.replace(/&lt;/g, '&amp;lt;'); //&lt;>html标签，引号html属性 str.replace(/>/g, '&amp;gt;'); str = str.replace(/\"/g, '&amp;quto;'); str = str.replace(/'/g, '&amp;##39;'); //str = str.replace(/ /g, '&amp;##32;'); //空格可能有问题，对html属性最好加引号 return str; }; 1.2.3 js 脚本转换&lt;script type=\"text/javascript\"> var data=\"##{data}\"; var data=\"hello\";alert(1);\"\"; &lt;/script> var escapeForJs = function(str) { if(!str) return ''; str = str.replace(/\\\\/g, '\\\\\\\\') str = str.replace(/\"/g, '\\\\\"') } 更好的方式是使用 JSON.stringify 转换 1.2.4 富文本过滤 按黑名单过滤 var xssFilter = function(html) { if (!html) return ''; html = html.replace(/&lt;\\s*\\/?script\\s*>/g, ''); html = html.replace(/javascript:[^'\"]*/g, ''); html = html.replace(/onerror\\s*=\\s*['\"]?[^'\"]*['\"]?/g, ''); return html; }; // 标签太多，属性太多，不适合此办法 按白名单保留部分标签和属性 // cheerio库 var xssFilter = function(html) { if (!html) return ''; var cheerio = require('cheerio'); var $ = cheerio.load(html); // 白名单 var whiteList = { img: ['src'], font: ['color', 'size'], a: ['href'] }; $('*').each(function(index, elem) { if (!whiteList[elem.name]) { $(elem).remove(); return; } for (var attr in elem.attribs) { if (whiteList[elem.name].indexOf(attr) === -1) { $(elem).attr(attr, null); } } }); console.log(html, $.html()); return $.html(); }; // 第三方库js-xss(根据白名单过滤HTML) // npm install xss var xssFilter = function(html) { if (!html) return ''; var xss = require('xss'); var ret = xss(html); console.log(html, ret); return ret; }; 1.2.5 CSP 内容安全策略(推荐)# 指定哪些内容可执行 child-src connect-src default-src font-src frame-src img-src manifest-src media-src object-src script-src style-src worker-src # 指定可信任来源 # 主机 'self' # 协议，self指同域 'unsafe-inline' # 直接插入页面的内容 'unsafe-eval' # eval函数 'none' # 不信任任何内容 'nonce-' # 一次凭证，指定内容与页面匹配才信任 # 哈希 'strict-dynamic' # 信任脚本内部引入的脚本 # 格式 # 设置头信息 Content-Security-Policy: default-src \"self\" http://www.example.com; content-src \"none\"; 2. 跨站请求伪造攻击 CSRF（cross site request forgy）跟 XSS 攻击一样，存在巨大的危害性，攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作。 CSRF 攻击原理: 第三方网站通过访问主网站后端带上 cookie 信息进行用户伪造 CSRF 危害: 利用用户登录态 用户不知情 完成业务请求 盗取用户资金 冒充用户发帖背锅 损坏网站名誉 2.1 CSRF 防御 禁止第三方网站带 Cookies same-site 属性（同一站点）-但是只有 chrome 是完全可以 在前端页面加入验证信息（ccap 模块生成验证码-npm install ccap –save） 验证码（攻击者网站不访问前端就没法拿到验证码通不过验证） token // 将token放入表单及cookie中，然后校验两者是否一致 var csrfToken = parseInt(Math.random() * 9999999, 10); ctx.cookies.set('csrfToken', csrfToken); 验证 referer // 禁止来自第三方网站的请求 var referer = ctx.request.headers.referer; if (!/^https?:\\/\\/localhost/.test(referer)) { throw new Error('非法请求'); } 3. 前端 cookie 安全性 前端数据存储 后端通过 http 头设置 请求时通过 http 头传给后端 前端可读写 遵守同源策略（协议，域名，端口） cookie 特性: 域名 有效期 路径 http-only secure（https） samesite cookie 作用: 存储个性化设置 存储未登录时用户唯一标识 存储已登录用户的凭证 前端提交用户名和密码 后端验证用户名和密码 后端通过 http 头设置用户凭证 后续访问时后盾先验证用户凭证 存储其它业务数据 3.1 cookie - 登录用户凭证3.1.1 用户 ID（隐患）3.1.2 用户 ID + 签名// crypt.js var crypt = {}; const KEY = '##ksdfidf312##!@%dj1'; crypt.cryptUserId = function(userId) { var crypto = require('crypto'); var sign = (crypto.createHmac = ('sha256', KEY)); sign.update(userId + ''); return sign.digest('hex'); }; module.exports = crypt; // 登录模块 ctx.cookies.set('sign', crypt.cryptUserId(user.id), { httpOnly: false, sameSite: 'strict' }); ctx.cookies.set('userId', crypt.cryptUserId(user.id), { httpOnly: false, sameSite: 'strict' }); // 验证 const crypt = require('./crypt'); var userId = ctx.cookies.get('userId'); var sign = ctx.cookies.get('sign'); var correctSign = cryptUserId(userId); if (correctSign !== sign) { throw new Error('err'); } 3.1.3 SessionId(持久化)// session.js var session = {}; var cache = {}; session.set = function(userId, obj) { var sessionId = Math.random(); if (!cache[sessionId]) { cache[sessionId] = {}; } cache[sessionId].content = obj; return sessionId; }; session.get = function(sessionId) { return cache[sessionId] &amp;&amp; cache[sessionId].content; }; module.exports = session; // user.js const session = require('./session'); var sessionId = session.set(user.id, { userId: user.id }); ctx.cookies.set('sessionId', sessionId, { httpOnly: true, sameSite: 'strict' }); // site.js const session = require('./session'); var sessionId = ctx.cookies.get('sessionId'); var sessionObj = session.get(sessionId); if (!sessionObj || !sessionObj.userId) { throw new Error('session不存在'); } var userId = sessionObj.userId; 3.2 cookies 和 xss 关系 xss 可能偷取 cookies http-only 的 cookie 不会被偷 3.3 cookies 和 csrf 关系 csrf 利用了用户 cookies 攻击站点无法读写 cookies 最好能阻止第三方使用 cookies 3.4 cookies - 安全策略 签名防篡改 私有变换（加密）- 信息隐藏 http-only（防止 xss） secure（https） same-site（主要 csrf 攻击，兼容性不好） 3.4.2 私有变换（加密）// 加密(node加密模块) var crypto = require('crypto'); var KEY = '9851##%*!df1%!'; var cipher = crypto.createCipher('des', KEY); var text = cipher.update('hello world', 'utf8', 'hex'); // 一边加密一边输出 text += cipher.final('hex'); console.log(text); // 解密 var decipher = crypto.createDecipher('des', KEY); var originalText = decipher.update(text, 'hex', 'utf8'); originalText += decipher.final('utf8'); console.log(originalText); 签名和加密是有区别的。签名的文件仍然是明文，内容公开，签名可以验证是否是用户传达的文件。加密的文件是密文，用户无法获取。 4. 点击劫持攻击原理： 通过 iframe 将目标网站放到页面上，将透明度设为 0，直接点击的是 iframe; 特征： 用户亲手操作 用户不知情 4.1 点击劫持防御 javascript 禁止内嵌（有局限性） X-FRAME-OPTIONS 禁止内嵌（ie8 以上）（推荐） 其他辅助手段 验证码 4.1.1 javascript 禁止内嵌html5 新属性sandbox，什么都不加默认会禁用掉很多功能 &lt;!-- 允许表单提交 --> &lt;iframe src=\"http://xxxx.cn:1211/post/15\" sandbox=\"allow-forms\">&lt;/iframe> &lt;!-- sandbox禁用功能 --> 这种方式有局限性，sandbox 即使加上有时候也会存在劫持。 &lt;script type=\"text/javascript\"> if(top.location != window.location){ top.location = window.location; } &lt;/script> 4.1.2 X-FRAME-OPTIONS 禁止内嵌ctx.set('X-Frame-Options', 'DENY'); DENY; // 禁止内嵌 SAME - ORIGIN; // 同一网站 SAMEORIGIN; // 嵌入页和被嵌入页在用一个域 ALLOW - FROM; // 网址 5. 传输过程安全问题 传输链路窃听篡改 https 5.1 传输链路窃听篡改我们可以用 anyproxy 代理软件来模拟攻击 http 窃听 窃听用户密码 窃听传输敏感信息 非法获取个人信息 http 篡改 插入广告 重定向网站 无法防御 xss 和 csrf 攻击 5.2 https 防御超文本传输安全协议（ HTTPS ）是一种通过计算机网络进行安全通信的传输协议。HTTPS 经由 HTTP 进行通信，但利用 SSL/TLS 来加密数据包。 HTTPS 开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。 还有一种情况是中间人攻击，看下图： 这种情况下要防御就需要引入证书 证书无法伪造 证书私钥不被泄露 域名管理权不泄露 CA 坚守原则 免费证书 www.sslforfree.com 5.2.1 https 部署curl https://get.acme.sh | sh /root/.acme.sh // 安装目录 cd /root/ ./acme.sh --issue -d www.example.com --webroot /data/web/www.example.com/ 然后配置 nginx server{ listen 80; listen 443 ssl http2; server_name www.example.com; ssl_certificate /root/.acme.sh/www.example.com/fullchain.cer; ssl_certificate_key /root/.acme.sh/www.example.com/www.example.com.key; location / { root /data/web/www.example.com; } } 6. 密码安全问题 密码作用 密码存储 密码传输安全性 密码的替代方案 生物特征密码问题 密码 - 泄露渠道 数据库被偷 服务器被入侵 通讯被窃听 内部人员泄露 其他网站（撞库） 6.1 密码存储 严禁明文存储(防泄露) 单向变换(防泄露) 变换复杂度要求(防猜解) - 变换次数越多越安全 加密成本几乎不变（生成密码时速度慢一些） 彩虹表失效（数量太大，无法建立通用性） 解密成本增大 N 倍 密码复杂度要求(防猜解) 加盐(防猜解) - 帮助用户提高复杂度 md5(sha1(md5(ID+ab83kd+原始密码+81kdso+盐+1lso;$2))) 6.1.1 严禁明文存储正常在数据库中是需要离线加密明文密码的，这里为了方便，我们在用户登录时做逻辑处理(加密、加盐) // user.js const password = require('./password') const results = await query( `select * from user where username = '${data.username}'` ) if(results.length){ let user = results[0]; //如果用户没有salt //需要升级 if(!user.salt){ var salt = password.getSalt(); var newPassword = password.encryptPassword(salt, user.password); await query(`update user set password = '${newPassword}', salt = '${salt}' where id = ${user.id}`); user.salt = salt; user.password = newPassword; } var encryptPassword = password.encryptPassword(user.salt, data.password) if(encryptPassword !== user.password){ throw new Error('密码不正确'); } } // password.js var password = {}; var md5 = function(str) { var crypto = require('crypto'); var md5Hash = crypto.createHash('md5'); md5Hash.update(str); return md5Hash.digest('hex'); }; password.getSalt = function() { return md5(Math.random() * 999999 + '' + new Date().getTime()); }; password.encryptPassword = function(salt, password) { return md5(salt + 'af$!##@$14##svc*&amp;sf%' + password); }; module.exports = password; 6.1.2 单向变换 哈希算法 明文-密文 – 对应 雪崩效应（明文有一点点不一样密文完全不一样） 密文 - 明文 无法反推 密文固定长度 常见哈希算法：md5 sha1 sha256 虽然没有办法反推出原密码，但是可以查表，网上有很多这种彩虹表的查询 这种情况下可以组合加密来防止彩虹表的查询 6.2 密码传输安全性 https 传输 频率限制 前端加密意义有限 前端加密 jspm install js-md5 7. SQL 注入攻击关系型数据库 存放结构化数据 可高效操作大量数据 方便处理数据之间的关联关系 常见：access/sqlite/mysql/mssql server 注入攻击危害 猜解密码 获取数据 删库删表 拖库 sql 语句 select * from user where id=1; insert into user(username,password) values('test','123'); update user set password='1234' where id=3; delete from user where id=3; 7.1 sql 注入攻击案例select * from user where username = 'TooBug' and password = '1' or '1'='1'; # 否定前面语句 select * from table where id=\"10\" and mid(version(),1,1)=5 # 截取版本号第一位是否等于5，等于5前面语句生效，否则报错。 select id,1,2,3 from table; select * from table union select 1,2,3 from table2; # 联合查询 select * from table where mid(username,1,1)=\"t\" # 查询username第一位等于't'; 7.2 sql 注入攻击防御 关闭错误输出 检查数据类型 对数据进行转义 使用参数化查询(抓包 charles，wireshark) 使用 ORM(对象关系映射)- 增强安全性，开发效率 7.3 NoSQL 注入攻击和防御 检查数据类型 类型转换 写完整条件 8. 接入层上传问题8.1 上传攻击 上传文件 再次访问上传的文件 上传的文件被当成程序解析 8.2 防御 限制上传后缀（比如 php 程序禁止上传 php 文件） 文件类型检查 fileType 文件内容检查（开头特征） var fileBuffer = fs.readFileSync(file.path); fileBuffer[0] == 0x5b; 程序输出（node 就是如此，但是因为要读到内存中，有读和写，性能受影响。折中办法：访问文件直接输出指令给到前端 nginx 服务器读取，性能损耗会小一些） 权限控制 - 可写可执行互斥（原则） 上传文件可写不可执行 部署应用时用低权限用户，而不用 root 这种高权限用户 9. 信息泄露和社会工程学 信息泄露 泄露系统敏感信息 泄露用户敏感信息 泄露用户密码 信息泄露途径 错误信息失控（mysql） sql 注入 水平权限控制不当 xss/csrf 社会工程学 你的身份由你掌握的资料确定 别人掌握了你的资料 别人伪装成你的身份 利用你的身份干坏事 案例: 电信诈骗 伪装公检法 QQ 视频借钱 微信伪装好友 9.1 OAuth 思想 一切行为由用户授权 授权行为不泄露敏感信息 授权会过期 9.1.1 利用 OAuth 思想防止资料泄露 用户授权读取资料 无授权的资料不可读取 不允许批量获取数据 数据接口可风控审计 10. 其它安全问题 拒绝服务攻击 DDOS 重放攻击 10.1 拒绝服务攻击 DOS特征: 模拟正常用户 大量占用服务器资源 无法服务正常用户 类型: TCP 半连接 HTTP 连接 DNS（域名解析服务器） 10.1.1 大规模分布式拒绝服务攻击 DDOS 流量可达几十到上百 G 分布式（肉鸡、代理） 极难防御 10.1.2 DOS 攻击防御 防火墙 交换机、路由器 流量清洗 高防 IP 10.1.3 DOS 攻击预防 避免重逻辑业务 快速失败快速返回 防雪崩机制 有损服务 CDN 10.2 重放攻击原理: 请求被窃听或记录 再次发起相同的请求 产生以外的结果 后果: 用户被多次消费 用户登录态被盗取 多次抽奖 10.2.1 防御 加密（https） 时间戳 token(session 后端生成) nonce 签名 总结cookies 和 session 关系session 是基于 cookies 的存储来实现的（常用） cookies 特性容量小，跟随 html 发送，通过 http 头设置，通过 js 读取 cookies 属性 域名，有域名不能跨域 路径，同一域名 path 不一样 cookies 读取情况不一样 有效期 http-only，没办法通过 js 读取，通过 http 发送后台给后台读取 same-site 删除一个 cookis 值？设置一个过期时间为过去时间。 https 如何保证数据不被窃听的通过数据加密方式，在客户端和服务端进行通信之前来协商一个加密协议，通过加密协议来传输所有数据。 https 如何保证不被中间人攻击证书机制 部署 https 的步骤 确保全栈都可以部署到 https 找 ca 生成证书","tags":[{"name":"前端安全","slug":"前端安全","permalink":"http://coder.liusixin.cn/tags/前端安全/"}]},{"title":"Nodejs编写静态博客命令行工具","date":"2017-11-15T05:44:50.000Z","path":"posts/d7a134ad/","text":"前言Node.js 除了可以编写服务器端程序， 也可以用来编写一些命令行工具， 本文会如何使用 commander 模块来编写一个命令行工具， 并以一个静态博客系统构建工具作为实例。具体内容包含以下几部分： commander 模块 markdown-it 模块 将 Markdown 转换成 HTML 实时监控文件变化 给 Markdown 内容套用模板 实时预览 生成整站静态页面 所使用到的第三方模块： commonder 解析命令行参数 http://tj.github.io/commander.js/ express http://expressjs.com/ serve-static 静态文件服务中间件 bttps://www.npmjs.com/package/serve-static markdown-it 渲染 Markdown 格式的文档 https://www.npmjs.com/package/markdown-it swig swig 语法模板引擎 http://paularmstrong.github.io/swig/ rd 遍历目录下的所有文件，包括子目录 https://www.npmjs.com/package/rd fs-extra 扩展了 fs 模块的一些方法 https://www.npmjs.com/package/fs-extra open 使用系统程序打开指定文件或网址 https://www.npmjs.com/package/open moment 解析、格式化日期时间 http://momentjs.com/docs/ 命令格式在编写命令行工具时，我们首先要定义命令的使用方法，比如： $ XBlog new # 表示创建一个空的博客； $ XBlog build # 表示生成整站静态HTML页面等。 常见的命令格式一条命令一般包含以下几部分： command [options] [arguments] - command # 命令名称，比如node。 - options # 单词或单字，比如 --help或-h。 - arguments # 参数，有时选项也带参数，比如：xss。 在查看命令帮助时，会出现 &quot;[]&quot; &quot;&lt;&gt;&quot; &quot;|&quot; 等符号: - [] # 表示是可选的。 - # 表示可变选项，一般是多选一，而且必须要选其一。 - x|y|z # 多选一，如果加上\"[]\"，则可不选。 - -abc # 多选，如果加上\"[]\", 则可不选。 比如，NPM 命令的使用方法描述如下： $ npm $ npm install $ npm list 以上是大多数命令行工具遵循的语法格式。 定义静态博客命令格式我们要实现的命令行生成工具包含以下功能： 创建一个空的博客； 文章使用 Markdown 格式编写； 本地实时预览； 生成整站静态 HTML； 根据描述，我们先来定义这个命令行工具的使用方法： XBlog create [dir] # 创建一个空的博客，dir为博客所在目录（可选，默认为当前目录） XBlog preview [dir] # 实时预览，dir为博客所在目录（可选，默认为当前目录） XBlog build [dir] [--output target] # 生成整站静态HTML, dir为博客所在目录（可选，默认为当前目录），target为生成的静态HTML存放目录 编写命令行工具在 Node 中，可以通过 process.argv 变量来取得启动时的参数，它是一个数组。比如： $ node test.js build xxx # process.argv 的值为： ['node', 'test.js', 'build', 'xxx'] 第一个为命令名，第二个为程序文件名，从第三个参数起则是启动 Node 程序所传的参数，每个参数用空格隔开。由于这些参数都是字符串，为了支持更灵活的参数组合方法，需要编写一个专门的程序先来解析这些参数字符串，而 commander 模块已经为我们做好了。 首先新建空的项目文件夹，然后npm init -y来初始化。 $ mkdir XBlog && cd XBlog $ npm init -y # 安装commander模块 $ npm i commander -D 然后新建文件 bin/XBlog 并编辑 #!/usr/bin/env node var program = require('commander'); // 命令版本号 program.version('0.0.1'); // help命令 program .command('help') .description('显示使用帮助') .action(function() { program.outputHelp(); }); // create命令 program .command('create [dir]') .description('创建一个空的博客') .action(function(dir) { console.log('create %s', dir); }); // preview命令 program .command('preview [dir]') .description('实时预览') .action(function(dir) { console.log('preview %s', dir); }); // build命令 program .command('build [dir]') .description('生成整站静态HTML') .option('-o, --output &lt;dir>', '生成的静态HTML存放目录') .action(function(dir, options) { console.log('create %s, output %s', dir, options.output); }); // 开始解析命令 program.parse(process.argv); command(&#39;help&#39;) 表示当前是什么命令； description(&#39;显示使用帮助&#39;) 当前命令的简单描述，在查看命令帮助时会显示出来； action(callback) 为解析到当前命令时执行的回调函数。 option(&#39;-o, --output &lt;dir&gt;&#39;, &#39;生成的静态HTML存放目录&#39;) 表示在执行 build 命令时，还可以附加一些可选项，比如 -o &lt;dir&gt;用来指定生成的文件输出到哪里。 第一行 #!/usr/bin/env node 指定当前文件使用哪个解释器执行。在 Linux Shell 环境下，文件具有执行权限时，可以直接通过 ./xxx 来执行（一般要执行 Node 时是执行命令 node xxx.js), 如不指定解释器，则默认使用 bash 执行。 现在编辑文件package.json, 增加 bin 属性： { \"name\": \"XBlog\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": { \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" }, \"keywords\": [], \"author\": \"liusixin\", \"license\": \"MIT\", \"bin\": { \"XBlog\": \"./bin/XBlog\" }, \"devDependencies\": { \"commander\": \"^2.10.0\" } } bin 属性用来指定当前模块需要链接的命令，在这里我们指定了 XBlog 命令是执行文件 ./bin/XBlog。 为了让这个设置生效，还需要执行以下命令来进行链接： $ sudo npm link 执行成功后，会显示 现在我们试下执行： XBlog help 说明我们这个命令行工具的基本框架已经完成了; 实时预览虽然实现了基本框架，但在功能上还是空白的。一个静态博客工具包含以下这些功能模块： 渲染文章内容页面和文章列表页面； 修改模板实时预览； 创建基本的博客模板； 我们先从实现 preview 命令入手。 启动 Web 服务器为了使代码结构更加清晰，首先我们将 bin/XBlog 文件中 preview 命令的回调函数改为require(&#39;../lib/cmd_preview&#39;); // preview命令 program .command('preview [dir]') .description('实时预览') .action(require('../lib/cmd_preview')); 新建文件 lib/cmd_preview.js var express = require('express'); var serveStatic = require('serve-static'); var path = require('path'); module.exports = function(dir) { dir = dir || '.'; // 指定当前博客项目所在的目录，如果没有指定则默认为当前目录 // 初始化express var app = express(); var router = express.Router(); app.use('/assets', serveStatic(path.resolve(dir, 'assets'))); // 静态资源文件 app.use(router); // 渲染文章 router.get('/posts/*', function(req, res, next) { // 文章内容页面 res.end(req.params[0]); }); // 渲染列表 router.get('/', function(req, res, next) { // 文章列表页面 res.end('文章列表'); }); app.listen(3000); }; 使用 express 来启动一个 Web 服务器，主要处理以下三部分内容： 以 &quot;/assets&quot; 开头的 URL 为博客中用到的静态资源文件， 对应的是博客根目录下的 assets 目录； 以 &quot;/posts&quot; 开头的 URL 为文章内容页面，比如访问的 URL 是 /posts/2017-12/hello-world.html, 对应的是源文件_posts/2017-12/helloworld.md; &quot;/&quot; 为文章列表页面。 由于使用到了 express 和 serve-static 两个模块，所以先安装它们： $ npm i express serve-static -S 然后启动 $ XBlog preview 然后 浏览器输入 http://localhost:3000 查看效果 渲染文章页面文章内容使用 Markdown 语法来编写，我们可以使用markdown-it模块来解析并将其转为相应的 HTML。模板引擎我们使用 swig。 文章源文件存储在_post 目录下，比如文件_posts/2017-12/hello-world.md 对应的 URL 是 /posts/2017-12/hello-world.html。 文件lib/cmd_preview.js: var express = require('express'); var serveStatic = require('serve-static'); var path = require('path'); var fs = require('fs'); var md = require('markdown-it')({ html: true, langPrefix: 'code-' }); module.exports = function(dir) { dir = dir || '.'; // 指定当前博客项目所在的目录，如果没有指定则默认为当前目录 // 初始化express var app = express(); var router = express.Router(); app.use('/assets', serveStatic(path.resolve(dir, 'assets'))); // 静态资源文件 app.use(router); // 渲染文章 router.get('/posts/*', function(req, res, next) { // 文章内容页面 var name = stripExtname(req.params[0]); var file = path.resolve(dir, '_posts', name + '.md'); fs.readFile(file, function(err, content) { if (err) return next(err); var html = markdownToHTML(content.toString()); res.end(html); }); }); // 渲染列表 router.get('/', function(req, res, next) { // 文章列表页面 res.end('文章列表'); }); app.listen(3000); }; // 去掉文件名中的扩展名 function stripExtname(name) { var i = 0 - path.extname(name).length; if (i === 0) i = name.length; return name.slice(0, i); } // 将Markdown转换为HTML function markdownToHTML(content) { return md.render(content || ''); } 我们随便写篇文章，保存到 example/posts/2017-12/hello-world.md # hello world 安装所需模块 markdown-it 并启动程序（注意 preview 命令后面有指定博客项目所在的目录，为example) $ npm i markdown-it -S $ XBlog preview example 然后在浏览器中打开 http://127.0.0.1:3000/posts/2017-12/hello-world.html 文章元数据一篇文章除内容外，一般还会带上一些元数据，比如文章标题、发表时间、标签等: --- title: hello-world date: 2017-12-01 --- 文件顶部在 “—” 之间的部分是文章的元数据 修改文件lib/cmd_preview.js, 增加函数解析文章元数据： // 解析文章内容 function parseSourceContent(data) { var split = '---\\n'; var i = data.indexOf(split); var info = {}; if (i !== -1) { var j = data.indexOf(split, i + split.length); if (j !== -1) { var str = data.slice(i + split.length, j).trim(); data = data.slice(j + split.length); str.split('\\n').forEach(function(line) { var i = line.indexOf(':'); if (i !== -1) { var key = line.slice(0, i).trim(); var value = line.slice(i + 1).trim(); info[key] = value; } }); } } info.source = data; return info; } 再修改渲染文章路由处理部分 fs.readFile(file, function(err, content) { if (err) return next(err); // var html = markdownToHTML(content.toString()); var post = parseSourceContent(content.toString()); console.log(post); var html = markdownToHTML(post.source); res.end(html); }); 重新启动程序并刷新页面，可看到文章的标题不见了，而在控制台中可看到这样的输出： 其中 title 和 date 为我们在文章源文件中设置的元数据，而 source 则为文章的内容。有了这些元数据，我们接下来就可以做更多的事情了。 增加模板上面的示例中，没有好看样式，显得略丑， 接下来我们给它接上一个模板。 修改文件lib/cmd_preview.js: var swig = require('swig'); swig.setDefaults({ cache: false }) ... // 渲染模板 function renderFile(file, data) { return swig.render(fs.readFileSync(file).toString(), { filename: file, autoescape: false, locals: data }) } 为了编程方便，此处使用 fs.readFileSync() 这个方法来读取文件内容，在读取过程中它会造成进程阻塞，但在本例中不会造成影响。 修改原来渲染文章内容的部分： fs.readFile(file, function(err, content) { if (err) return next(err); var post = parseSourceContent(content.toString()); post.content = markdownToHTML(post.source); post.layout = post.layout || 'post'; var html = renderFile(path.resolve(dir, '_layout', post.layout + '.html'), { post: post }); res.end(html); }); 在渲染模板时，传递post变量进去，在模板中可以通过post.content来取得文章的内容，通过post.xxx来取得文章的元数据XXX。可以通过元数据layout来指定要渲染的模块，默认为post, 模板文件存储在 _layout 目录下。 新建模板文件，保存到example/_layout/post.html &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>{{config.title|escape}}&lt;/title> &lt;link rel=\"stylesheet\" href=\"/assets/style.css\"> &lt;/head> &lt;body> &lt;h1>{{post.title|escape}}&lt;/h1> &lt;p>日期：{{post.date|escape}}&lt;/p> &lt;hr> &lt;div class=\"post-content\">{{post.content}}&lt;/div> &lt;/body> &lt;/html> 引用了一个 CSS 文件，example/assets/style.css: html { background-color: #eee; } body { width: 800px; min-height: 500px; margin: 0 auto; padding: 40px; line-height: 1.6; background-color: #fff; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-weight: 300; } ul { margin: 0; padding: 0; list-style: none; } li i { display: block; margin-top: 20px; border-bottom: 1px solid #888; } pre { background-color: #f5f5f5; margin: 0; padding: 8px 12px; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 14px; font-weight: 300; color: #000; } .post-date { display: inline-block; padding: 0px 16px; background-color: #888; color: #fff; } .post-title { display: inline-block; margin-left: 6px; text-decoration: none; font-weight: bold; } .post-title:hover { color: #f00; } 安装 swig 模块并启动程序： $ npm i swig -S $ XBlog preview example 可以看到美观多了。接下来我们试试换个模板，给文章添加元数据： layout: post2 新建模板文件example/_layout/post2.html: &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>{{config.title|escape}}&lt;/title> &lt;/head> &lt;body> &lt;h1>{{post.title|escape}}&lt;/h1> &lt;p>日期：{{post.date|escape}}&lt;/p> &lt;hr> &lt;div class=\"post-content\">{{post.content}}&lt;/div> &lt;/body> &lt;/html> 区别是 post2 里没有引 css 文件。我们再看下效果: 渲染文章列表要渲染文章列表，则首先要遍历所有文章，并且按照发表时间来排序，然后将其标题渲染出来。每篇文章均存储在 _posts 目录下，为了方便管理，我们采用的格式是 发表年月/文件名.md，可以借助rd模块来遍历整个 _posts 目录下的 .md 文件。 修改文件lib/cmd_preview.js: var rd = require('rd'); ... // 渲染列表 router.get('/', function(req, res, next) { // 文章列表页面 var list = []; var sourceDir = path.resolve(dir, '_posts'); rd.eachFileFilterSync(sourceDir, /\\.md$/, function(f, s) { var source = fs.readFileSync(f).toString(); var post = parseSourceContent(source); post.timestamp = new Date(post.date); post.url = '/posts/' + stripExtname(f.slice(sourceDir.length + 1)) + '.html'; list.push(post); }) list.sort(function(a, b) { return b.timestamp - a.timestamp; }) var html = renderFile(path.resolve(dir, '_layout', 'index.html'), { posts: list }) res.end('html'); }) rd.eachFileFilterSync(dir, pattern, callback)遍历所有文件，dir为遍历目录，pattern为过滤规则正则，此例子中我们只读取 md 后缀的文件，callback 为回调函数，每读取到一个文件就会执行一次，它的第一个参数为这个文件的完整路径； 在得到文章列表之后，我们还需要对文章按发表时间降序排序，首先我们先通过 post.timestamp = new Date(post.date); 得到文章发表时间的时间戳，然后通过数组的 sort()来进行排序； post.url 为文章的链接，主要为了在渲染文章列表时，点击跳转详细内容页面，通过 &#39;/posts/&#39; + stripExtname(f.slice(sourceDir.length + 1)) + &#39;.html&#39; 来取得。其原理为先取得文章源文件在 _posts 目录下的相对路径，然后将其后缀名.md改为.html即可。 新建文章列表的模板文件为_layout/index.html, &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>{{config.title|escape}}&lt;/title> &lt;link rel=\"stylesheet\" href=\"/assets/style.css\"> &lt;/head> &lt;body> &lt;h1>{{post.title|escape}}&lt;/h1> &lt;ul> {% for post in posts %} &lt;li> &lt;span class=\"post-date\">{{post.date|escape}}&lt;/span> &lt;a class=\"post-title\" href=\"{{post.url|escape}}\"> {{post.title|escape}} &lt;/a> &lt;/li> {% endfor %} &lt;/ul> &lt;/body> &lt;/html> 我们再随便添加几篇文章，并安装 rd 模块，然后启动程序 $ npm i rd -S $ XBlog preview example 然后在浏览器中打开 http://localhost:3000 这样，我们的静态博客实时预览就完成了。 生成静态博客生成静态博客内容时渲染文章的程序与实时预览时基本一样，区别是这一步不是等待用户访问时再渲染文章，而是直接遍历所有文章并直接渲染，然后把渲染后的页面直接保存为文件，因此我们可以先把这些公共的程序提取出来。 首先将渲染文章的内容部分和渲染文章的列表部分的程序提取处理， 分别命名为renderPost()和renderIndex(), 新建文件lib/utils.js: var swig = require('swig'); var rd = require('rd'); var path = require('path'); var fs = require('fs'); var md = require('markdown-it')({ html: true, langPrefix: 'code-' }); swig.setDefaults({ cache: false }); // 去掉文件名中的扩展名 function stripExtname(name) { var i = 0 - path.extname(name).length; if (i === 0) i = name.length; return name.slice(0, i); } // 将Markdown转换为HTML function markdownToHTML(content) { return md.render(content || ''); } // 解析文章内容 function parseSourceContent(data) { var split = '---\\n'; var i = data.indexOf(split); var info = {}; if (i !== -1) { var j = data.indexOf(split, i + split.length); if (j !== -1) { var str = data.slice(i + split.length, j).trim(); data = data.slice(j + split.length); str.split('\\n').forEach(function(line) { var i = line.indexOf(':'); if (i !== -1) { var key = line.slice(0, i).trim(); var value = line.slice(i + 1).trim(); info[key] = value; } }); } } info.source = data; return info; } // 渲染模板 function renderFile(file, data) { return swig.render(fs.readFileSync(file).toString(), { filename: file, autoescape: false, locals: data }); } // 遍历所有文章 function eachSourceFile(sourceDir, callback) { rd.eachFileFilterSync(sourceDir, /\\.md$/, callback); } // 渲染文章 function renderPost(dir, file) { var content = fs.readFileSync(file).toString(); var post = parseSourceContent(content.toString()); post.content = markdownToHTML(post.source); post.layout = post.layout || 'post'; var html = renderFile(path.resolve(dir, '_layout', post.layout + '.html'), { post: post }); return html; } // 渲染文章列表 function renderIndex(dir) { var list = []; var sourceDir = path.resolve(dir, '_posts'); eachSourceFile(sourceDir, function(f, s) { var source = fs.readFileSync(f).toString(); var post = parseSourceContent(source); post.timestamp = new Date(post.date); post.url = '/posts/' + stripExtname(f.slice(sourceDir.length + 1)) + '.html'; list.push(post); }); list.sort(function(a, b) { return b.timestamp - a.timestamp; }); var html = renderFile(path.resolve(dir, '_layout', 'index.html'), { posts: list }); return html; } exports.renderPost = renderPost; exports.renderIndex = renderIndex; exports.stripExtname = stripExtname; exports.eachSourceFile = eachSourceFile; 优化lib/cmd_preview.js: var express = require('express'); var serveStatic = require('serve-static'); var path = require('path'); var utils = require('./utils'); module.exports = function(dir) { dir = dir || '.'; // 指定当前博客项目所在的目录，如果没有指定则默认为当前目录 // 初始化express var app = express(); var router = express.Router(); app.use('/assets', serveStatic(path.resolve(dir, 'assets'))); // 静态资源文件 app.use(router); // 渲染文章 router.get('/posts/*', function(req, res, next) { // 文章内容页面 var name = utils.stripExtname(req.params[0]); var file = path.resolve(dir, '_posts', name + '.md'); var html = utils.renderPost(dir, file); res.end(html); }); // 渲染列表 router.get('/', function(req, res, next) { // 文章列表页面 var html = utils.renderIndex(dir); res.end(html); }); app.listen(3000, function() { console.log(`Blog is running`); }); }; 重新启动预览程序，可以看到程序正常运行 接下来实现 build 命令 修改文件bin/XBlog: // build命令 program .command('build [dir]') .description('生成整站静态HTML') .option('-o, --output &lt;dir>', '生成的静态HTML存放目录') .action(require('../lib/cmd_build')); 新建文件lib/cmd_build.js var path = require('path'); var utils = require('./utils'); var fs = require('fs-extra'); module.exports = function(dir, options) { dir = dir || '.'; var outputDir = path.resolve(options.output || dir); // 写入文件 function outputFile(file, content) { console.log('生成页面：%s', file.slice(outputDir.length + 1)); fs.outputFileSync(file, content); } // 生成文章内容页面 var sourceDir = path.resolve(dir, '_posts'); utils.eachSourceFile(sourceDir, function(f, s) { var html = utils.renderPost(dir, f); var relativeFile = utils.stripExtname(f.slice(sourceDir.length + 1)) + '.html'; var file = path.resolve(outputDir, 'posts', relativeFile); outputFile(file, html); }); // 生成首页 var htmlIndex = utils.renderIndex(dir); var fileIndex = path.resolve(outputDir, 'index.html'); outputFile(fileIndex, htmlIndex); }; build 命令允许通过 --output &lt;dir&gt; 选项来指定文件的输出路径，如果没有指定则默认输出到当前博客项目所在的目录， 通过 path.resolve(options.output || dir)来取得，并保存到变量outputDir中； 保存文件时使用fs-extra模块的 fs.outputFileSync() 函数来做，其好处是可以不用管目录是否存在，如果目录不存在，则模块会自动帮我们创建。 安装fs-extra模块并执行 build 命令： $ npm i fs-extra -S $ XBlog build example 同时可以看到生成目录 如果想要输出到别的目录，可以指定 --output,比如： $ XBlog build example --output output 配置文件有时需要在渲染页面时用到一些公共的数据，在启动实时预览程序时希望可以自已指定要监听的端口，这时我们可以通过博客目录下的config.json来指定这些数据。 修改文件lib/utils.js： // 读取配置文件 function loadConfig(dir) { var content = fs.readFileSync(path.resolve(dir, 'config.json')).toString(); var data = JSON.parse(content); return data; } exports.loadConfig = loadConfig; 新建文件example/config.json: { \"port\": 3100 } 修改文件lib/cmd_preview.js，顶部增加代码 var open = require('open'); ... var config = utils.loadConfig(dir); var port = config.port || 3000; var url = 'http://127.0.0.1:' + port; app.listen(port, function(){ console.log(`Blog is running`); }) open(url); 通过配置文件 port 属性指定监听端口，如果没有则默认3000; open 模块用于调用系统浏览器打开指定网址，在preview命令执行后，将自动在浏览器中打开博客首页。 安装open模块并执行preview命令： S npm i open -S S XBlog preview example 执行命令后，就可以看到浏览器会自动打开http://127.0.0.1:3100。 接下来我们实现在模板中也可以通过 config 变量来访问到配置数据。 修改文件lib/utils.js, 将renderPost()和renderIndex()修改： // 渲染文章 function renderPost(dir, file) { var content = fs.readFileSync(file).toString(); var post = parseSourceContent(content.toString()); post.content = markdownToHTML(post.source); post.layout = post.layout || 'post'; var config = loadConfig(dir); var layout = path.resolve(dir, '_layout', post.layout + '.html'); var html = renderFile(layout, { config: config, post: post }); return html; } // 渲染文章列表 function renderIndex(dir) { var list = []; var sourceDir = path.resolve(dir, '_posts'); eachSourceFile(sourceDir, function(f, s) { var source = fs.readFileSync(f).toString(); var post = parseSourceContent(source); post.timestamp = new Date(post.date); post.url = '/posts/' + stripExtname(f.slice(sourceDir.length + 1)) + '.html'; list.push(post); }); list.sort(function(a, b) { return b.timestamp - a.timestamp; }); var config = loadConfig(dir); var layout = path.resolve(dir, '_layout', 'index.html'); var html = renderFile(layout, { config: config, posts: list }); return html; } 在渲染时通过loadConfig()来读取配置信息，并作为 config 变量传递给模板。 创建空白博客模板在创建一个新的博客项目时，为了方便使用，我们希望这个工具能自动创建一些必需的文件，比如页面模板和默认配置文件，这样就可以马上编写文章了。 把上面创建的一些文件保存在 tpl 目录下： 将example/_layout/index.html复制到tpl/_layout/index.html; 将example/_layout/post.html复制到tpl/_layout/post.html; 将example/assets/style.css复制到tpl/assets/style.css; 将example/config.json复制到tpl/config.json。 一个空的博客项目包含以下目录： _layout目录，存放模板文件； _posts目录，存放文章内容源文件； posts目录，存放生成的博客页面； assets目录，存放博客页面中引用到的静态资源。 我们还可以在新博客自动创建一篇 hello, world 文章。 修改文件bin/XBlog, 将 create 命令部分改为： // create命令 program .command('create [dir]') .description('创建一个空的博客') .action(require('../lib/cmd_create')); 新建文件lib/cmd_create.js var path = require('path'); var utils = require('./utils'); var fs = require('fs-extra'); var moment = require('moment'); module.exports = function(dir) { dir = dir || '.'; // 创建基本目录 fs.mkdirsSync(path.resolve(dir, '_layout')); fs.mkdirsSync(path.resolve(dir, '_posts')); fs.mkdirsSync(path.resolve(dir, 'assets')); fs.mkdirsSync(path.resolve(dir, 'posts')); // 复制模板文件 var tplDir = path.resolve(__dirname, '../tpl'); fs.copySync(tplDir, dir); // 创建第一篇文章 newPost(dir, 'hello, world', '这是我的第一篇文章'); console.log('OK'); }; // 创建一篇文章 function newPost(dir, title, content) { var data = [ '---', 'title: ' + title, 'date: ' + moment().format('YYYY-MM-DD'), '---', '', content ].join('\\n'); var name = moment().format('YYYY-MM') + '/hello-world.md'; var file = path.resolve(dir, '_posts', name); fs.outputFileSync(file, data); } 使用fs-extra模块提供的mkdirsSync()来创建目录， 可以不用管其父目录是否存在，模块会自动帮我们创建； 使用fs-extra模块提供的copySync()来复制一个目录； 使用moment模块来生成日期字符串。 安装 moment 模块，创建一个空的项目并预览： $ npm i moment -S $ XBlog create new_blog $ XBlog preview new_blog 至此，静态博客的基本功能已经完成了。 第三方服务评论组件由于这个博客是静态页面，所以无法在服务器端处理用户对文章内容的评论。现在网上已有很多第三方的评论组件，我们可以在模板中简单地填写一些代码即可使用到这些服务。以下是一些常用的第三方评论组件。 多说：社会化评论系统、社交评论插件，详细介绍见 http://duoshuo.com/。 Disqus：The Web’s Community of Communities, 详细介绍见 https://disqus.com。 我们在模板文件_layout/post.html末尾添加以下多说评论组件的代码: &lt;!-- 多说评论框start --> &lt;div class=\"ds-thread\" data-thread-key=\"\" data-title=\"{{post.title|escape}}\" data-url=\"\">&lt;/div> &lt;!-- 多说评论框end --> &lt;!-- 多说公共JS代码start (一个网页只需插入一次） --> &lt;script type=\"text/javascript\"> var duoshuoQuery = { short_name: \"node-in-action-blog\" }; (function() { var ds = document.createElement('script'); ds.type = 'text/javascript'; ds.async = true; ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js'; ds.charset = 'UTF-8'; (document.getElementsByTagName('head')[O] || document.getElementsByTagName('body')[O]).appendChild(ds); })() &lt;/script> &lt;!-- 多说公共JS代码end --> 分享组件可以使用国内的 “加网” 提供的分享组件，详细介绍见http://www.jiathis.com/。 我们在模板文件_layout/post.html末尾添加以下 JiaThis 分享组件： &lt;!-- JiaThis Button BEGIN --> &lt;div class=\"jiathis—style_32x32\"> &lt;a class=\"jiathis_button_qzone\">&lt;/a> &lt;a class=\"jiathis button tsina\">&lt;/a> &lt;a class=\"jiathis_button_tqq\">&lt;/a> &lt;a class=\"jiathis button weixin\">&lt;/a> &lt;a class=\"jiathis button renren\">&lt;/a> &lt;a href=\"http://www.jiathis.com/share\" class=\"jiathis jiathis_txt jtico jtico_jiathis \" target=\"_blank\">&lt;/a> &lt;a class=\"jiathis_counter_style\">&lt;/a> &lt;/div> &lt;script type=\"text/javascript\" src=\"http://v3.jiathis.com/code/jia.js\" charset=\"utf-8\">&lt;/script> &lt;!-- JiaThis Button END -->","tags":[{"name":"javascript","slug":"javascript","permalink":"http://coder.liusixin.cn/tags/javascript/"},{"name":"Nodejs","slug":"Nodejs","permalink":"http://coder.liusixin.cn/tags/Nodejs/"},{"name":"Koa2","slug":"Koa2","permalink":"http://coder.liusixin.cn/tags/Koa2/"}]},{"title":"JavaScript设计模式--结构型设计模式","date":"2017-11-08T12:23:57.000Z","path":"posts/5a581879/","text":"该系列参考自 《JavaScript 设计模式》 以及 汤姆大叔的博文 深入理解 JavaScript 系列 前言 外观模式 适配器模式 代理模式 装饰者模式 桥接模式 组合模式 享元模式 一. 外观模式 为一组复杂子系统接口提供一个更高级的统一接口，通过这个接口使得对子系统访问更加的容易。 // 使用外观模式注册事件监听 function addEvent(dom, type, fn) { if (dom.addEventListener) { dom.addEventListener(type, fn, false); } else if (dom.attachEvent) { dom.attachEvent('on' + type, fn); } else { dom['on' + type] = fn; } } // 使用外观模式获取事件对象 var getEvent = function(event) { return event || window.event; }; 通过对接口的二次封装，使其简单易用，隐藏起内部的复杂度，外观模式就是对接口的外层包装，以供上层代码调用。因此外观模式封装的接口方法不需要接口的具体实现，只需要按照接口的使用规则使用即可。 二. 适配器模式 将一个类的接口转换为另外一个类的接口以满足用户的需求，使类之间的接口不兼容问题通过适配器得以解决。 我们来举一个例子，鸭子（Dock）有飞（fly）和嘎嘎叫（quack）的行为，而火鸡虽然也有飞（fly）的行为，但是其叫声是咯咯的（gobble）。如果你非要火鸡也要实现嘎嘎叫（quack）这个动作，那我们可以复用鸭子的 quack 方法，但是具体的叫还应该是咯咯的，此时，我们就可以创建一个火鸡的适配器，以便让火鸡也支持 quack 方法，其内部还是要调用 gobble。 首先要先定义鸭子和火鸡的抽象行为，也就是各自的方法函数： //鸭子 var Duck = function() {}; Duck.prototype.fly = function() { throw new Error('该方法必须被重写!'); }; Duck.prototype.quack = function() { throw new Error('该方法必须被重写!'); }; //火鸡 var Turkey = function() {}; Turkey.prototype.fly = function() { throw new Error(' 该方法必须被重写 !'); }; Turkey.prototype.gobble = function() { throw new Error(' 该方法必须被重写 !'); }; //鸭子 var MallardDuck = function() { Duck.apply(this); }; MallardDuck.prototype = new Duck(); //原型是Duck MallardDuck.prototype.fly = function() { console.log('可以飞翔很长的距离!'); }; MallardDuck.prototype.quack = function() { console.log('嘎嘎！嘎嘎！'); }; //火鸡 var WildTurkey = function() { Turkey.apply(this); }; WildTurkey.prototype = new Turkey(); //原型是Turkey WildTurkey.prototype.fly = function() { console.log('飞翔的距离貌似有点短!'); }; WildTurkey.prototype.gobble = function() { console.log('咯咯！咯咯！'); }; 为了让火鸡也支持 quack 方法，我们创建了一个新的火鸡适配器TurkeyAdapter： var TurkeyAdapter = function(oTurkey) { Duck.apply(this); this.oTurkey = oTurkey; }; TurkeyAdapter.prototype = new Duck(); TurkeyAdapter.prototype.quack = function() { this.oTurkey.gobble(); }; TurkeyAdapter.prototype.fly = function() { var nFly = 0; var nLenFly = 5; for (; nFly &lt; nLenFly; ) { this.oTurkey.fly(); nFly = nFly + 1; } }; 该构造函数接受一个火鸡的实例对象，然后使用 Duck 进行 apply，其适配器原型是 Duck，然后要重新修改其原型的 quack 方法，以便内部调用 oTurkey.gobble()方法。其 fly 方法也做了一些改变，让火鸡连续飞 5 次（内部也是调用自身的 oTurkey.fly()方法）。 var oMallardDuck = new MallardDuck(); var oWildTurkey = new WildTurkey(); var oTurkeyAdapter = new TurkeyAdapter(oWildTurkey); //原有的鸭子行为 oMallardDuck.fly(); oMallardDuck.quack(); //原有的火鸡行为 oWildTurkey.fly(); oWildTurkey.gobble(); //适配器火鸡的行为（火鸡调用鸭子的方法名称） oTurkeyAdapter.fly(); oTurkeyAdapter.quack(); 三. 代理模式 由于一个对象不能直接引用另一个对象，所以需要代理对象在这两个对象之间起到中介的作用 // 先声明美女对象 var girl = function(name) { this.name = name; }; // 这是dudu var dudu = function(girl) { this.girl = girl; this.sendGift = function(gift) { alert('Hi ' + girl.name + ', dudu送你一个礼物：' + gift); }; }; // 大叔是代理 var proxyTom = function(girl) { this.girl = girl; this.sendGift = function(gift) { new dudu(girl).sendGift(gift); // 替dudu送花咯 }; }; var proxy = new proxyTom(new girl('酸奶小妹')); proxy.sendGift('999朵玫瑰'); 假如 dudu 要送酸奶小妹玫瑰花，却不知道她的联系方式或者不好意思，想委托大叔去送这些玫瑰，那大叔就是个代理 其实在日常开发中，我们遇到很多这种情况，比如跨域，之前总结过跨域的所有东西，其中的 jsonp，window.name 还是 location.hash 都是通过代理模式来实现的。 四. 装饰者模式 在不改变源对象的基础上，通过对其进行包装拓展使原有对象可以满足用户的更复杂需求 这里拿给输入框添加事件举例 var decorator = function(input, fn) { //获取时间源 var input = document.getElementById(input); if (typeof input.onclick === 'function') { //缓存事件源原有的回调函数 var oldClickFn = input.onclick; input.onclick = function(ev) { oldClickFn(); fn(); }; } else { input.onclick = fn; } }; 装饰着模式很简单，就是对原有对象的属性和方法的添加。相比于之前说的适配器模式是对原有对象的适配，添加的方法和原有的方法功能上大致相似。但是装饰着提供的方法和原有方法功能项则有一定的区别，且不需要去了解原有对象的功能。只要原封不动的去使用就行。不需要知道具体的实现细节。 五. 桥接模式 在系统沿着多个维度变化的时候，不增加起复杂度已达到解耦的目的 场景在我们日常开发中，需要对相同的逻辑做抽象的处理。桥接模式就是为了解决这类的需求。 桥接模式最主要的特点就是将实现层和抽象层解耦分离，是两部分可以独立变化 比如我们写一个跑步游戏，对于游戏中的人和精灵都是动作单元。而他们的动作也是非常的统一。比如人和精灵和球运动都是 x，y 坐标的改变，球的颜色和精灵的颜色绘制方式也非常的类似。 我们就可以将这些方法给抽象出来。 //运动单元 function Speed(x, y) { this.x = x; this.y = y; } Speed.prototype.run = function() { console.log('动起来'); }; // 着色单元 function Color(cl) { this.color = cl; } Color.prototype.draw = function() { console.log('绘制色彩'); }; // 变形单元 function Shape(ap) { this.shape = ap; } Shape.prototype.change = function() { console.log('改变形状'); }; //说话单元 function Speak(wd) { this.word = wd; } Speak.prototype.say = function() { console.log('请开始你的表演'); }; //创建球类，并且它可以运动可以着色 function Ball(x, y, c) { this.speed = new Speed(x, y); this.color = new Color(c); } Ball.prototype.init = function() { //实现运动和着色 this.speed.run(); this.color.draw(); }; function People(x, y, f) { this.speed = new Speed(x, y); this.speak = new Speak(f); } People.prototype.init = function() { this.speed.run(); this.speak.say(); }; //... //当我们实例化一个人物对象的时候，他就可以有对应的方法实现了 var p = new People(10, 12, '我是一个人'); p.init(); 六. 组合模式 又称部分-整体模式，将对象组合成树形结构以表示成“部分整体”的层次结构。组合模式使得用户对单个对象以及组合对象的使用具有一致性 场景我们平时开发过程中，一定会遇到这种情况：同时处理简单对象和由简单对象组成的复杂对象，这些简单对象和复杂对象会组合成树形结构，在客户端对其处理的时候要保持一致性。比如电商网站中的产品订单，每一张产品订单可能有多个子订单组合，比如操作系统的文件夹，每个文件夹有多个子文件夹或文件，我们作为用户对其进行复制，删除等操作时，不管是文件夹还是文件，对我们操作者来说是一样的。在这种场景下，就非常适合使用组合模式来实现。 组合模式主要有三个角色： 抽象组件（Component）：抽象类，主要定义了参与组合的对象的公共接口 子对象（Leaf）：组成组合对象的最基本对象 组合对象（Composite）：由子对象组合起来的复杂对象 理解组合模式的关键是要理解组合模式对单个对象和组合对象使用的一致性，我们接下来说说组合模式的实现加深理解。 // 抽象一个虚拟父类 var News = function() { this.children = []; this.element = null; }; News.prototype = { init: function() { throw new Error('请重写你的方法'); }, add: function() { throw new Error('请重写你的方法'); }, getElement: function() { throw new Error('请重写你的方法'); } }; function iniheritObject(o) { function F() {} F.prototype = o; return new F(); } function inheritPrototype(subClass, superClass) { var p = iniheritObject(superClass.prototype); p.constructor = subClass; subClass.prototype = p; } //容器类 var Container = function(id, parent) { News.call(this); this.id = id; this.parent = parent; this.init(); }; //寄生式继承父类原型方法 inheritPrototype(Container, News); Container.prototype.init = function() { this.element = document.createElement('ul'); this.element.id = this.id; this.element.className = 'new-container'; }; Container.prototype.add = function(child) { this.children.push(child); this.element.appendChild(child.getElement()); return this; }; Container.prototype.getElement = function() { return this.element; }; Container.prototype.show = function() { this.parent.appendChild(this.element); }; //同样下一层极的行成员集合类以及后面新闻组合体类 var Item = function(classname) { News.call(this); this.classname = classname; this.init(); }; inheritPrototype(Item, News); Item.prototype.init = function() { this.element = document.createElement('li'); this.element.className = this.classname; }; Item.prototype.add = function(child) { this.children.push(child); this.element.appendChild(child.getElement()); return this; }; Item.prototype.getElement = function() { return this.element; }; var NewsGroup = function(className) { News.call(this); this.classname = classname || ''; this.init(); }; inheritPrototype(NewsGroup, News); NewsGroup.prototype.init = function() { this.element = document.createElement('div'); this.element.className = this.classname; }; NewsGroup.prototype.add = function(child) { this.children.push(child); this.element.appendChild(child.getElement()); return this; }; NewsGroup.prototype.getElement = function() { return this.element; }; 所以后面我们在使用的时候，创建新闻类，利用之前定义的组合元素去组合就可以了。 七. 享元模式 运用共享技术有效的支持大量细粒度对象，避免对象之间拥有相同内容造成的不必要开销 主要用来优化程序的性能，适合解决大量类似的对象产生的性能问题。享元模式通过分析应用程序的对象，将其解析为内在数据和外在数据，减少对象数量，从而提高程序的性能。 基础知识享元模式通过共享大量的细粒度的对象，减少对象的数量，从而减少对象的内存，提高应用程序的性能。其基本思想就是分解现有类似对象的组成，将其展开为可以共享的内在数据和不可共享的外在数据，我们称内在数据的对象为享元对象。通常还需要一个工厂类来维护内在数据。 在 JS 中，享元模式主要有下面几个角色组成： 客户端：用来调用享元工厂来获取内在数据的类，通常是应用程序所需的对象 享元工厂：用来维护享元数据的类 享元类：保持内在数据的类 我们举个例子进行说明：苹果公司批量生产 iphone，iphone 的大部分数据比如型号，屏幕都是一样，少数部分数据比如内存有分 16G,32G 等。未使用享元模式前，我们写代码如下： function Iphone(model, screen, memory, SN) { this.model = model; this.screen = screen; this.memory = memory; this.SN = SN; } var phones = []; for (var i = 0; i &lt; 1000000; i++) { var memory = i % 2 == 0 ? 16 : 32; phones.push(new Iphone('iphone6s', 5.0, memory, i)); } 这段代码中，创建了一百万个 iphone，每个 iphone 都独立申请一个内存。但是我们仔细观察可以看到，大部分 iphone 都是类似的，只是内存和序列号不一样，如果是一个对性能要求比较高的程序，我们就要考虑去优化它。 大量相似对象的程序，我们就可以考虑用享元模式去优化它，我们分析出大部分的 iphone 的型号，屏幕，内存都是一样的，那这部分数据就可以公用，就是享元模式中的内在数据，定义享元类如下： function IphoneFlyweight(model, screen, memory) { this.model = model; this.screen = screen; this.memory = memory; } 我们定义了 iphone 的享元类，其中包含型号，屏幕和内存三个数据。我们还需要一个享元工厂来维护这些数据： var flyweightFactory = (function() { var iphones = {}; return { get: function(model, screen, memory) { var key = model + screen + memory; if (!iphones[key]) { iphones[key] = new IphoneFlyweight(model, screen, memory); } return iphones[key]; } }; })(); 在这个工厂中，我们定义了一个字典来保存享元对象，提供一个方法根据参数来获取享元对象，如果字典中有则直接返回，没有则创建一个返回。 接着我们创建一个客户端类，这个客户端类就是修改自 iphone 类： function Iphone(model, screen, memory, SN) { this.flyweight = flyweightFactory.get(model, screen, memory); this.SN = SN; } 然后我们依旧像之前那样生成多个 iphone var phones = []; for (var i = 0; i &lt; 1000000; i++) { var memory = i % 2 == 0 ? 16 : 32; phones.push(new Iphone('iphone6s', 5.0, memory, i)); } console.log(phones); 这里的关键就在于 Iphone 构造函数里面的 this.flyweight = flyweightFactory.get(model, screen, memory) 。这句代码通过享元工厂去获取享元数据，而在享元工厂里面，如果已经存在相同数据的对象则会直接返回对象，多个 iphone 对象共享这部分相同的数据，所以原本类似的数据已经大大减少，减少的内存的占用。 在 DOM 中的使用&lt;ul class=\"menu\"> &lt;li class=\"item\">选项1&lt;/li> &lt;li class=\"item\">选项2&lt;/li> &lt;li class=\"item\">选项3&lt;/li> &lt;li class=\"item\">选项4&lt;/li> &lt;li class=\"item\">选项5&lt;/li> &lt;li class=\"item\">选项6&lt;/li> &lt;/ul> 点击菜单项，进行相应的操作，我们通过 jQuery 来绑定事件，一般会这么做： $('.item').on('click', function() { console.log($(this).text()); }); 给每个列表项绑定事件，点击输出相应的文本。这样看暂时没有什么问题，但是如果是一个很长的列表，尤其是在移动端特别长的列表时，就会有性能问题，因为每个项都绑定了事件，都占用了内存。但是这些事件处理程序其实都是很类似的，我们就要对其优化。 $('.menu').on('click', '.item', function() { console.log($(this).text()); }); 通过这种方式进行事件绑定，可以减少事件处理程序的数量，这种方式叫做事件委托，也是运用了享元模式的原理。事件处理程序是公用的内在部分，每个菜单项各自的文本就是外在部分。我们简单说下事件委托的原理：点击菜单项，事件会从 li 元素冒泡到 ul 元素，我们绑定事件到 ul 上，实际上就绑定了一个事件，然后通过事件参数 event 里面的 target 来判断点击的具体是哪一个元素，比如低级第一个 li 元素，event.target 就是 li，这样就能拿到具体的点击元素了，就可以根据不同元素进行不同的处理。 参考：Javascript 设计模式理论与实战：享元模式","tags":[{"name":"javascript","slug":"javascript","permalink":"http://coder.liusixin.cn/tags/javascript/"},{"name":"编程笔记","slug":"编程笔记","permalink":"http://coder.liusixin.cn/tags/编程笔记/"},{"name":"设计模式","slug":"设计模式","permalink":"http://coder.liusixin.cn/tags/设计模式/"}]},{"title":"JavaScript设计模式--创建型设计模式","date":"2017-11-04T15:14:55.000Z","path":"posts/3bf0239/","text":"该系列参考自 《JavaScript 设计模式》 以及 汤姆大叔的博文 深入理解 JavaScript 系列 前言 简单工厂模式 工厂方法模式 抽象工厂模式 建造者模式 原型模式 单例模式 一. 简单工厂模式 简单工厂模式的概念就是创建对象，不仅如此，简单工厂模式还可以用来创建相似的对象。 场景如果你想创建一些书，那么这些书都有一些相似的地方，比如目录、页码等。也有很多不同的地方， 如书名、出版时间、书的类型等，对于创建的对象相似的属性当然好处理，对于不同的属性就要有针对的修改处理了。 //工厂模式 function createBook(name, time, type) { //创建一个对象，并且对对象拓展属性和方法 var o = new Object(); o.name = name; o.time = time; o.type = type; o.getName = function() { console.log(this.name); }; //将对象返回 return o; } var book1 = createBook('js book', '2017/11/16', 'JS'); var book2 = createBook('css book', '2017/11/13', 'CSS'); book1.getName(); book2.getName(); var Basketball = function() { this.info = '美国篮球'; }; Basketball.prototype = { constructor: Basketball, getMember: function() { console.log('每队需要5个成员'); }, getBallSize: function() { console.log('这个篮球还是很大的'); } }; var Football = function() { this.info = '这是足球'; }; Football.prototype = { constructor: Football, getMember: function() { console.log('足球每队需要十一个人'); }, getBallSize: function() { console.log('足球我不喜欢'); } }; var Tennis = function() { this.info = '网球貌似现在还是蛮流行的'; }; Tennis.prototype = { constructor: Tennis, getMember: function() { console.log('一对一，二对二咯'); }, getBallSize: function() { console.log('网球还是比较小的'); } }; //球类工厂 var sportsFactory = function(name) { switch (name) { case 'NBA': return new Basketball(); break; case 'wordCup': return new Football(); break; default: return new Tennis(); } }; 这种简单工厂模式非常的像寄生式继承，只不过这里 o 没有继承任何对象和类。 简单工厂的用途就是创建对象，或者创建相似的对象。 二. 工厂方法模式 工厂方法模式本意是将实际创建对象的工作推迟到子类当中。这样核心类就成为了抽象类。 前言在之前，我们介绍过简单工厂设计模式，简单工厂设计模式存在唯一的工厂类，它的优点是所有产品类的实例化集中管理，便于理解。当产品数量较少，且不会经常发生变化时，我们当然可以直接使用简单工厂模式，但是有的时候，需求是在时刻变化的，产品类也可能随之增加，如果使用简单工厂模式，就避免不了去修改工厂类的代码。要解决这个问题，就得使用今天所讲的，工厂方法模式。 基本概念工厂方法模式：不再有一个唯一的工厂类就创建产品，而是将不同的产品交给对应的工厂子类去实现。每个产品由负责生产的子工厂来创造。如果添加新的产品，需要做的是添加新的子工厂和产品，而不需要修改其他的工厂代码。 工厂方法模式主要有三种类组成： 抽象工厂类：负责定义创建产品的公共接口 产品子工厂：继承抽象工厂类，实现抽象工厂类提供的接口 每一种产品各自的产品类 安全模式类安全模式类就是可以屏蔽对类的错误使用而造成的后果。说白了，就是在构造函数开始时先判断当前对象 this 指向是不是类。 var Demo = function() { if (!(this instanceof Demo)) { return new Demo(); } }; Demo.prototype.show = function() { console.log('show'); }; var d = Demo(); d.show(); 采用工厂方法模式简单工厂模式仅仅适用于创建比较少的对象，如果需要创建多个类，并且会经常修改，像我们之前说的简单工厂的方法就不是很实用了，因为如果我要多添加一个类，就需要修改两个地方，所以这里我们采用工厂方法模式 var Factory = function(type, content) { if (this instanceof Factory) { var temp = new this[type](content); } else { return new Factory(type, content); } }; //在工厂原型中设置创建所有类型数据对象的基类 Factory.prototype = { constructor: Factory, Java: function(content) { //... }, JavaScript: function(content) { //... }, UI: function(content) { this.content = content; (function(content) { var div = document.createElement('div'); div.innerHTML = content; div.style.border = '1px solid red'; document.getElementById(content).appendChild(div); })(content); } }; 如上，我们就可以创建多个类了 var data = [ { type: 'JavaScript', content: 'Javascript还是很重要的' }, { type: 'Java', content: 'Java培训哪家强' }, { type: 'UI', content: 'UI...' } ]; for (var i = 0, length = data.length; i++; i &lt; data.length) { Factory(data[i].type, data[i].content); } 三. 抽象工厂模式 通过对类的工厂抽象使其业务用于对产品类簇的创建，而不负责创建某一类产品的实例。也就是说我们要创建一个抽象类。这也是面向对象的开发语言中一种很常见的开发模式。 场景var Car = function() {}; Car.prototype.getPrice = function() { return new Error('抽象方法不能调用，需自行实现'); }; Car.prototype.getSpeed = function() { return new Error('抽象方法不能调用，需自行实现'); }; 由于 JavaScript 在没有 abstract 的具体实现，所以我们需要如上手动实现，也即是在创建这个类的时候，要求使用这些方法，我们需要手动去重写它，而不能继承使用。因为 在大型的应用中，总有一些子类去继承一些父类，这些父类经常会定义一些必要的方法，但是不会具体的去实现，会去要求子类自行实现。如果子类没有重写这些方法而去调用他，就会报错。 // 抽象工厂方法 var VehicleFactory = function(subType, superType) { //判断抽象工厂中是否有该抽象类 if (typeof VehicleFactory[superType] === 'function') { //缓存类 function F() {} //继承父类属性和方法 F.prototype = new VehicleFactory[superType](); //将子类的constructor指向子类 subType.constructor = subType; //子类原型继承父类 subType.prototype = new F(); } else { return new Error('未创建该抽象类'); } }; //小汽车抽象类 VehicleFactory.Car = function() { this.type = 'car'; }; VehicleFactory.Car.prototype = { getPrice: function() { return new Error('抽象方法不能调用'); }, getSpeed: function() { return new Error('抽象方法不能调用'); } }; //公共汽车抽象类 VehicleFactory.Bus = function() { this.type = 'Bus'; }; VehicleFactory.Bus.prototype = { getPrice: function() { return new Error('抽象方法不能调用'); }, getSpeed: function() { return new Error('抽象方法不能调用'); } }; //大卡车抽象类 VehicleFactory.Trunk = function() { this.type = 'Trunk'; }; VehicleFactory.Trunk.prototype = { getPrice: function() { return new Error('抽象方法不能调用'); }, getSpeed: function() { return new Error('抽象方法不能调用'); } }; //子类 var BMW = function(price, speed) { this.price = price; this.speed = speed; }; VehicleFactory(BMW, 'Car'); BMW.prototype.getPrice = function() { return this.price; }; BMW.prototype.getSpeed = function() { return this.speed; }; //... var three = new BMW('35w', '200'); three.getSpeed(); console.log(three.getPrice()); 我们可以看出，抽象工厂其实是实现子类继承父类的方法，在这个方法里，我们需要传递子类以及需要被继承的父类的名称，并且在抽象工厂方法中，又增加了一次对抽象类存在性的一次判断，然后通过寄生式继承，在继承中我们是通过 new 关键字复制了父类的一个实例，因为我们不仅仅需要继承父类原型上的方法，还需要继承父类的属性。所以通过 new 关键字将父类的构造函数执行一遍来复制父类构造函数中的属性和方法。 通过抽象工厂，我们就能知道每一个子类到底是哪一种类别了。 同时注意，抽象类中定义的方法这是显示定义一些功能，但是没有具体的实现，而一个对象是应该具备一套完整的功能的。所以用抽象类创建的对象当然也是抽象的。所以我们还不能直接用它来创建类的实例。 四. 建造者模式 将一个复杂对象的构建层和表示层相分离，同样的构建过程可以采用不同的表示。 场景工厂模式主要是用来创建对象的实例（简单工厂模式，工厂方法模式）或者是类簇（抽象工厂模式），关心的是最终的产出是什么，所以工厂模式我们得到的是对象的实例或者对象的类簇。然而建造者模式在创建对象的过程中则更为复杂一些。虽然目的也是为了创建对象，但是更关心的创建对象的整个过程或者说是每一个细节。 比如创建一个人，我们创建的结果不仅仅是得到一个人的实例，还要关注创建人的时候，这个人是男是女，穿什么衣服带什么帽子等等。 var Human = function(param) { this.skill = (param &amp;&amp; param.skill) || '保密'; this.hobby = (param &amp;&amp; param.hobby) || '保密'; }; Human.prototype = { constructor: Human, getSill: function() { return this.skill; }, getHobby: function() { return this.hobby; } }; var Name = function(name) { var that = this; (function(name, that) { this.wholeName = name; if (name.indexOf(' ') > -1) { that.firstName = name.slice(0, name.indexOf(' ')); that.secondName = name.slice(name.indexOf(' ')); } })(name, that); }; var Work = function(work) { var that = this; (function(work, that) { switch (work) { case 'code': that.work = '工程师'; that.wordDesc = '代码使我快乐'; break; case 'UE': that.work = '设计师'; that.wordDesc = '设计更似艺术'; break; default: that.work = work; that.wordDesc = '对不起，我们还不清楚你所选择职位的相关描述'; } })(work, that); }; //更换期望职位以及描述 Work.prototype.changeWork = function(work) { this.work = work; }; Work.prototype.changeDesc = function(desc) { this.wordDesc = desc; }; //创建一个应聘者 var Person = function(name, work) { var _person = new Human(); _person.name = new Name(name); _person.work = new Work(work); return _person; }; var person = new Person('Liusixin', 'code'); console.log(person.skill); console.log(person.hobby); console.info(person.work); person.work.changeDesc('一撸代码就疯狂'); console.info(person.work); 五. 原型模式 用原型实例指向创建对象的类，适用于创建新的对象的类共享原型对象的属性和方法。这种继承是一种基于对属性和方法的共享而不是复制。 场景在创建的类中，存在基类，起定义的方法和属性能够被子类所继承和使用。 原型模式就是将可复用的、可共享的、消耗大的从基类中提取出来然后放到原型中，然后子类通过组合继承或者寄生组合式继承将方法和属性继承下来。子类中对于那些需要重写的方法进行重写，这样，子类 创建的对象既有子类的属性和方法也共享着基类的属性和方法。 示例拿网页中轮播图举例，有的是渐变效果，有的是滚动，有的带有箭头。。。所以这里我们可以创建一个基类，轮播图，然后再根据不同的需求再去修改。 //图片轮播图类 var LoopImages = function(imgArr, container) { this.imageArr = imgArr; //轮播图片数组 this.container = container; //轮播图片容器 this.createImage = function() {}; //创建轮播图 this.changeImage = function() {}; //轮播图切换 }; //上下切换 var SlideLoopImage = function(imgArr, container) { //构造函数继承图片轮播类 LoopImages.call(this, imgArr, container); //重写继承的图片切换方法 this.changeImage = function() { console.log('上下切换的方式'); }; }; //渐隐切换 var FadeLoopImg = function(imgArr, container, arrow) { LoopImages.call(this, imgArr, container); //切换箭头私有变量 this.arrow = arrow; this.changeImage = function() { console.log('渐隐的切换方式'); }; }; //实例化一个 var fadeImg = new FadeLoopImg(['01.jpg', '02.jpg', '03.jpg'], 'slide', [ 'left.jpg', 'right.jpg' ]); 但是如上的写法 ，其实还有一种更加优化的方法。首先看基类，作为基类是要被子类继承的，那么此时将属性和方法都写到基类的构造函数里会有一些问题。 比如每一次创建子类继承都要创建一次父类，如果父类的构造函数的创建过程中存在很多耗时较长的逻辑，这样的话性能消耗还是蛮大的。为了提高性能，我们可以使用共享机制。 对于每一次创建的一些简单而又差异化的属性我们可以放到构造函数中，而把一些消耗资源比较大的方法放到基类的原型中。这样避免很多不必要的消耗。 var LoopImages = function(imgArr, container) { this.imageArr = imgArr; this.container = container; }; LoopImages.prototype = { crateImage: function() { console.log('创建轮播图方法'); }, changeImage: function() { console.log('图片切换方法'); } }; //上下切换 var SlideloopImg = function(imgArr, container) { LoopImages.call(this, imgArr, container); }; SlideloopImg.prototype = new LoopImages(); SlideloopImg.prototype.changeImage = function() { console.log('上下切换的方式'); }; var FadeLoopImg = function(imgArr, container, arrow) { this.arrow = arrow; LoopImages.call(this, imgArr, container); }; FadeLoopImg.prototype = new LoopImages(); FadeLoopImg.prototype.changeImage = function() { console.log('渐隐切换方式'); }; 六. 单例模式 单例模式又称为单体模式，其实就是只允许实例化一个对象，有时我们也可以用一个对象类规划命名空间，仅仅有条的管理对象的属性和方法。 //命名空间管理 var obj = { g: function(id) { return document.getElementById(id); }, css: function(id, key, value) { this.g(id).style[key] = value; } //... }; //模块分明 var A = { Util: { util_method1: function() {}, util_method2: function() {} }, Tool: { tool_method1: function() {}, tool_method2: function() {} } //... }; //惰性单例 var LazySingle = (function() { //单例实例引用 var _instance = null; //单例 function Single() { return { publicMethod: function() {}, publicProperty: '1.0' }; } //获取单例接口 return function() { if (!_instance) { _instance = Single(); } //返回单例 return _instance; }; })();","tags":[{"name":"javascript","slug":"javascript","permalink":"http://coder.liusixin.cn/tags/javascript/"},{"name":"编程笔记","slug":"编程笔记","permalink":"http://coder.liusixin.cn/tags/编程笔记/"},{"name":"设计模式","slug":"设计模式","permalink":"http://coder.liusixin.cn/tags/设计模式/"}]},{"title":"JavaScript设计模式--面向对象的JS","date":"2017-11-03T13:31:55.000Z","path":"posts/b48d1f6c/","text":"该系列参考自 《JavaScript 设计模式》 以及 汤姆大叔的博文 深入理解 JavaScript 系列 封装创建一个类在 JavaScript 中创建一个对象很容易，首先声明一个函数保存在一个变量里。按编程习惯一般将这个变量名的首字母大写。然后内部通过 this 变量来添加属性或者方法来实现对类添加属性和行为。 var Book = function(id, bookname, price) { this.id = id; this.bookename = bookname; this.price = price; }; 当然，我们也可以通过在类的原型上添加属性和方法。有两种方式： Book.prototype.display = function() { //展示展示这本书 }; //或者 Book.prototype = { display: function() { //展示这本书 } }; 这样，我们就将我们所需要的方法和属性都封装到我们封装的 Book 类里面了，当使用这些功能和方法的时候，我们不能直接使用这些类，而是需要使用关键字 new 来实例化新的对象。 var book = new Book(10, 'JavaScript设计模式', 20); console.log(book.bookname); 注意，通过 this 添加的属性和方法是在当前对象上添加的，然而 JavaScript 是一种基于原型的语言，所以每创建一个对象时，他都有一个 prototype 用于指向其继承的属性、方法。这样通过 prototype 继承的方法并不是对象自身的，所以在使用这些方法时，需要通过 prototype 一层一层往上查找。 简单的说，通过 this 定的属性和方法是该对象自身拥有的，所以我们每次通过类创建的一个新对象时，this 执行的属性和方法都会得到相应的创建，而通过 prototype 继承的属性和方法是每一个对象通过 prototype 访问到的。所以我们每一次通过类创建一个新对象时，这些属性和方法不会再次创建。 如上图，实例的proto属性指向原型。原型的 constructor 属性指向构造函数。当创建一个函数或者对象时都会为其创建一个原型对象 prototype，在 prototype 对象中，又会像函数中创建 this 一样创建一个 constructor 属性，这个属性指向的就是拥有整个原型对象的函数或者对象。 属性与方法封装由于 JavaScript 是函数级作用域，申明在函数内部的变量或者方法在外部是访问不到的，通过此特性即可创建类的私有变量和私有方法。然而在函数内部通过 this 创建的属性和方法，在类创建对象时，每个对象自身都拥有一份，并且在外部访问到。因此用 this 创建的属性可以看做是对象的公有属性和公有方法。而通过 this 创建的方法不但可以访问这些对象的公有属性和公有方法，还可以访问类自身的私有属性和私有方法，我们称之为特权方法。 在创建对象时，我们可以使用这些特权方法来初始化实例对象的一些属性，因此这些在创建对象时，调用的特权方法可以看做是类的构造器 var Book = function(id, name, price) { //私有属性 var num = 1; //私有方法 function checkId() {} //特权方法 this.getName = function() {}; this.getPrice = function() {}; this.setName = function() {}; this.setPrice = function() {}; //对象公有属性 this.id = id; //对象公有方法 this.copy = function() {}; //构造器 this.setName(name); this.setPrice(price); }; 通过 new 关键字创建新对象时，由于类外面通过点语法添加的属性和方法没有执行到，所以新创建的对象中无法获取他们，当时可以通过类来使用。因此我们称之为静态共有属性和静态共有方法。而通过类的 prototype 创建的属性和方法在类的实例中可以通过 this 访问到的（新创建对象的ptoto指向类的原型所指的对象），所以我们将 prototype 中的属性和方法称之为共有属性和方法 //静态的共有属性和方法，对象不能访问 Book.isChinese = true; Book.setTime = function() { console.log('new time'); }; Book.prototype = function() { //共有属性和方法 isBook: true; display = function() {}; }; 通过 new 关键字创建的对象，实际上是对新对象 this 的不断赋值，并将 prototype 指向类的 prototype 所指向的对象，而类的构造函数外面的通过点语法添加的属性和方法不会添加到新创建的对象上去。 闭包的实现有时候我们经常将类的静态变量通过闭包来实现 var Book = (function() { //静态私有变量、静态私有方法 var bookNum = 0; function checkBook(name) {} //返回构造函数 return function(newId, newName, newPrice) { //私有变量、方法 var name, price; function checkId(id) {} //特权方法 this.getName = function() {}; this.getPrice = function() {}; this.setName = function() {}; this.setPrice = function() {}; //公有属性、公有方法 this.id = newId; this.copy = function() {}; bookNum++; if (bookNum > 100) { throw new Error('我们仅出版了100本书'); } //构造器 this.setNmae(name); this.setPrice(price); }; })(); Book.prototype = { //静态共有属性、静态公有方法 isJsBook: false, display: function() {} }; 闭包就是有权访问另外一个函数作用域中变量的函数，即在一个函数内部创建另外一个函数。我们将这个闭包作为创建对象的构造函数，这样，它既是闭包又是可实例化对象的函数，即可访问到类作用域中的变量。但是在闭包外部添加原型属性和方法看上去似乎脱离闭包这个类，所以咱们可以用下面的方式来搞一搞 继承类式继承function SuperClass() { this.superValue = true; } SuperClass.prototype.getSuperValue = function() { return this.superValue; }; function SubClass() { this.subValue = false; } SubClass.prototype = new SubClass(); SubClass.prototype.getSubValue = function() { return this.subValue; }; 继承非常简单，就是声明两个类而已，不过类式继承需要将第一个类的实例赋值给第二个类的原型，因为类的原型对象作用就是为类的原型添加共有方法，但是类不能直接访问这些属性和方法，必须通过原型 prototype 来访问。而我们实例化一个父类的时候，新创建的对象复制了父类构造函数的属性和方法并将原型__proto__指向父类的原型对象，这样就拥有了父类原型对象的属性和方法，并且这个新创建的对象可以直接访父类原型对象上的属性和方法。而且新创建的对象不仅仅可以访问父类原型上的属性和方法，同样可以访问父类构造函数中复制的属性和方法。将这个对象赋值给子类的原型，那么这个子类的原型同样可以访问父类原型上的属性和方法与从父类构造函数中复制的属性和方法。 另外，我们可以通过instanceof来检测某个对象是否为某个类的实例 var instance = new SubClass(); console.log(instance instanceof SuperClass); // false console.log(instance instanceof SubClass); // true console.log(SubClass instanceof SuperClass); // false 注意，instanceof 是判断对象是否是后面类的实例，它并不表示二者的继承 console.log(SubClass.prototype instanceof SuperClass); // false 但是这种类式继承有两个缺点，其一，由于子类通过其原型 prototype 对父类实例化，继承了父类，所以说父类中如果共有属性是引用类型，就会在子类中被所有的实例所共享，因此一个子类的实例更改子类原型从父类构造函数中继承的共有属性就会直接影响到其他的子类。 function SuperClass() { this.books = ['js', 'css']; } function SubClass() {} SubClass.prototype = new SuperClass(); var instance1 = new SubClass(); var instance2 = new SubClass(); console.log(instance2.books); // [\"js\", \"css\"] instance1.books.push('html'); console.log(instance1.books, instance2.books); // [\"js\", \"css\", \"html\"] 其二，由于子类实现的继承是靠其原型 prototype 对父类进行实例化实现的，因此在创建父类的时候，是无法向父类传递参数的。因而在实例化父类的时候也无法对父类构造函数内的属性进行初始化 构造函数继承function SuperClass(id) { this.books = ['js', 'css']; this.id = id; } SuperClass.prototype.showBooks = function() { console.log(this.books); }; function SubClass(id) { //继承父类 SuperClass.call(this, id); } //创建第一个子类实例 var instance1 = new SubClass(10); //创建第二个子类实例 var instance2 = new SubClass(11); instance1.books.push('html'); console.log(instance1); console.log(instance2); instance1.showBooks(); //TypeError 如上，SuperClass.call(this,id) 当然就是构造函数继承的核心语句了，由于 call 这个方法可以更改函数的作用环境，因此在子类中，对superClass调用这个方法就是将子类中的变量在父类中执行一遍。由于父类中给 this 绑定属性，因此子类自然也就继承父类的共有属性。由于这种类型的继承没有涉及到原型prototype，所以父类的原型方法自然不会被子类继承，而如果想被子类继承，就必须放到构造函数中，这样创建出来的每一个实例都会单独的拥有一份而不能共用，这样就违背了代码复用的原则，所以综合上述两种，我们提出了组合式继承方法 组合继承类式继承是通过子类原型 prototype 对父类实例化实现的，构造函数继承是通过在子类的构造函数作用环境中执行一次父类的构造函数来实现的。 function SuperClass(name) { this.name = name; this.books = ['Js', 'CSS']; } SuperClass.prototype.getBooks = function() { console.log(this.books); }; function SubClass(name, time) { SuperClass.call(this, name); this.time = time; } SubClass.prototype = new SuperClass(); SubClass.prototype.getTime = function() { console.log(this.time); }; 如上，我们就解决了之前说到的一些问题，但是从代码看，这个 SuperClass 的构造函数执行了两遍。 原型式继承原型式继承大致的实现方式是这个样子的 function inheritObject(o) { //申明一个过渡对象 function F() {} //过渡对象的原型继承父对象 F.prototype = o; //返回过渡对象的实例，该对象的原型继承了父对象 return new F(); } 其实这种方式和类式继承非常的相似，他只是对类式继承的一个封装，其中的过渡对象就相当于类式继承的子类，只不过在原型继承中作为一个普通的过渡对象存在，目的是为了创建要返回的新的实例对象。 var book = { name: 'js book', likeBook: ['css Book', 'html book'] }; var newBook = inheritObject(book); newBook.name = 'ajax book'; newBook.likeBook.push('react book'); var otherBook = inheritObject(book); otherBook.name = 'canvas book'; otherBook.likeBook.push('node book'); console.log(newBook, otherBook); 如上代码我们可以看出，原型式继承和类式继承一个样子，对于引用类型的变量，还是存在子类实例共享的情况。 所以，我们还有下面的寄生式继承 寄生式继承function inheritObject(o) { //申明一个过渡对象 function F() {} //过渡对象的原型继承父对象 F.prototype = o; //返回过渡对象的实例，该对象的原型继承了父对象 return new F(); } var book = { name: 'js book', likeBook: ['html book', 'css book'] }; function createBook(obj) { //通过原型方式创建新的对象 var o = new inheritObject(obj); // 拓展新对象 o.getName = function(name) { console.log(name); }; // 返回拓展后的新对象 return o; } 其实寄生式继承就是对原型继承的拓展，一个二次封装的过程，这样新创建的对象不仅仅有父类的属性和方法，还新增了别的属性和方法。 寄生组合式继承回到之前的组合式继承，那时候我们将类式继承和构造函数继承组合使用，但是存在的问题就是子类不是父类的实例，而子类的原型是父类的实例，所以才有了寄生组合式继承。 而寄生组合式继承是寄生式继承和构造函数继承的组合。但是这里寄生式继承有些特殊，这里他处理不是对象，而是类的原型。 function inheritPrototype(subClass, superClass) { // 复制一份父类的原型副本到变量中 var p = inheritObject(superClass.prototype); // 修正因为重写子类的原型导致子类的constructor属性被修改 p.constructor = subClass; // 设置子类原型 subClass.prototype = p; } 组合式继承中，通过构造函数继承的属性和方法都是没有问题的，所以这里我们主要探究通过寄生式继承重新继承父类的原型。我们需要继承的仅仅是父类的原型，不用去调用父类的构造函数。换句话说，在构造函数继承中，我们已经调用了父类的构造函数。因此我们需要的就是父类的原型对象的一个副本，而这个副本我们可以通过原型继承拿到，但是这么直接赋值给子类会有问题，因为对父类原型对象复制得到的复制对象 p 中的 constructor 属性指向的不是 subClass 子类对象，因此在寄生式继承中要对复制对象 p 做一次增强，修复起 constructor 属性指向性不正确的问题，最后将得到的复制对象 p 赋值给子类原型，这样子类的原型就继承了父类的原型并且没有执行父类的构造函数。 function inheritPrototype(subClass, superClass) { // 复制一份父类的原型副本到变量中 var p = inheritObject(superClass.prototype); // 修正因为重写子类的原型导致子类的constructor属性被修改 p.constructor = subClass; // 设置子类原型 subClass.prototype = p; } function inheritObject(o) { //申明一个过渡对象 function F() {} //过渡对象的原型继承父对象 F.prototype = o; //返回过渡对象的实例，该对象的原型继承了父对象 return new F(); } function SuperClass(name) { this.name = name; this.books = ['js book', 'css book']; } SuperClass.prototype.getName = function() { console.log(this.name); }; function SubClass(name, time) { SuperClass.call(this, name); this.time = time; } inheritPrototype(SubClass, SuperClass); SubClass.prototype.getTime = function() { console.log(this.time); }; var instance1 = new SubClass('React', '2017/11/11'); var instance2 = new SubClass('Js', '2018/22/33'); instance1.books.push('test book'); console.log(instance1.books, instance2.books); instance2.getName(); instance2.getTime(); 这种方式继承其实如上图所示，其中最大的改变就是子类原型中的处理，被赋予父类原型中的一个引用，这是一个对象，因此有一点你需要注意，就是子类在想添加原型方法必须通过prototype.来添加，否则直接赋予对象就会覆盖从父类原型继承的对象了。 多继承由于 JavaScript 中的继承是通过原型链来实现的，只有一条原型链，所以理论上来说是实现不了继承多个父类的。但是我们可以通过一些小技巧，来实现一个类似的多继承 var extend = function(target, source) { // 遍历源对象中的属性 for (var property in source) { //将源对象中的属性复制到目标对象中 target[property] = source[property]; } //返回目标对象 return target; }; 当然，此处我们实现的这是浅拷贝，对于引用类型的它还是无能为力的。jquery 中实现了深拷贝，就是将源对象中的引用类型的属性再执行一遍 extend 方法而实现。这里我们实现的比较简单。 var book = { name: 'javascript 设计模式', alike: ['css', 'html'] } var another = { color: 'blue' }; extend(another, book); console.log(another.name); console.log(another.alike); another.alike.push('React'); another.name = '设计模式'； console.log(another, book); 多态多态，其实就是同一个方法多种的调用方式，在 JavaScript 中其实有很多种实现方式的。只不过要对传入的参数进行判断以实现多种的调用方式。","tags":[{"name":"javascript","slug":"javascript","permalink":"http://coder.liusixin.cn/tags/javascript/"},{"name":"编程笔记","slug":"编程笔记","permalink":"http://coder.liusixin.cn/tags/编程笔记/"},{"name":"设计模式","slug":"设计模式","permalink":"http://coder.liusixin.cn/tags/设计模式/"}]},{"title":"Javascript面向对象总结","date":"2017-10-15T05:32:32.000Z","path":"posts/3d2ababd/","text":"本文内容是复习红宝书中面向对象章节以及各类博客的总结篇 前言对象(Object)应该算是 js 中最为重要的部分，也是 js 中非常难懂晦涩的一部分。更是面试以及框架设计中出没。 对象属性属性类型简单的说，对象拥有四个属性: [[Configurable]]:是否可以通过 delete 删除，能否修改属性的特性。直白点：是否可配置，默认为 true [[Enumerable]]:枚举性，表示是否可以通过 for-in 循环返回，默认为 true [[Writable]]:可写性：是否可以修改属性的值，默认为 true [[Value]]:包含属性的值，也就是对应的可读性。 默认为 undefined 如果要修改属性默认的特性，必须通过Object.defineProperty()方法。大致如下： var animal = {}; Object.defineProperty(animal,\"name\",{ writable:false, value: 'dog'; }); console.log(animal.name);//dog animal.name = 'cat'; console.log(animal.name);//dog 从上面的实例大家也能看出，在调用Object.defineProperty()方法后，如果不指定 configurable、enumerable、writable 特性的值时，默认为 FALSE。 访问器属性 访问器属性不包含数据值，但是包含 getter 和 setter 函数。在读取访问器属性时，会调用 getter 函数，这个函数负责返回有效值。在写入访问器属性时，回到用 setter 函数并传入新值。 [[Configurable]]:表示是否可以通过 delete 删除。默认为 TRUE [[Enumerable]]:同上面介绍的 Enumerable 一样，默认为 true [[Get]]:读取数据时候调用的方法。默认为 undefined [[Set]]:在写入属性值得时候默认调用的方法。默认为 undefined 看个例子（来自于红宝石）: const book = { _year: 2012, edition: 1 }; Object.defineProperty(book, 'year', { get() { return this._year; }, set(value) { if (value > 2012) { (this._year = value), this.edition++; } } }); book.year = 2013; console.log(book.edition); // 2 其实对于多个属性的定义，我们可以使用Object.defineProperties方法。然后对于读取属性的特性我们可以使用Object.getOwnPropertyDescriptor()方法。详细内容可以自行查看 创建对象创建对象，我们不是直接可以通过 Object 的构造函数或者对象字面量的方法来实现对象的创建嘛？当然是可以的，但是有一个明显的缺点：使用同一个接口创建很多对象，产生大量重复的代码，我们引用设计模式。 工厂模式一种很基础的设计模式，简而言之就是用函数来封装以特定接口创建对象的细节。 function createAnimal(name, type) { const o = new Object(); o.name = name; o.type = type; o.sayName = function() { alert(this.name); }; return o; } const cat = createAnimal('小猫', 'cat'); const dog = createAnimal('小狗', 'dog'); 优点：可以无数次的调用这个函数，来创建相似对象。 缺点：不能解决对象识别的问题。实际项目中可以参考弹出层的设计。 构造函数模式ECMAScript 中的构造函数可以用来创建特定类型的对象。在运行时会自动出现在执行环境中。 function Animal(name, type) { this.name = name; this.type = type; this.sayName = function() { alert(this.name); }; } const cat = new Animal('小猫', 'cat'); const dog = new Animal('小狗', 'dog'); 注意上面我们没有显示的 return 过一个对象出来，为什么？因为 this。 关于构造函数惯例首字母大写不用多说。强调构造函数一定要使用关键字 new 来调用。new 的过程： 创建一个新的对象 将构造函数的作用域赋值给新对象（this 执行新的对象） 执行构造函数的代码 返回新的对象 在实例对象中，都有一个 constructor 属性。 cat.constructor == Animal; //true dog.constructor == Animal; //true cat instanceof Animal; //true dog instanceof Animal; //true 构造函数模式的优点如上所说，但是缺点还是有的，比如说 cat.sayName == dog.sayName; //false 也就是说，他创建了两个功能一样的函数，这样是很没有必要的，当然，我们可以把 say 放到构造函数外面，然后通过this.sayName = sayName来操作，但是这样的话，又会导致全局变量的污染。怎么办？ 原型模式我们在创建每一个函数的时候都有一个 prototype(原型)属性，这个属性是一个指针，指向一个对象。而这个对象的用途就是包含由特定类型的所有实例共享的属性和方法。 function Animal() {} Animal.prototype.name = '毛毛'; Animal.prototype.type = 'dog'; Animal.prototype.sayName = function() { alert(this.name); }; const cat = new Animal(); const dog = new Animal(); alert(cat.sayName == dog.sayName); // true 原型模式的好处就是可以让所有的对象实例共享他的属性和方法。不必在构造函数中定义对象实例的信息。 function Person() {} Person.prototype.name = 'Liusixin'; Person.prototype.age = 26; Person.prototype.sayName = function() { alert(this.name); }; const man = new Person(); console.log(man.name); // 'Liusixin' -> 来自原型 man.name = 'Liu'; console.log(man.name); // Liu -> 来自实例 delete man.name; console.log(man.name); // 'Liusixin' -> 来自原型 上面的例子说明两点 原型中的对象属性可以被实例所覆盖重写 通过 delete 可以删除实例中的属性，但是删除不了原型对象上的 我们可以通过hasOwnProperty()方法来确定一个属性是在原型上还是在实例上。man.hasOwnProperty(&#39;name&#39;),如果 name 为实例属性，则返回 true。 我们也可以通过 &#39;name&#39; in man 来确定，man 上是否有 name 这个属性。 上面大家可能已将发现，这种原型模式的写法非常的繁琐，有了大量的 XXX.prototype. 这里有一种简写的形式。 参照具体说明参照阮神的博客 Javascript 面向对象编程（二）：构造函数的继承 function Person() {} Person.prototype = { constructor: Person, name: 'Liusixin', age: 26, job: 'web Engineer', sayName() { alert(this.name); } }; 上面代码特意添加了一个constructor属性，因为每创建一个函数，就会自动创建他的prototype对象，这个对象会自动获取contractor属性。而我们这中写法，本质上重写了默认的prototype对象，因此，constructor属性也就变成新的对象的constructor属性了（指向 Object 构造函数），所以这里的简写方式，一定要加上constructor。 下面我们再谈一谈原型模式的优缺点。 优点，正如上面我们说到的，可以省略为构造函数传递出实体参数这个环节，并且很多实例可以共享属性和方法。正是因为原型中所有的属性是被所有的实例所共享的，这个特性在方法中非常实用，但是对于包含引用类型的属性来说问题就比较突出了。 function Person() {} Person.prototype = { constructor: Person, name: 'liusixin', friends: ['xiaohong', 'xiaoming'], sayName() { alert(this.name); } }; const person1 = new Person(); const person2 = new Person(); person1.friends.push('xiaohua'); alert(person1.friends); // 'xiaohong','xiaoming','xiaohua' alert(person2.friends); // 'xiaohong','xiaoming','xiaohua' alert(person1.friends == person2.friends); // true 由于 friends 数组存在于Person.prototype上，并不是 person1 上，所以当我们修改的时候，其实修改的是所有实例所共享的那个值。 组合使用构造函数和原型模式这是创建自定义类型最常见的一种方式。就是组合使用构造函数和原型模式.构造函数模式用于定义实力属性，原型模式用于定义方法和共享的属性。 function Person(name, age) { this.name = name; this.age = age; } Person.prototype = { constructor: Person, sayName() { alert(this.name); }, }; const person1 = new Person('Liu', 26); const person2 = new Person('Sixin', 20); ... 上面的例子中，实例所有的属性都是在构造函数中定义，而实例所有共享的属性和方法都是在原型中定义。这种构造函数和原型模式混合的模式，是目前 ECMAScript 中使用最为广泛的一种方法。 当然，有些人会觉得独立的构造函数和原型非常的难受，所以也有推出所谓的动态原型构造模式的这么一说。 function Person(name, age) { this.name = name; this.age = age; if (typeof this.sayName !== 'function') { Person.prototype.sayName = function () { console.log(this.name); }; } } ... 注意上面的代码，之后在 sayName 不存在的时候，才会在原型上给他添加相应的方法。因为对原型的修改，能够立即在所有的实例中得到反应。所以这中做法确实也是非常的完美。 继承 说到面向对象，当然得说到继承。说到继承当然得说到原型。说到原型，这里我们参考一篇博文：全面理解面向对象的 JavaScript 首先什么是 javascript 面向对象呢 一切事物皆对象。 对象具有封装和继承特性。 对象与对象之间使用消息通信，各自存在信息隐秘。 js 语言是通过一种叫做原型(prototype) 的方式来实现面向对象编程的。当然，还有比如 java 就是基于类来实现面向对象编程的。 基于类的面向对象和基于原型的面向对象方式比较对于基于类的面向对象的方式中，对象依靠 class 类来产生。而在基于原型的面向对象方式中，对象则是依靠构造器(constructor)利用原型(prototype)构造出来的。举个客观世界的例子来说，例如工厂造一辆汽车一方面，工人必须参照一张工程图纸，设计规定这辆车如何制造，这里的工程图纸就好比语言中的类 class。而车就是按照这个类制造出来的。另一方面，工人和机器相当于 contractor，利用各种零部件(prototype)将汽车造出来。 首先，客观世界中的对象的产生都是其他实物对象构造的世界，而抽象的图纸是不能产生出汽车的。也就是说，类，是一个抽象概念的而非实体，而对象的产生是一个实体的产生。其次，按照一切事物皆对象的面向对象的法则来说，类本身并不是一个对象，然而原型方式的构造函数和原型本身也是个对象。再次，在类的面向对象语言中，对象的状态为对象的实例所持有，对象的行为方法则由申明该对象的类所持有，并且只有对象的构造和方法能够被继承。而在原型的面向对象语言中，对象的行为、状态都属于对象本身，并且能够一起被继承。 原型链 ECMAScript 描述了原型链的概念，并将原型链作为实现继承的主要方法。基本思想就是利用原型让一个引用类型继承另一个引用类型的属性和方法。 实现原型链有一种基本模式： function SuperType() { this.property = true; } SuperType.prototype.getSuperValue = function() { return this.property; }; function SubType() { this.subproperty = false; } SubType.prototype = new SuperType(); SubType.prototype.getSubValue = function() { return this.subproperty; }; const instance = new SubType(); alert(instance.getSuperValue()); 在上面的代码中，我们没有使用 SubType 默认提供的原型，而是给它换了一个新的原型，这个新原型就是 SuperType 的实例。于是，新原型不仅具有所谓一个 SuperType 的实例所拥有的全部属性和方法，而且其内部还有一个指针，指向 SuperType 的原型。最终结果是这样的：instance 指向 subtype 的原型，subtype 的原型又指向 SuperType 的原型。 通过实现原型链，本质上是扩展了原型搜索机制。 虽然如上，我们已经实现了 javascript 中的继承。但是依旧存在一些问题：最主要的问题来自包含引用类型的原型。第二个问题就是在创建子类型的实例时，不能向超类型的构造函数中传递参数。这两个问题上面也都有说到，这里就不做过多介绍，直接看解决办法: 借用构造函数 在解决原型中包含引用类型的数据时，我们可以在子类型构造函数内部调用超类型的构造函数。直接看代码： function SuperType(name) { this.colors = ['red', 'yellow']; this.name = name; } function SubType(name) { // 继承了Super SuperType.call(this, name); } const instance1 = new SubType('Liu'); console.log(instance1.name); instance1.colors.push('black'); console.log(instance1.colors); // 'red','yellow','black' const instance2 = new SubType('sixin'); console.log(instance2.colors); // 'red','yellow' 毕竟函数只不过是在特定环境中执行代码的对象，因此可以通过 call 或者 apply 方法在新创建的对象上执行构造函数。而且如上代码也解决了子类构造函数中向超类构造函数传递参数的问题 但是，这样问题就来了，类似我们之前讨论创建的对象那种构造函数的问题：如果都是使用构造函数，那么，也就避免不了方法都在构造函数中定义，然后就会产生大量重复的代码了。 组合继承 因为考虑到上述的缺点，所以这里又使用了组合继承的方式，历史总是惊人的相似。直接看代码： function SuperType(name) { this.name = name; this.colors = ['red', 'yellow']; } SuperType.prototype.sayName = function() { alert(this.name); }; function SubType(name, age) { // 继承属性 SuperType.call(this, name); this.age = age; } // 继承方法 SubType.prototype = new SuperType(); SubType.prototype.constructor = SubType; SubType.prototype.sayAge = function() { alert(this.age); }; const instance1 = new SubType('Liusixin', 26); instance1.colors.push('white'); instance1.sayName(); // Liusixin instance1.sayAge(); // 26 const instance2 = new SubType('Liu', 20); alert(instance2.colors); // 'red','yellow' instance2.sayName(); // Liu instance2.sayAge(); // 20 在上面的例子中，SuperType 构造函数定义了两个属性，name 和 colors，SuperType 的原型中定义了一个方法 sayName，subtype 的构造函数中调用 SuperType 构造函数并且传入 name，然后将 SuperType 的实例赋值给 subtype 的原型。然后又在新的原型中定义了 sayAge 的方法。这样一来，就可以让两个不同的 SubType 实例既分别拥有自己的属性，包括 colors，又可以使用相同的方法了。 组合继承避免了原型链和借用构造函数的缺陷，融合了他们的优点。成为 javascript 中最为常见的继承模式。而且instanceof和isPrototypeOf方法也能用于识别组合模式创建的对象。 别的继承模式继承模式不止上面几种，这里只是说到常见的继承模式。还有原型式继承、寄生式继承、寄生组合式继承等，其实，只要理解了原型、原型链、构造函数等对象的基本概念，理解起来这中模式都是非常容易的。","tags":[{"name":"javascript","slug":"javascript","permalink":"http://coder.liusixin.cn/tags/javascript/"},{"name":"编程笔记","slug":"编程笔记","permalink":"http://coder.liusixin.cn/tags/编程笔记/"}]},{"title":"JS的变量、作用域和内存问题","date":"2017-10-11T13:39:19.000Z","path":"posts/d446ebaa/","text":"基本类型和引用类型 在 ECMAScript 中，变量分为基本类型和引用类型两种。基本类型就是存储简单的数据段。而引用类型指的是那些可能由多个值构成的对象。在 ECMAScript 中，基本类型包括：Undefined、Null、Boolean、Number 和 String。这些基本类型的对象都是按值访问的。所以 js 中我们可以直接操作他们。但是引用类型如 Object 等，是按照引用来操作的。并非直接操作其值。并且我们可以动态的为引用类型变量添加属性和方法。而基本类型则不可以。 变量赋值和传参主要说明引用类型 对于赋值 function setName(obj) { obj.name = 'Nicholas'; obj = new Object(); obj.name = 'sixin'; console.log(obj.name); // sixin } const person = new Object(); setName(person); console.log(person.name); // Nicholas 引用类型在传参的时候，也是按照值传递的。 即使在函数内部修改了参数的值。原始的引用依然不变。实际上，在重写 obj 的时候，这个变量的引用已经是一个局部变量了。只是在这儿函数运行完，这个对象被销毁了。 如果不懂的话我们用直白的方式解释下这段代码是： person这个object作为参数传递给function的时候，function内部的作用域可以找到person而且这时候obj的值指向的是“堆内存中person所指向地址”（person本身也是个指针，obj是person这个指针被作为参数传递后复制出来的副本）；然后下一步 new 出一个 Object 的时候，是在堆内存中新建了一个Object()，这个时候obj是指向这个新 new 出来的 Object 的指针，所以对这个 Object 新增一个叫 name 的属性并且在这个局部变量指针还未被销毁（即函数未执行完毕）之前打出 log，输出的是这个新 new 出来的 Object 里的 name 属性，是 sixin。需要注意的是，在function执行的这一个阶段里，对于原来的 Object 进行操作只有一次，即给它的 name 属性赋值为’Nicholas’，随即在这个函数里就没有指针再指向它了，所以在外部的输出就是”Nicholas”； 执行环境及其作用域 这大概是一个非常基础也是重要的部分，后续会在进阶里面详细展开。 执行环境定义了变量或者函数有权访问的其他数据，决定了他们的行为。每一个执行环境都有一个与之关联的变量对象（如 global、window）。环境中定义的所有变量和函数都保存在这个对象中。 某一个执行环境执行完毕后，该环境会被销毁。其中的所有的变量和函数也将随之销毁。全局执行环境知道应用程序退出才被销毁（如关闭网页等） 当代码在一个环境中执行的时候，会创建变量对象的一个 ​​ 作用域链。作用域链的用途，是保证对执行环境有权访问的变量和函数的有序访问。作用域链的前端，始终是当前执行的代码所在的环境的变量对象。全局执行环境始终是作用域链的最后一个对象。 标识符的解析也就是沿着作用域链一级一级的搜索的过程。搜索过程从作用域链的前端开始，然后逐级向后回溯。知道找到标识符为止。 let color = 'red'; function changeColor() { let anotherColor = 'blue'; function swapColors() { const tempColor = anotherColor; anotherColor = color; color = tempColor; // 这个执行环境中可以访问到tempColor color antherColor } // 这里只能访问anotherColor color swapColors(); } changeColor(); // 这里只能访问color 所以从上面代码我们可以感受到：内部环境可以通过作用域链访问到外部环境的变量。反之不可。这些环境之间的联系都是线性、有次序的。 延长作用域链虽然执行环境的类型只有两种。局部的和全局的。但是还有一种方法可以延长作用域链。 这是因为有些语句可以在作用域链的前端临时添加一个变量对象，改变量对象会在代码执行后被移除。 try-catch 语句中的 catch with语句 对于 with 语句而言，会将指定的对象添加到作用域链中。对于 catch 语句而言，会创建一个新的变量对象，其中包含被抛出的错误对象的申明。 垃圾收集局部变量只在函数执行过程中存在。而在这个过程中，会为局部变量在栈或者堆中分配相应的内存空间。然后函数执行时，用了这些变量。执行完后，则这些变量就没有用了，需清理释放内存空间。 但是并非所有的情况下都这么容易的得出结论。垃圾收集器必须跟踪哪个变量用了哪个变量没用。对于不在利用的打上标记，已被将来收回其所占用的内存。 标记清除 这是最为常用一种清除方式。当一个变量进入到环境的时候，标记为’进入环境’，这个基本是不会被清除的，因为执行流进入到相应的环境的时候可能会用到。当变量离开环境的时候，标记为’离开环境’。 可以使用任何方式来标记。我们要知道是如何标记不重要，重要的是采用什么策略。 垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记。他会去掉环境中的变量以及被环境中的变量所引用的变量的标记。剩下的，则准备删除。因为环境中的变量已经无法访问到这些变量了。目前 IE、ff 、 opera 、 chrome 都是这种标记清除方式。 引用计数 因为不常用，简单说下 引用计数的意思就是跟踪记录每一个值被引用的次数。当一个引用类型的变量复制给一个变量的时候，这个引用次数则+1，如果有别复制给另一个变量，则再+1，如果包含对这个值的引用的变量又被赋值了别的值。则这个值-1. 当引用次数为 0 的时候，则当做垃圾回收。 function test() { var objectA = new Object(); var objectB = new Object(); objectA.someOtherObject = objectB; objectB.someOtherObject = objectA; } 对象 A 和对象 B 的属性互相引用。也就是说，这两个对象的引用次数永远都是 2.哪怕这个函数执行完咯，也没法清理的。 虽然垃圾回收机制帮我们做了很多事，但是电脑分配给浏览器的可用内存通常要比桌面应用的内存要小的多，毕竟是为了防止运行 js 的网页耗尽所有的内存而导致系统崩溃的问题发生。 所以我们确保用最少的内存可以让页面获取最好的性能，最佳的执行方案就是执行中的代码都是有必要的数据。 function createPerson(name) { const localPerson = new Object(); localPerson.name = name; return localPerson; } const neal = createPerson('Neal'); // 主动清理垃圾 createPerson = null; createPerson设置为null，并没有立刻把他清除，只是释放了他的引用。让其脱离其执行环境，以便于垃圾收集器更快的将其回收。","tags":[{"name":"javascript","slug":"javascript","permalink":"http://coder.liusixin.cn/tags/javascript/"},{"name":"编程笔记","slug":"编程笔记","permalink":"http://coder.liusixin.cn/tags/编程笔记/"}]},{"title":"如何编写高质量javascript代码","date":"2017-10-07T12:06:24.000Z","path":"posts/8c1d1a9d/","text":"在我们日常编码中，编写可维护代码是非常重要的，编写可维护代码，意味着： 可读性 一致性 可预测性 团队代码风格一致 最小全局变量JavaScript 是通过函数来管理作用域的。在函数内部申明的变量只能在函数内部使用，在函数外部不能使用。每一个 JavaScript 都有一个全局对象，当你在任意的函数外部访问 this 的时候可以访问到，你创建的每一个全局变量都成为这个全局对象的属性。浏览器中，这个全局对象便是 window。 myglobal = 'Hello'; console.log(myglobal); console.log(window.myglobal); console.log(window['myglobal']); console.log(this.myglobal); 全局变量的问题全局变量最大的问题就是变量名冲突，造成不可以预计的后果。而在 web 页面中包含不是开发者缩写的代码也很常见 第三方 JavaScript 库 广告或者统计脚本 不同类型的组件 所以一旦出现命名冲突，可能会造成不可预估的错误。所以尽可能的少用全局变量是非常有必要的。比如使用局部变量声明，es6 中的let和const，这里我们主要探讨下 var。 由于 JavaScript 的两个特征，不自觉的创建变量是出乎意料的容易，首先，你可以甚至不需要声明就可以使用变量；第二，JavaScript 有隐含的全局概念，意味着你不声明的任何变量都会成为一个全局对象属性。 function sum(x, y) { // 不推荐写法: 隐式全局变量 result = x + y; return result; } 另一个创建隐式全局变量的反例就是使用任务链进行部分 var 声明。下面的片段中，a 是本地变量但是 b 却是全局变量，这可能不是你希望发生的 // 反例，勿使用 function foo() { var a = (b = 0); // ... } 忘记 var 的副作用 隐式全局变量和明确定义的全局变量间有些小的差异，就是通过delete操作符让变量未定义的能力。 通过 var 创建的全局变量（任何函数之外的程序中创建）是不能被删除的 隐式全局变量（无视是否在函数中创建）是能被删除的 这表明，在技术上，隐式全局变量并不是真正的全局变量，但它们是全局对象的属性。属性是可以通过delete操作符删除的，而变量是不能的 单 var 形式 在函数顶部使用单 var 语句是比较有用的一种形式，其好处在于 提供了一个单一的地方去寻找功能所需要的所有局部变量 防止变量在定义之前使用的逻辑错误 帮助你记住声明的全局变量，因此较少了全局变量 少代码（类型、传值、单线完成） function func() { var a = 1, b = 2, sum = a + b, myobject = {}, i, j; // function body... } 预解析：var 散布的问题JavaScript 中，你可以在函数的任何位置声明多个 var 语句，并且它们就好像是在函数顶部声明一样发挥作用，这种行为称为 hoisting。当你使用了一个变量，然后不久在函数中又重新声明的话，就可能产生逻辑错误。对于 JavaScript，只要你的变量是在同一个作用域中（同一函数），它都被当做是声明的，即使是它在 var 声明前使用的时候。 // 反例 myname = 'global'; // 全局变量 function func() { alert(myname); // \"undefined\" var myname = 'local'; alert(myname); // \"local\" } func(); 由于函数声明提前，也就是预解析。为了避免这种混乱，最好是预先声明你想使用的全部变量。 为了完整，我们再提一提执行层面的稍微复杂点的东西。代码处理分两个阶段，第一阶段是变量，函数声明，以及正常格式的参数创建，这是一个解析和进入上下文的阶段。第二个阶段是代码执行，函数表达式和不合格的标识符（为声明的变量）被创建。但是，出于实用的目的，我们就采用了”hoisting”这个概念， 这种 ECMAScript 标准中并未定义，通常用来描述行为。 for 循环 推荐写法 for (var i = 0, max = myarray.length; i &lt; max; i++) { // 使用myarray[i]做点什么 } 伴随着单 var 形式，你可以把变量从循环中提出来，就像下面这样： function looper() { var i = 0, max, myarray = []; // ... for (i = 0, max = myarray.length; i &lt; max; i++) { // 使用myarray[i]做点什么 } } 最后一个需要对循环进行调整的是使用下面表达式之一来替换i++。 i = i + 1; i += 1; ++和–-促进了“过分棘手(excessive trickiness)”。 还有两种变化的形式，其又有了些微改进，因为： 少了一个变量(无 max) 向下数到 0，通常更快，因为和 0 做比较要比和数组长度或是其他不是 0 的东西作比较更有效率 //第一种变化的形式： var i, myarray = []; for (i = myarray.length; i– - ;) { // 使用myarray[i]做点什么 } //第二种使用while循环： var myarray = [], i = myarray.length; while (i– - ) { // 使用myarray[i]做点什么 } for-in Loops for-in 循环应该用在非数组对象的遍历上，使用 for-in 进行循环也被称为“枚举” 从技术上将，你可以使用 for-in 循环数组（因为 JavaScript 中数组也是对象），但这是不推荐的。因为如果数组对象已被自定义的功能增强，就可能发生逻辑错误。另外，在 for-in 中，属性列表的顺序（序列）是不能保证的。所以最好数组使用正常的 for 循环，对象使用 for-in 循环。 有个很重要的hasOwnProperty()方法，当遍历对象属性的时候可以过滤掉从原型链上下来的属性。 // 对象 var man = { hands: 2, legs: 2, heads: 1 }; // 在代码的某个地方 // 一个方法添加给了所有对象 if (typeof Object.prototype.clone === 'undefined') { Object.prototype.clone = function() {}; } 在这个例子中，我们有一个使用对象字面量定义的名叫 man 的对象。在 man 定义完成后的某个地方，在对象原型上增加了一个很有用的名叫 clone()的方法。此原型链是实时的，这就意味着所有的对象自动可以访问新的方法。为了避免枚举 man 的时候出现clone()方法，你需要应用hasOwnProperty()方法过滤原型属性。如果不做过滤，会导致clone()函数显示出来，在大多数情况下这是不希望出现的。 // 1. // for-in 循环 for (var i in man) { if (man.hasOwnProperty(i)) { // 过滤 console.log(i, ':', man[i]); } } /* 控制台显示结果 hands : 2 legs : 2 heads : 1 */ // 2. // 反面例子: // for-in loop without checking hasOwnProperty() for (var i in man) { console.log(i, ':', man[i]); } /* 控制台显示结果 hands : 2 legs : 2 heads : 1 clone: function() */ 另外一种使用hasOwnProperty()的形式是取消Object.prototype上的方法。 for (var i in man) { if (Object.prototype.hasOwnProperty.call(man, i)) { // 过滤 console.log(i, ':', man[i]); } } 其好处在于在 man 对象重新定义hasOwnProperty情况下避免命名冲突。也避免了长属性查找对象的所有方法，你可以使用局部变量“缓存”它。 var i, hasOwn = Object.prototype.hasOwnProperty; for (i in man) { if (hasOwn.call(man, i)) { // 过滤 console.log(i, ':', man[i]); } } （不）扩展内置原型 增加内置的构造函数原型（如Object(), Array(), 或Function()）挺诱人的，但是这严重降低了可维护性，因为它让你的代码变得难以预测。使用你代码的其他开发人员很可能更期望使用内置的 JavaScript 方法来持续不断地工作，而不是你另加的方法。 switch 模式var inspect_me = 0, result = ''; switch (inspect_me) { case 0: result = 'zero'; break; case 1: result = 'one'; break; default: result = 'unknown'; } 每个 case 和 switch 对齐（花括号缩进规则除外） 每个 case 中代码缩进 每个 case 以 break 清除结束 避免贯穿（故意忽略 break）。如果你非常确信贯穿是最好的方法，务必记录此情况，因为对于有些阅读人而言，它们可能看起来是错误的 以 default 结束 switch：确保总有健全的结果，即使无情况匹配。 避免隐式类型转换 JavaScript 的变量在比较的时候会隐式类型转换。这就是为什么一些诸如：false == 0 或 “” == 0 返回的结果是 true。为避免引起混乱的隐含类型转换，在你比较值和表达式类型的时候始终使用===和!==操作符。 避免 eval() 如果代码是在运行时动态生成，有一个更好的方式不使用 eval 而达到同样的目标。例如，用方括号表示法来访问动态属性会更好更简单： // 反面示例 var property = 'name'; alert(eval('obj.' + property)); // 更好的 var property = 'name'; alert(obj[property]); 使用eval()也带来了安全隐患，因为被执行的代码（例如从网络来）可能已被篡改。这是个很常见的反面教材，当处理 Ajax 请求得到的 JSON 相应的时候。在这些情况下，最好使用 JavaScript 内置方法来解析 JSON 相应，以确保安全和有效。若浏览器不支持JSON.parse()，你可以使用来自JSON.org的库。 同样重要的是要记住，给setInterval(), setTimeout()和Function()构造函数传递字符串，大部分情况下，与使用eval()是类似的，因此要避免。在幕后，JavaScript 仍需要评估和执行你给程序传递的字符串： // 反面示例 setTimeout('myFunc()', 1000); setTimeout('myFunc(1, 2, 3)', 1000); // 更好的 setTimeout(myFunc, 1000); setTimeout(function() { myFunc(1, 2, 3); }, 1000); 如果你必须使用eval()，可以考虑使用new Function()代替。有一个小的潜在好处，因为在new Function()中作代码评估是在局部函数作用域中运行，所以代码中任何被评估的通过 var 定义的变量都不会自动变成全局变量。另一种方法来阻止自动全局变量是封装eval()调用到一个即时函数中。 console.log(typeof un); // \"undefined\" console.log(typeof deux); // \"undefined\" console.log(typeof trois); // \"undefined\" var jsstring = 'var un = 1; console.log(un);'; eval(jsstring); // 1 jsstring = 'var deux = 2; console.log(deux);'; new Function(jsstring)(); // 2 jsstring = 'var trois = 3; console.log(trois);'; (function() { eval(jsstring); })(); // 3 console.log(typeof un); // number console.log(typeof deux); // \"undefined\" console.log(typeof trois); // \"undefined\" 另一间eval()和Function构造不同的是eval()可以干扰作用域链，而Function()则不会。不管你在哪里执行 Function()，它只看到全局作用域。所以其能很好的避免本地变量污染。 parseInt 下的数值转换 使用parseInt()你可以从字符串中获取数值，该方法接受另一个基数参数，这经常省略，但不应该。当字符串以”0″开头的时候就有可能会出问题，例如，部分时间进入表单域，在 ECMAScript 3 中，开头为”0″的字符串被当做 8 进制处理了，但这已在 ECMAScript 5 中改变了。为了避免矛盾和意外的结果，总是指定基数参数。 空格 空格的使用同样有助于改善代码的可读性和一致性。在写英文句子的时候，在逗号和句号后面会使用间隔。在 JavaScript 中，你可以按照同样的逻辑在列表模样表达式（相当于逗号）和结束语句（相对于完成了“想法”）后面添加间隔。 适合使用空格的地方包括： for 循环分号分开后的的部分：如for (var i = 0; i &lt; 10; i += 1) {...} for 循环中初始化的多变量(i 和 max)：for (var i = 0, max = 10; i &lt; max; i += 1) {...} 分隔数组项的逗号的后面：var a = [1, 2, 3]; 对象属性逗号的后面以及分隔属性名和属性值的冒号的后面：var o = {a: 1, b: 2}; 限定函数参数：myFunc(a, b, c) 函数声明的花括号的前面：function myFunc() {} 匿名函数表达式 function 的后面：var myFunc = function () {}; 使用空格分开所有的操作符和操作对象是另一个不错的使用，这意味着在+, -, *, =, &lt;, &gt;, &lt;=, &gt;=, ===, !==, &amp;&amp;, ||, +=等前后都需要空格。 注释、 驼峰命名","tags":[{"name":"javascript","slug":"javascript","permalink":"http://coder.liusixin.cn/tags/javascript/"},{"name":"编程笔记","slug":"编程笔记","permalink":"http://coder.liusixin.cn/tags/编程笔记/"}]},{"title":"VUE 学习笔记——vuex","date":"2017-10-04T03:14:51.000Z","path":"posts/4f38c43c/","text":"1 vuex$ npm i vuex -S // store.js import Vue from 'vue'; import Vuex from 'vuex'; Vue.use(Vuex); const store = new Vuex.Store({ state: { count: 0 }, mutations: { updateCount(state, num) { state.count = num; } } }); export default store; &lt;template> &lt;div id=\"root\"> &lt;span>{{count}}&lt;/span> &lt;/div> &lt;/template> &lt;script> export default { components: { Header, Footer }, mounted () { let i = 1 setInterval(() => { this.$store.commit('updateCount', i++) // 通过组件内部调用方法修改mutations }, 1000) }, computed: { count() { return this.$store.state.count } } } &lt;/script> vue 组件是树形结构的，store 只有放在最外层，它内部的子节点才能拿到 store 对象 import Vuex from 'vuex'; export default () => { return new Vuex.Store({ state: { count: 0 }, mutations: { updateCount(state, num) { state.count = num; } } }); }; // return新的对象，防止栈溢出 1.1 vuex-state 每个数据都要给默认值，不然会导致后续增加这个值的时候，它的数据不是响应式的，不会更新视图。用到的字段一次性声明好。 import Vuex from 'vuex'; import defaultState from './state/state'; import mutations from './mutations/mutations'; export default () => { return new Vuex.Store({ state: defaultState, mutations }); }; 这里命名 defaultState 是因为后续服务端渲染有一部分数据直接渲染到客户端，会覆盖 default 数据，default 数据没有跟业务相关的内容，只是默认值。 export default { count: 0 }; export default { updateCount(state, num) { state.count = num; } }; 1.2 vuex-getter 可以理解为 computed，方便我们生成在应用里可以用的数据，在与后端开发联调的时候，后端数据有时并不适合在 view 层去显示，需要重新组装，这个组装数据需要在多个页面用到的时候用 getter。 import Vuex from 'vuex'; import defaultState from './state/state'; import mutations from './mutations/mutations'; import getters from './getters/getters'; export default () => { return new Vuex.Store({ state: defaultState, mutations, getters }); }; // state.js export default { count: 0, firstName: 'liu', lastName: 'sixin' }; // getters.js export default { fullName(state) { return `${state.firstName} ${state.lastName}`; } }; // app.vue &lt;template> &lt;span>{{fullName}}&lt;/span> &lt;/template> &lt;script> export default { computed: { fullName(){ return this.$store.getters.fullName } } } &lt;/script> 在组件内这种写法太麻烦，vuex 给我们提供了更简便的写法 // app.vue &lt;template> &lt;span>{{fullName}} {{count}}&lt;/span> &lt;/template> &lt;script> import { mapState, mapGetters } from 'vuex' export default { computed: { ...mapState(['count']), fullName(){ return this.$store.getters.fullName } } } &lt;/script> 但是在 babel 里 env 是不支持…这种语法，\b // 可以使用es8\u001c或者未定稿语法 npm i babel-preset-stage-1 -D { \"presets\": [ \"env\"\b, \"stage-1\" ], \"plugins\": [ \"transform-vue-jsx\", \"syntax-dynamic-import\" ] } 如果想要不同名的方式 export default { computed: { ...mapState({ counter: 'count' }), } } // 以函数的方式 export default { computed: { ...mapState({ counter: (state) => state.count }), } } 1.3 vuex-mutation 专门用来修改 state 数据，默认只能传 2 个参数，要传多个值，第二个参数设为对象 // app.vue computed: { let i = 1; setInterval(() => { this.$store.commit('updateCount', { num: i++, num2: 2 }); }, 1000); } // mutations.js export default { updateCount(state, { num, num2 }) { state.count = num; } }; vue 官方推荐所有 state 修改都放在 mutation 方法里，但是不强制,如果要强制的话，设置 strict 为 true(只在开发环境使用) import Vuex from 'vuex'; import defaultState from './state/state'; import mutations from './mutations/mutations'; import getters from './getters/getters'; const isDev = process.env.NODE_ENV === 'development'; export default () => { return new Vuex.Store({ strict: isDev, state: defaultState, mutations, getters }); }; 1.4 vuex-action action 和 mutation 差不多，但是 action 用于异步代码，而 mutation 用于同步代码 // store.js import Vuex from 'vuex' import defaultState from './state/state' import mutations from './mutations/mutations' import getters from './getters/getters' import actions from './actions/actions' export default () => { return new Vuex.Store({ state: defaultState, mutations, getters, actions }) } // actions.js export default { updateCountAsync (store, data) { setTimeout(() => { store.commit('updateCount', { num: data.num }) }, data.time) } } // app.vue mounted () { this.$store.dispatch('updateCountAsync', { num: 5, time: 2000 }) } \b 更简洁的写法，建立方法对应关系 // app.vue import { mapActions, mapMutations } from 'vuex' methods: { ...mapActions(['updateCountAsync']), ...mapMutations(['updateCount']) }, mounted () { let i = 1 this.updateCountAsync({ num: 5, time: 2000 }) setTimeout(() => { this.updateCount({ num: i++, num2: 2 }) }, 1000) } 1.5 vuex 模块// store.js import Vuex from 'vuex' import defaultState from './state/state' import mutations from './mutations/mutations' import getters from './getters/getters' import actions from './actions/actions' export default () => { return new Vuex.Store({ state: defaultState, mutations, getters, actions, modules: { a: { state: { text: 1 } }, b: { state: { text: 2 } } } }) } // app.vue &lt;template> &lt;div id=\"root\"> &lt;span>{{fullName}} {{counter}} - {{textA}} {{textB}}&lt;/span> &lt;/div> &lt;/template> &lt;script> computed: { textA () { return this.$store.state.a.text }, textB () { return this.$store.state.b.text } } &lt;/script> 更简洁写法 computed: { ...mapState({ counter: (state) => state.count, textA: state => state.a.text }) }, 加入 mutation // store.js export default () => { return new Vuex.Store({ modules: { a: { state: { text: 1 }, mutations: { updateText(state, text){ console.log('a.state', state) state.text = text } } }, b: { state: { text: 2 } } } }) } // app.vue &lt;template> &lt;div id=\"root\"> &lt;span>{{fullName}} {{counter}} - {{textA}} {{textB}}&lt;/span> &lt;/div> &lt;/template> &lt;script> mounted () { this.updateText('12345') }, methods: { ...mapActions(['updateCountAsync']), ...mapMutations(['updateCount', 'updateText']) }, computed: { ...mapState({ counter: (state) => state.count, textA: state => state.a.text }) } &lt;/script> 可以看到 updateText 调用没有像之前在模块内调用，这是因为 vuex 默认会把所有 mutation 放到全局命名当中，如果要加命名空间，加入 namespaced:true getter 和 mutation 一样 // store.js export default () => { return new Vuex.Store({ modules: { a: { namespaced: true, state: { text: 1 }, mutations: { updateText(state, text){ console.log('a.state', state) state.text = text } }, getters: { textPlus (state, getters, rootState) { // getters 所有的getter方法集合，rootState 全局的state return state.text + rootState.count } } }, b: { state: { text: 2 } } } }) } // app.vue &lt;template> &lt;div id=\"root\"> &lt;span>{{fullName}} {{counter}} - {{textA}} {{textB}}&lt;/span> &lt;/div> &lt;/template> &lt;script> mounted () { this.['a/updateText']('12345') }, methods: { ...mapActions(['updateCountAsync']), ...mapMutations(['updateCount', 'a/updateText']) }, computed: { ...mapState({ counter: (state) => state.count, textA: state => state.a.text }) ...mapGetters({ textPlus: 'a/textPlus' }) } &lt;/script> 在模块内获取全局的 rootState 方法 // store.js export default () => { return new Vuex.Store({ modules: { a: { namespaced: true, state: { text: 1 }, mutations: { updateText(state, text) { console.log('a.state', state); state.text = text; } }, getters: { textPlus(state, getters, rootState) { // getters 所有的getter方法集合，rootState 全局的state return state.text + rootState.count; } }, actions: { add(ctx) { //这里ctx在之前全局声明里拿到的是store对象，在这里是这一个模块的ctx，包含模块方法和rootState }, // 简洁方法 add({ state, commit, rootState }) { // 这里commit默认去模块里的mutation找 commit('updateText', rootState.count); // 要想在全局去找 commit('updateText', { num: 55667 }, { root: true }); } } }, b: { state: { text: 2 }, actions: { // 在b模块调用a模块方法，如果加了namespaced，则必须要加 root: true 才能调用 testAction({ commit }) { commit('a/updateText', 'test test', { root: true }); } } } } }); }; 注意：模块里还可以声明模块，可以无限嵌套 1.6 vuex 动态注册模块//index.js Vue.use(Vuex) const store = createStore() store.registerModule('c', { state: { text: 3 } }) // app.vue computed: { ...mapState({ textC: state => state.c.text }) } 1.7 vuex 热更器 页面在不刷新的情况下更新数据 // store.js import Vuex from 'vuex'; import defaultState from './state/state'; import mutations from './mutations/mutations'; import getters from './getters/getters'; import actions from './actions/actions'; export default () => { const store = new Vuex.Store({ state: defaultState, mutations, getters, actions }); if (module.hot) { module.hot.accept( [ './state/state', './getters/getters', './mutations/mutations', './actions/actions' ], () => { const newState = require('./state/state').default; const newGetters = require('./getters/getters').default; const newMutations = require('./mutations/mutations').default; const newActions = require('./actions/actions').default; store.hotUpdate({ state: newState, getters: newGetters, mutations: newMutations, actions: newActions }); } ); } return store; }; 1.8 vuex 其它 API\b//index.js Vue.use(Vuex); const store = createStore(); store.registerModule('c', { state: { text: 3 } }); //unregisterModule 解绑动态注册模块 store.unregisterModule('c'); // store.watch // 第一个参数为state，监听得到state的返回值，\b第二个参数返回一个方法，当第一个参数有变化的时候调用第二个方法作为回调。相当于store里的getter方法。 store.watch(state => state.count + 1, () => {}); // store.subscribe // 拿到所有mutation状态，有一个mutation变化，就会被调用 store.subscribe((mutation, state) => { console.log(mutation.type); console.log(mutation.payload); }); // store.subscribeAction // 拿到所有action状态，有一个action变化，就会被调用 store.subscribeAction((action, state) => { console.log(action.type); console.log(action.payload); }); 这两个方法一般用于 vuex 插件 1.9 vuex 插件import Vuex from 'vuex'; import defaultState from './state/state'; import mutations from './mutations/mutations'; import getters from './getters/getters'; import actions from './actions/actions'; export default () => { const store = new Vuex.Store({ state: defaultState, mutations, getters, actions, plugins: [ store => { // store.subscribe } ] }); }; 1.10 vuex\b 总结整个应用加入了 vuex 之后： index.js 顶部声明 root -&gt; new Vue() 通过 vue 实例把整个应用都挂载 \b 到 root 节点上,这个应用渲染的是 A\bpp 这个节点 new Vue({ router, store, render: h => h(App) }).$mount('#root'); 在 \bApp 里承担了一个路由操作，有多个路由子节点，每个子节点分别渲染不同的 vue 组件。整个 vue 应用就是节点的树形，通过一层层向下渲染，最终 \b 渲染成 html 节点。 有一个独立于 vue 节点树的 store，类似于一个数据库，store 通过在声明 vue 对象的时候 \b 注入到整个 \b 组件树，注入之后 App，及 \b 所有节点都可以通过 $store 对象调用 store 内容。 在节点内就可以通过 dispatch 或 commit 分别调用 mutation 或 action，以这种方式让我们在节点里可以修改 store 数据。但是要注意，真正的修改是在 store 里去做，而不是 dispatch 在节点 \b 里去操作。","tags":[{"name":"编程笔记","slug":"编程笔记","permalink":"http://coder.liusixin.cn/tags/编程笔记/"},{"name":"Vue","slug":"Vue","permalink":"http://coder.liusixin.cn/tags/Vue/"}]},{"title":"造轮子系列：JS封装无缝滚动","date":"2017-09-30T09:51:53.000Z","path":"posts/612f1a43/","text":"封装无缝滚动无缝滚动指的是几个元素循环滚动，视觉效果就像是有无穷无尽的元素一样。 实现的原理也很简单，首先对容器元素进行滚动操作。子元素在容器元素中依次排列，并且将子元素复制一份，放在同一个容器元素中，这样就实现了首尾相接。当最后一个子元素滚动过临界点的时候，将容器元素的位置拉回初始位置，然后重复滚动操作即可。 首先写好 HTML &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"> &lt;title>封装无缝滚动&lt;/title> &lt;style> body { margin: 0; } #scroll_area { width: 400px; height: 100px; border-top: 1px solid #ccc; border-bottom: 1px solid #ccc; margin: 20px auto; overflow: hidden; } .scroll_body { display: flex; position: relative; left: 0; height: 100%; font-size: 30px; } .scroll_body .item { flex: 1; display: flex; align-items: center; justify-content: center; } .buttons { width: 400px; margin: 20px auto; } &lt;/style> &lt;/head> &lt;body> &lt;div id=\"scroll_area\"> &lt;div class=\"scroll_body\"> &lt;div class=\"item\">1&lt;/div> &lt;div class=\"item\">2&lt;/div> &lt;div class=\"item\">3&lt;/div> &lt;div class=\"item\">4&lt;/div> &lt;div class=\"item\">5&lt;/div> &lt;/div> &lt;/div> &lt;div class=\"buttons\"> &lt;button class=\"left\">move left&lt;/button> &lt;button class=\"right\">move right&lt;/button> &lt;button class=\"stop\">stop&lt;/button> &lt;/div> &lt;/body> &lt;/html> 滚动区域元素 scroll_area 固定，容器元素 scro11_body 在滚动区域中滚动，滚动效果就是通过定时器每秒钟移动 1 个像素来实现的。 var lastTime = 0, nextFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequesAnimationFrame || window.msRequestAnimationFrame || function(callback) { var currTime = +new Date, delay = Math.max(1000 / 60, 1000 / 60 - (currTime - lastTime)); lastTime = currTime + delay; return setTimeout(callback, delay); }, cancelFrame = window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.webkitCancelRequestAnimationFrame || window.mozCancelRequestAnimationFrame || window.msCancelRequestAnimationFrame || clearTimeout; var area = document.querySelector('#scroll_area'); var areaWidth = area.offsetWidth; var scrollBody = area.querySelector('.scroll_body'); var itemWidth = areaWidth/(scrollBody.children.length); scrollBody.style.width = areaWidth * 2 + 'px'; scrollBody.innerHTML = scrollBody.innerHTML + scrollBody.innerHTML; var targetPos = areaWidth; var scrollX = 0; var timer = null; function ani() { cancelFrame(timer); timer = nextFrame(function() { scrollX -= 1; if(-scrollX >= targetPos) { scrollX = 0; } scrollBody.style.left = scrollX + 'px'; ani(); }) } ani(); 对于初学者来说，一个比较难以理解的地方就是 nextFrame 与 cancelFrame 的声明，这是一个类似于定时器的 setTimeout 的兼容性写法。requestAnimationFrame 是一个在 HTML5 中用于实现动画效果的API。 通过面向对象的方式来扩展控制滚动方向、停止滚动等接口: (function(ROOT){ var lastTime = 0, nextFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequesAnimationFrame || window.msRequestAnimationFrame || function(callback) { var currTime = +new Date, delay = Math.max(1000 / 60, 1000 / 60 - (currTime - lastTime)); lastTime = currTime + delay; return setTimeout(callback, delay); }, cancelFrame = window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.webkitCancelRequestAnimationFrame || window.mozCancelRequestAnimationFrame || window.msCancelRequestAnimationFrame || clearTimeout; var timer = null; function Scroll(elem) { this.elem = elem; this.areaWidth = elem.offsetWidth; this.scrollBody = elem.querySelector('.scroll_body'); this.itemWidth = this.areaWidth/this.scrollBody.children.length; this.scrollX = 0; this.targetPos = this.areaWidth; this.init(); } Scroll.prototype = { constructor: Scroll, init: function() { this.scrollBody.style.width = this.areaWidth * 2 + 'px'; this.scrollBody.innerHTML = this.scrollBody.innerHTML + this.scrollBody.innerHTML; this.moveRight(); }, moveLeft: function() { var self = this; cancelFrame(timer); timer = nextFrame(function() { self.scrollX -= 1; if(-self.scrollX >= self.targetPos) { self.scrollX = 0; } self.scrollBody.style.left = self.scrollX + 'px'; self.moveLeft(); }) }, moveRight: function() { var self = this; cancelFrame(timer); timer = nextFrame(function() { self.scrollX += 1; if(self.scrollX >= 0) { self.scrollX = -self.targetPos; } self.scrollBody.style.left = self.scrollX + 'px'; self.moveRight(); }) }, stop: function() { cancelFrame(timer); } } ROOT.Scroll = Scroll; })(window); var scroll = new Scroll(document.querySelector('#scroll_area')); var left_btn = document.querySelector('.left'); var right_btn = document.querySelector('.right'); var stop_btn = document.querySelector('.stop'); left_btn.onclick = function() { scroll.moveLeft(); } right_btn.onclick = function() { scroll.moveRight(); } stop_btn.onclick = function() { scroll.stop(); }","tags":[{"name":"javascript","slug":"javascript","permalink":"http://coder.liusixin.cn/tags/javascript/"}]},{"title":"VUE 学习笔记——vue-router","date":"2017-09-28T15:10:20.000Z","path":"posts/154ba74b/","text":"1 vue-router 之集成import Router from 'vue-router'; import routes from './routes'; // const router = new Router({ // routes // }) export default () => { return new Router({ routes, mode: 'history' // history路由形式，seo友好 }); }; 这里为什么要 export 出去一个函数。因为在每次服务端渲染都会新生成一个 app，router 只有一个对象，就会缓存每次新建的 app，导致服务端渲染流程结束后，app 并没有被释放掉，造成内存溢出。 路由要使用&lt;router-view /&gt;来渲染 1.1 路由参数export default () => { return new Router({ routes, mode: 'history', // history路由形式，seo友好 base: '/base/', // 应用基路径，所有路径\b前面都会有base \blinkActiveClass: '', linkExactActiveClass: '', scrollBehavior: (to, from, savedPosition){ // 页面路径进行跳转的时候页面要不要滚动 // to,路由跳转要去的路由 // from，从哪个路由跳转到下一个路由 // savedPosition，记录滚动条位置 }, parseQuery(query){ // 把url参数字符串转obj }, stringifyQuery(obj){ // 把obj转字符串 }, fallback: true // 不支持前端路由情况下，vue会自动fallback成哈希的模式，如果设成false，单页就变成了多页应用，每次路由跳转都会到后端再去返回新的内容，一般为true }) } vue 中可点击的内容一般用&lt;router-link /&gt;来做 linkActiveClass: '', linkExactActiveClass: '' // 就是用来配置全局样式，两者区别linkExactActiveClass是linkActiveClass子集 // scrollBehavior scrollBehavior: (to, from, savedPosition){ if(savedPosition){ // 如果在app下产生过滚动行为，下一次回来还会在这个位置 return savedPosition } else { return { x: 0, y: 0 } } } 浏览器会默认帮助跳转到默认位置，我们可以根据需求自定义 1.2 路由配置及参数传递export default [ { path: '/', redirect: '/app' }, { path: '/app', component: app, name: 'app', meta: {}, children: [ //子路由 { path: 'test', component: Test } ] }, { path: '/login', component: Login } ]; &lt;router-link to=\"/login\">login&lt;/router-link> //通过name去解析路由，而不是直接解析字符串 &lt;router-link \b:to=\"{name: 'app'}\">login&lt;/router-link> // 关键字。搜索引擎优化 meta: { title: 'this is app', description: 'xxxx' } 1.3 路由动画&lt;transition name=\"fade\"> &lt;router-view>&lt;/router-view> &lt;/transition> &lt;style lang=\"stylus\"> .fade-enter-active, .fade-leave-active transition: opacity .5s .fade-enter, .fade-leave-to opacity: 0 &lt;/style> 1.4 路由传参export default [ { path: '/', redirect: '/app' }, { path: '/app:id', // /app/xxx, xxx会变成id的变量传到组件内部 props: true, // 会把:id传入到App组件里 component: App, name: 'app', meta: {} } ]; 可以通过 this.$route 取到路由相关参数 通过 url 后?加参数可以取到 query props: true 这种方式可以更方便，同时达到组件与路由的解耦效果，尽量不要在组件里取$route url: localhost:8080/app/123?a=123&amp;b=456 // 同时也可以自定义props { path: '/app:id', props: { id: 123 } } // 根据query进行传递 { path: '/app:id', props: (route) => ({ id: route.query.b // 456 }) } 1.5 路由高级用法-命名视图&lt;template> &lt;div id=\"app\"> &lt;router-view name=\"a\" /> &lt;router-view /> &lt;/div> &lt;/template> { path: '/app, component: { default: Todo, a: Login } } 1.6 路由高级用法-导航守卫// 导航钩子 import Vue from 'vue'; import VueRouter from 'vue-router'; import App from './app.vue'; import './assets/styles/global.styl'; import routes from './config/router'; Vue.use(VueRouter); var router = routes(); router.beforeEach((to, from, next) => { // 进行数据校验,比如验证用户界面是需要用户登录才能显示 if (to.fullPath === '/app') { next('/login'); } else { next(); } }); router.beforeResolve((to, from, next) => { console.log('before resolve invoked'); next(); }); router.afterEach((to, from) => { console.log('before each invoked'); }); new Vue({ router, render: h => h(App) }).$mount('#root'); // 路由配置也可以增加钩子 { path: '/app, component: { default: Todo, a: Login }, beforeEnter (to, from, next) { //在beforeEach和beforeResolve之间调用 //执行逻辑 next() } } // 在组件里增加钩子 export default { beforeRouteEnter(to, from, next) { next() }, beforeRouteUpdate(to, from, next) { // 只有在使用param路由才会触发 next() }, beforeRouteLeave(to, from, next) { next() }, data () { return { } } // beforeRouteLeave最先触发 // 整个触发顺序 beforeEach(); beforeRouteEnter(); beforeResolve(); afterEach(); 在做路由跳转数据监听的时候可以用 beforeRouteEnter 代替 watch，并且 beforeRouteEnter 要通过 next 传递参数，因为在这之前它并没有被创建，取不到值。 export default { beforeRouteEnter(to, from, next) { console.log(this.id); // undifined next(vm => { console.log(vm.id); }); } }; beforeRouteEnter 路由钩子一般用来做数据获取插入到对象当中，这样页面进来时数据就已经获取好了 beforeRouteLeave 可以做一些确认，比如表单提交离开时，判断表单是否做了修改，然后弹出提示要不要离开，确认离开就执行 next，不确认就把数据保存下来。 beforeRouteLeave(to, from, next){ if(global.confirm('are you sure?')) { next() } } 1.7 路由高级用法-异步组件{ path: '/app, component: () => import('../views/todo/todo.vue') } 可能会提示不正确语法 import // 安装插件 npm i babel-plugin-syntax-dynamic-import -D // 修改下.babelrc { \"presets\": [ \"env\" ], \"plugins\": [ \"transform-vue-jsx\", \"syntax-dynamic-import\" ] } // 同时把app.vue里需要异步加载的组件import去掉 &lt;template> &lt;div id=\"root\"> &lt;div id=\"cover\">&lt;/div> &lt;Header>&lt;/Header> &lt;router-link to=\"/login\">login&lt;/router-link> &lt;!-- &lt;todo>&lt;/todo> --> &lt;router-view /> &lt;Footer>&lt;/Footer> &lt;/div> &lt;/template> &lt;script> import Header from './layout/header.vue' import Footer from './layout/footer.jsx' // import Todo from './views/todo/todo.vue' export default { components: { Header, Footer, // Todo } } &lt;/script>","tags":[{"name":"编程笔记","slug":"编程笔记","permalink":"http://coder.liusixin.cn/tags/编程笔记/"},{"name":"Vue","slug":"Vue","permalink":"http://coder.liusixin.cn/tags/Vue/"}]},{"title":"记一次工作中的 js 控制 cookie 的实践","date":"2017-09-27T13:15:05.000Z","path":"posts/e2c95240/","text":"概述主要实现的功能是有个活动的结果弹窗在进入页面会自动弹出来一次，当天只弹出一次，直到活动结束为止。 实现逻辑 使用 addCookie SetCookie getCookie 三个公用的方法来实现操作。 首次载入页面时先判断当前时间是否在活动时间内，之后使用 getCookie 判断 cookie 是否存在，如果不存在使用 addCokie 添加 cookie（这里的 cookie 的值设置为当天的日期值）并弹出弹窗；如果存在的话判断 cookie 的值，如果等于当天的日期值弹出弹窗 在关闭弹窗的时候也得先判断是否有这个 cookie ，因为可能活动已经结束了，再使用 SetCookie 对 cookie 的值进行修改，这里将当天的日期值加 1 后的值赋给 SetCookie 的第二个参数，再用活动结束后的时间减去当天的时间最后算出离活动还有几天的天数，将这个天数的值当作是 SetCookie 的第三个参数，这里需要注意的是如果天数小于 1 那么这个方法执行完之后会默认将 cookie 删掉。 整个的执行测试过程：在今天进入这个页面之后因为没有 cookie 会生成这个 cookie ，cookie 的有效时间至活动结束之前（addCookie 的第三个参数，这个是按照小时数换算的），cookie 的值（第二个参数）设置为当天的日期，这时点击关闭弹窗的按钮修改 cookie 的日期值，之后在今天的其他时间之内再次进入页面的时候会进行日期判断，此时的日期值会是明天的所以不会弹出弹窗，到了第二天再次进入时因为日期值又相等了，所以还会有弹窗，然后点击关闭日期加 1 ，这样直至活动结束，弹出弹窗之后再点击关闭按钮，时间相减的值取整数为 0 ，这样 SetCookie 执行后会自动将这个 cookie 删掉了。 //三个公用方法 //添加cookie function addCookie(objName, objValue, objHours) { var str = objName + '=' + escape(objValue); if (objHours > 0) { //为0时不设定过期时间，浏览器关闭时cookie自动消失 var date = new Date(); var ms = objHours * 3600 * 1000; date.setTime(date.getTime() + ms); str += '; expires=' + date.toGMTString(); } document.cookie = str + '; path=/'; } //修改cookie function SetCookie(c_name, value, expiredays) { var exdate = new Date(); exdate.setDate(exdate.getDate() + expiredays); document.cookie = c_name + '=' + escape(value) + (expiredays == null ? '' : ';expires=' + exdate.toGMTString()) + '; path=/'; } //取cookies函数 function getCookie(name) { var arr = document.cookie.match(new RegExp('(^| )' + name + '=([^;]*)(;|$)')); if (arr != null) return unescape(arr[2]); return null; } //页面脚本中用到的地方，下面的 #now_date1 的 value 是服务器获取的当前的百度时间 供 JS 调用 var nowDate = $('#now_date1').val(); //服务器当前时间 //增加弹窗 cookie this.addpopupcookie = function() { var _me = this; var start = new Date(nowDate); var end = new Date('2018/1/2'); if (start &lt; end) { var cookiestr = getCookie('popuptoogle'); if (!cookiestr) { var date = start.getDate() + ''; var hours = parseInt((end - start) / 1000 / 3600); addCookie('popuptoogle', date, hours); $('.lay-popup5').show(); } else if (parseInt(cookiestr) &lt;= start.getDate()) { $('.lay-popup5').show(); } } return _me; }; //公用的关闭弹窗 this.closelaypopup = function(e) { var _me = this; //console.log(e.target.parentNode.parentNode.parentNode); if (e != null &amp;&amp; getCookie('popuptoogle')) { if ($(e.target.parentNode.parentNode.parentNode).hasClass('lay-popup5')) { var now = new Date(nowDate); var date = now.getDate() + 1 + ''; var days = parseInt((new Date('2018/1/2') - now) / 1000 / 3600 / 24); SetCookie('popuptoogle', date, days); } } $('#lay-popup-bg,.lay-popup').hide(); _me.ioslayclosepopup(); return _me; };","tags":[{"name":"javascript","slug":"javascript","permalink":"http://coder.liusixin.cn/tags/javascript/"},{"name":"项目实践","slug":"项目实践","permalink":"http://coder.liusixin.cn/tags/项目实践/"},{"name":"Cookie","slug":"Cookie","permalink":"http://coder.liusixin.cn/tags/Cookie/"}]},{"title":"造轮子系列：JS封装选项卡组件","date":"2017-09-26T13:12:57.000Z","path":"posts/5f666ea6/","text":"封装一个选项卡通常情况下，选项卡由两部分组成。一部分是头部，它包含一堆按钮，每一个按钮对应不同的页面，按钮包括选中与无法选中两种状态。另一部分则由一些具体的页面组成，当我们单击按钮时，就切换到对应的页面。 如果每个页面中包含的是根据动态加载的数据渲染出来的界函，那么通常只会有一个页面，单击按钮时重新加载数据并重新渲染页面。 先初始化html &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"> &lt;title>封装选项卡&lt;/title> &lt;style> body { margin: 0; } ul, li { list-style: none; padding: 0; } .box { max-width: 400px; margin: 10px auto; background: #efefef; } .box .tab_options { height: 40px; display: flex; justify-content: space-around; border-bottom: 1px solid #ccc; } .box .tab_options li { line-height: 40px; cursor: pointer; } .box .tab_options li.active { color: red; border-bottom: 1px solid red; } .box .tab_content { position: relative; min-height: 400px; } .box .tab_content .item_box { position: absolute; left: 0; top: 0; width: 100%; text-align: center; display: none; } .box .tab_content .item_box.active { display: block; } &lt;/style> &lt;/head> &lt;body> &lt;div class=\"box\" id=\"tab_wrap\"> &lt;ul class=\"tab_options\"> &lt;li data-index=\"0\" class=\"item active\">tab1&lt;/li> &lt;li data-index=\"1\" class=\"item\">tab2&lt;/li> &lt;li data-index=\"2\" class=\"item\">tab3&lt;/li> &lt;li data-index=\"3\" class=\"item\">tab4&lt;/li> &lt;/ul> &lt;div class=\"tab_content\"> &lt;div class=\"item_box active\">tab box 1&lt;/div> &lt;div class=\"item_box\">tab box 2&lt;/div> &lt;div class=\"item_box\">tab box 3&lt;/div> &lt;div class=\"item_box\">tab box 4&lt;/div> &lt;/div> &lt;/div> &lt;/body> &lt;/html> 实现原理在 HTML 代码中，每一个头部按钮都保存了一个 data-index 属性，这个属性告诉我们这是第几个按钮，这个值同时也对应第几页。 因此只需声明一个 index 变量来保存当前页的序列，井在单击时把当前页的值修改为 data-index 的值就可以了。与此同时，把当前按钮修改为选中状态，其他按钮修改为未选中状态，让当前页显示，其他页隐藏即可。 var tabHeader = document.querySelector('.tab_options'); var items = tabHeader.children; var tabContent = document.querySelector('.tab_content'); var itemboxes = tabContent.children; var index = 0; tabHeader.addEventListener('click', function(e) { var a = [].slice.call(e.target.classList).indexOf('item'); if(a > -1 &amp;&amp; index != e.target.dataset.index) { items[index].classList.remove('active'); itemboxes[index].classList.remove('active'); index = e.target.dataset.index; items[index].classList.add('active'); itemboxes[index].classList.add('active'); } }, false) 此时假设要新增一个功能，即在 HTML 中新增两个按钮，单击它们就可以分别切换到上一页或下一页 &lt;button class=\"next\">Next&lt;/button> &lt;button class=\"prev\">Prev&lt;/button> 为了更直观地实现这个功能，我们将选项卡封装为一个对象 !function(ROOT) { // var index = 0; function Tab(elem) { this.index = 0; this.tabHeader = elem.firstElementChild; this.items = this.tabHeader.children; this.tabContent = elem.lastElementChild; this.itemboxes = this.tabContent.children; this.max = this.items.length - 1; this.init(); } Tab.prototype = { constructor: Tab, init:function() { this.tabHeader.addEventListener('click', this.clickHandler.bind(this), false); }, clickHandler: function(e) { var a = [].slice.call(e.target.classList).indexOf('item'); if(a > -1) { this.switchTo(e.target.dataset.index); } }, switchTo: function(i) { if(i == this.index) { return; } this.items[this.index].classList.remove('active'); this.itemboxes[this.index].classList.remove('active'); this.index = i; this.items[this.index].classList.add('active'); this.itemboxes[this.index].classList.add('active'); }, next: function() { var tgIndex = 0; if(this.index >= this.max) { tgIndex = 0; } else { tgIndex = this.index + 1; } this.switchTo(tgIndex); }, pre: function() { var tgIndex = 0; if(this.index == 0) { tgIndex = this.max; } else { tgIndex = this.index - 1; } this.switchTo(tgIndex); }, getIndex: function() { return this.index; } } ROOT.Tab = Tab; }(window); 在上面的代码中，将切换功能封装成了基础的 switchTo 方法，它接收一个表示页面序列的参数，只要我们调用这个方法，就能够切换到对应的页面。因此基于这个基础方法，就能够很容易地扩展出下一页 next 与上一页 pre 的方法。 var tab = new Tab(document.querySelector('#tab_wrap')); document.querySelector('.next').addEventListener('click', function() { tab.next(); console.log(tab.getIndex()); }, false); document.querySelector('.prev').addEventListener('click', function() { tab.pre(); console.log(tab.getIndex()); }, false);","tags":[{"name":"javascript","slug":"javascript","permalink":"http://coder.liusixin.cn/tags/javascript/"}]},{"title":"VUE 学习笔记——核心概念","date":"2017-09-24T13:17:20.000Z","path":"posts/870730ac/","text":"1. VUE 核心技术 \b node_modules 下 vue\b 有多个版本，因为 vue 提供不同环境的支持 import vue 默认使用 vue.runtime.esm.js vue.runtime.esm.js; // 开发环境默认 vue.runtime.min.js; // 正式环境 runtime 和没有 runtime 的区别在于是否可以在 vue 对象里写 template,runtime 文件不能写入模板 resolve: { alias: { 'vue': path.join(__dirname, '../node_modules/vue/dist/vue.esm.js') // 指定使用哪个vue文件 } } \"rules\": { \"no-new\": \"off\" // eslint默认不允许直接使用new } 1.1 vue 实例 VUE 实例的创建和作用 VUE 实例的属性 VUE 实例的方法 1.1.1 VUE 实例的创建和作用创建实例 import Vue from 'vue'; new Vue({ el: '#root', template: '&lt;div>hello world&lt;/div>' }); 另外一种方式 import Vue from 'vue' const app = new Vue({ template: '&lt;div>hello world&lt;/div>' }) app.$mount('#root) 绑定数据方式 import Vue from 'vue'; const app = new Vue({ template: '&lt;div>{{text}}&lt;/div>', data: { text: 0 } }); app.$mount('#root'); setInterval(() => { app.text += 1; }, 500); 1.1.2 vue 实例属性app.$data; app.$props; app.$el; app.$options; app.$options.render = h => { return h('div', {}, 'test'); }; app.$root === app; // true,每个节点都可以调用，返回的都是顶层的root app.$children; app.$slots; // 插槽 app.$scopedSlots; app.$refs; // 快速定位节点，返回html节点，组件会返回组件实例 app.$isServer; // 服务端渲染判断 1.1.3 vue 实例方法监听变化 app.$watch('text', (newText, oldText) => { // 监听新值和旧值 console.log(`${newText}, ${oldText}`); }); // 这种写法需要手动去注销值 const unWatch = app.$watch('text', (newText, oldText) => { // 监听新值和旧值 console.log(`${newText}, ${oldText}`); }); setTimeout(() => { unWatch(); }, 2000); \b// 常用写法,这种方式会自动注销 const app = new Vue({ template: '&lt;div>{{text}}&lt;/div>', data: { text: 0 }, watch: { text(newText, oldText){} } }) 事件监听 app.$on('test', (a, b) => { // 作用域于一个对象才会生效，不会冒泡 console.log(`${a},${b}`); // 1 2 }); app, $emit('test', 1, 2); // 可以传递参数 app.$once('test', () => {}); // 只触发一次 app, $emit('test'); 强制重新渲染组件 vue 中，如果没有给 data 中的属性赋值，那这个属性就是非响应式的，不会引起 vue 进行一个重新渲染的过程 const app = new Vue({ template: '&lt;div>{{text}}{{obj.a}}&lt;/div>', data: { text: 0\b, obj: {} } }).$mount('#root') let i = 0 setInterval(() => { i++ app.obj.a = i }, 1000) 此时发现 obj 并没有渲染出来，但是值在变化 let i = 0; setInterval(() => { i++; app.obj.a = i; app.$forceUpdate(); // 强制重新渲染组件 }, 1000); 但是不建议这么做，可以提前声明一个默认值。还有另外一种方法 let i = 0; setInterval(() => { i++; app.obj.a = i; app.$set(app.obj, 'a', i); // 相当于补上一个响应式属性 app.$delete; // 对应的删除方法 }, 1000); vue 的渲染过程是异步的，在改了属性并不是立刻会渲染刷新掉，会有一个异步队列，如果连续改了多次，它会一次性渲染，整个过程异步渲染。如果想在值渲染结束后对它进行修改，可以使用 app.$nextTick(callback) app.$nextTick(callback)在下一次更新后才会传入 callback 1.2 VUE 的生命周期import Vue from 'vue'; new Vue({ el: '#root', template: '&lt;div>{{text}}&lt;/div>', data: { text: 0 }, beforeCreate() { console.log(this, 'beforeCreate'); }, created() { console.log(this, 'created'); }, beforeMount() { // 组件被渲染前执行 console.log(this, 'beforeMount'); }, mounted() { // 组件被渲染执行 console.log(this, 'mounted'); }, beforeUpdate() { // 数据更新前才会执行 console.log(this, 'beforeUpdate'); }, updated() { // 数据更新才会执行 console.log(this, 'updated'); }, activated() { // keep-alive触发 console.log(this, 'activated'); }, deactivated() { console.log(this, 'deactivated'); }, beforeDestroy() { console.log(this, 'beforeDestroy'); }, destroyed() { console.log(this, 'destroyed'); } }); setTimeout(() => { // app.$destroy() // 销毁组件 }, 1000); // beforeCreate // created // beforeMount // mounted // el: '#root', 注释掉这句,发现下面这两句无论如何都会执行 // beforeCreate // created 由此可以发现，mount 就是把组件生成的 html 内容挂载到 dom 上的过程 beforeCreate () { // 事件已经ok，响应式数据还没有生成，所以不要修改data里数据，如果ajax异步请求数据，最早也要在create里去做 console.log(this.$el, 'beforeCreate') //undefined }, created () { console.log(this.$el, 'created') //undefined }, beforeMount () { // 渲染初始化，之后判断是否有template，有的话会解析成 render(h) 函数，之后进行到mounted console.log(this.$el, 'beforeMount') //&lt;div id=\"root\">&lt;/div> }, mounted () { console.log(this.$el, 'mounted') //&lt;div>0&lt;/div> }, 在服务端渲染的时候只会调用 beforeCreate 和 created。因为 mount 渲染是跟 dom 有关，服务端渲染没有 dom 执行的环境 vue 内部还有 renderError()函数。只会在开发环境使用 render(h) { throw new TypeError('render error') } renderError(h, err){ return h('div', {}, err.stack) // render函数出错会调用 } errorCaptured(){ // 收集线上错误，如果在根组件定义，会捕捉所有子组件错误 // 会向上冒泡，并且正式环境可以使用 } 1.3 VUE 数据绑定import Vue from 'vue'; new Vue({ el: '#root', template: ` &lt;div v-bind:id=\"box\" v-on:click=\"handleClick\"> &lt;p v-html=\"html\">&lt;/p> &lt;/div> `, data: { text: 'aaa', html: `&lt;span>haha&lt;/span>`, box: 'content' }, methods: { handleClick() { console.log('click'); } } }); // &lt;div id=\"content\">&lt;p>&lt;span>haha&lt;/span>&lt;/p>&lt;/div> v-html // 绑定html节点要使用v-html，防止注入攻击。 v-bind // 绑定动态数据。 v-on // 绑定事件。可以简写成 @click :class // 动态绑定class 动态绑定 class template: ` &lt;div :class=\"{ active: isActive }\"> &lt;p v-html=\"html\">&lt;/p> &lt;/div> `, data: { isActive: false } // 另一种写法 template: ` &lt;div :class=\"[isActive ? 'active' : '']\"> &lt;p v-html=\"html\">&lt;/p> &lt;/div> `, data: { isActive: false } // 第三种写法:对象方式 template: ` &lt;div :class=\"[{ active: isActive }]\"> &lt;p v-html=\"html\">&lt;/p> &lt;/div> `, data: { isActive: false } :style 样式绑定 template: ` &lt;div :class=\"[{ active: isActive }]\" :style=\"[styles1, styles2]\" > &lt;p v-html=\"html\">&lt;/p> &lt;/div> `, data: { styles1: { color: 'red' }, styles2: { font-size: 16px } } 1.4 computed 计算属性import Vue from 'vue'; new Vue({ el: '#root', template: ` &lt;div> &lt;p>Name：{{name}}&lt;/p> &lt;p>Name：{{getName()}}&lt;/p> &lt;p>&lt;input type=\"text\" v-model=\"number\" />>&lt;/p> &lt;/div> `, data: { firstName: 'liu', lastName: 'sixin', number: 0 }, computed: { name() { console.log('name'); return `${this.firstName} ${this.lastName}`; } }, methods: { getName() { console.log('getName'); return `${this.firstName} ${this.lastName}`; } } }); 输入框 \b 每次改变会重新渲染页面，同时会看到 getName 会多次调用，而 computed 里面则会缓存值 computed: { name: { get(){}, set(name){} } } 尽量不要使用 set，会导致项目逻辑变得很复杂 1.5 watch有点类似于 computed 第一次绑定不会执行，只有数据变化才会，\b 如果需要首次就调用 watch: { firstName: { handler(newName, oldName){ this.fullName = newName + ' ' + this.lastName }, immediate: true, // 首次就执行 deep: true // 深度监听，对象的属性变化也会被监听，性能开销大 } } watch 有个明显劣势就是监听多个东西就要加多个 handler，并不适用于显示某个数据，用 computed 更好。 watch 更多用于监听到数据变化向后台发请求，computed 做不到。具体就是监听到某个数据变化要做某个操作的时候用 watch。 deep 对性能开销比较大，可以修改成字符串形式 watch: { 'obj.a': { handler(){ console.log('a is changed') }, immediate: true } } 重点：不要在 computed 和 watch 里修改原来的属性，最好是生成新的** 1.6 VUE 原生指令v-text // 标签里要显示的内容，内容多的话使用数据绑定 v-html v-show // 相当于display：none v-if // 会增删节点，影响重绘 v-else-if v-else // 对应v-if v-for \b&lt;li v-for=\"(item, index) in arr\" :key=\"item\">{{item}}&lt;/li> \b&lt;li v-for=\"(val, key, index) in obj\">{{val}}:{{key}}{{index}}&lt;/li> data:{ arr: [1,2,3], obj: { a: 123, b: 456, c: 789 } } v-on v-model v-pre // 内容不会做任何解析 v-cloak v-once // 数据绑定内容只执行一次，节省开销 key 值尽量不要用 index 去做，因为数组发生变化后，index 也会跟着变化，可能会导致错误 修饰符 template: ` &lt;div> &lt;div> &lt;input type=\"text\" v-model.number=\"text\" /> &lt;/div> &lt;div> &lt;input type=\"checkbox\" :value=\"1\" v-model=\"arr\" /> &lt;input type=\"checkbox\" :value=\"2\" v-model=\"arr\" /> &lt;input type=\"checkbox\" :value=\"3\" v-model=\"arr\" /> &lt;/div> &lt;div> &lt;input type=\"radio\" v-model=\"picked\" /> &lt;input type=\"radio\" v-model=\"picked\" /> &lt;/div> &lt;/div> `, data: { text: 0, active: false, arr: [1, 2, 3], picked: '' } .number 修饰符，会自动转化为数字 .trim 修饰符，会去除空格 .lazy 事件修饰符，会增加 change 事件，不加默认是 input 2. VUE 组件2.1 组件核心import Vue from 'vue'; const component = { template: `&lt;div>component&lt;/div>` }; Vue.component('CompOne', component); new Vue({ el: '#root', template: `&lt;comp-one>&lt;/comp-one>` }); 组件的数据传递 import Vue from 'vue'; const component = { props: { active: Boolean }, template: ` &lt;div> &lt;p>&lt;span v-show=\"active\">{{num}}&lt;/span>&lt;/p> &lt;p>&lt;span>{{num}}&lt;/span>&lt;/p> &lt;p>&lt;input type=\"button\" @click=\"hander\" value=\"+\" />&lt;/p> &lt;/div> `, data() { return { num: 0 }; }, methods: { hander() { this.num++; } } }; Vue.component('comp', component); new Vue({ el: '#root', template: ` &lt;div> &lt;comp :active=\"true\">&lt;/comp> &lt;comp>&lt;/comp> &lt;/div> ` }); import Vue from 'vue'; const component = { props: { active: Boolean, propOne: String }, template: ` &lt;div> &lt;input type=\"text\" v-model=\"text\" /> &lt;p>&lt;span @click=\"\"handleChange>{{propOne}}&lt;/span>&lt;/p> &lt;p>&lt;span v-show=\"active\">{{text}}&lt;/span>&lt;/p> &lt;/div> `, data() { return { text: 0 }; }, methods: { handleChange() { this.$emit('change'); } } }; Vue.component('comp', component); new Vue({ el: '#root', template: ` &lt;div> &lt;comp :active=\"true\" :prop-one=\"prop1\" @change=\"handleChange\">&lt;/comp> &lt;comp :active=\"false\" prop-one=\"prop2\">&lt;/comp> &lt;/div> `, methods: { handleChange() { this.prop1 += 1; } } }); 默认值 import Vue from 'vue'; const component = { props: { active: { type: Boolean, required: true, default: false } } }; require 和 default 二选一即可 props: { active: { type: Boolean, default () { // 如果指定的是对象，要使用这种方式 return { } }, } } 函数方式校验 props: { active: { validator (value) { // 更严格的校验，去掉type return typeof value === 'boolean' } } } new Vue({ el: '#root', template: ` &lt;div> &lt;comp :active=\"true\" :prop-one=\"prop1\" @change=\"handleChange\">&lt;/comp> &lt;/div> ` }) 2.2 extend 组件继承const CompVue = Vue.extend(component) new CompVue({ el: '#root' propsData: { propOne: 'xxx' }, data: { text: 'haha' }, mounted () { console.log('comp mounted111') } }) 通过 propsData 拿到值 mounted 会在 \b 原组件先被调用，再调用继承组件内的 mounted 另一种方式 const component1 = {}; const component2 = { extend: component, data() { return { text: 1 }; }, mounted() { console.log('comp2 mounted'); console.log(this.$parent.$options.name); // Root } }; new Vue({ name: 'Root', el: '#root', components: { Comp: component2 }, template: `&lt;comp>&lt;/comp>` }); const parent = new Vue({ name: 'parent' }); const component2 = { extend: component, data() { return { text: 1 }; }, mounted() { console.log(this.$parent.$options.name); } }; new Vue({ parent: parent, name: 'Root', el: '#root', components: { Comp: component2 }, data: { text: 23333 }, template: ` &lt;div> &lt;span>{{text}}&lt;/span> &lt;comp>&lt;/comp> &lt;/div> `, mounted() { console.log(this.$parent.$options.name); } }); // Root // parent 2.3 组件实现自定义双响绑定import Vue from 'vue'; const component = { props: ['value'], template: ` &lt;div> &lt;input type=\"text\" @input=\"handleInput\" :value=\"value\" /> &lt;/div> `, methods: { handleInput(e) { this.$emit('input', e.target.value); } } }; new Vue({ el: '#root', components: { CompOne: component }, data() { return { value: '123' }; }, template: ` &lt;div> &lt;comp-one :value=\"value\" @input=\"value = arguments[0]\">&lt;/comp-one> &lt;/div> ` }); 可以直接写成 v-model import Vue from 'vue'; const component = { props: ['value'], template: ` &lt;div> &lt;input type=\"text\" @input=\"handleInput\" :value=\"value\" /> &lt;/div> `, methods: { handleInput(e) { this.$emit('input', e.target.value); } } }; new Vue({ el: '#root', components: { CompOne: component }, data() { return { value: '123' }; }, template: ` &lt;div> &lt;comp-one :value=\"value\" v-model=\"value\">&lt;/comp-one> &lt;/div> ` }); 这就是在组件内部实现 v-model 最简单的方式，只需要在一个组件里加上 props，通过事件把这个值 emit 出去，这就实现了双向绑定。 v-model 内部帮我们处理了双响绑定的逻辑 有时候 prop 要处理的值和我们定义的值会冲突，我们不想同时改变，可以这样写 import Vue from 'vue'; const component = { model: { prop: 'value1', event: 'change' }, props: ['value1'], template: ` &lt;div> &lt;input type=\"text\" @input=\"handleInput\" :value=\"value1\" /> &lt;/div> `, methods: { handleInput(e) { this.$emit('change', e.target.value); } } }; new Vue({ el: '#root', components: { CompOne: component }, data() { return { value: '123' }; }, template: ` &lt;div> &lt;comp-one :value=\"value\" v-model=\"value\">&lt;/comp-one> &lt;/div> ` }); 2.4 组件高级属性2.4.1 插槽import Vue from 'vue'; const component = { template: ` &lt;div\b :style=\"style\"> &lt;slot>&lt;/slot> &lt;/divd> `, data() { return { style: { width: '200px', height: '200px', border: '1px solid #aaa' } }; } }; new Vue({ el: '#root', components: { CompOne: component }, data() { return { value: '123' }; }, template: ` &lt;div> &lt;comp-one> &lt;span>this is content&lt;/span> &lt;/comp-one> &lt;/div> ` }); 2.4.2 具名插槽import Vue from 'vue'; const component = { template: ` &lt;div\b :style=\"style\"> &lt;div class=\"header\"> &lt;slot name=\"header\">&lt;/slot> &lt;/div> &lt;div class=\"body\"> &lt;slot name=\"body\">&lt;/slot> &lt;/div> &lt;/divd> `, data() { return { style: { width: '200px', height: '200px', border: '1px solid #aaa' } }; } }; new Vue({ el: '#root', components: { CompOne: component }, data() { return { value: '123' }; }, template: ` &lt;div> &lt;comp-one> &lt;span slot=\"header\">this is header&lt;/span> &lt;span slot=\"body\">this is body&lt;/span> &lt;/comp-one> &lt;/div> ` }); 2.4.3 scoped slot 作用域插槽import Vue from 'vue'; const component = { template: ` &lt;div\b :style=\"style\"> &lt;slot value=\"456\">&lt;/slot> &lt;/divd> `, data() { return { style: { width: '200px', height: '200px', border: '1px solid #aaa' } }; } }; new Vue({ el: '#root', components: { CompOne: component }, data() { return { value: '123' }; }, template: ` &lt;div> &lt;comp-one> &lt;span slot-scope=\"props\">{{props.value}}&lt;/span> &lt;/comp-one> &lt;/div> ` }); 同样可以使用 v-bind 方式传值 import Vue from 'vue'; const component = { template: ` &lt;div\b :style=\"style\"> &lt;slot :value=\"value\">&lt;/slot> &lt;/divd> `, data() { return { style: { width: '200px', height: '200px', border: '1px solid #aaa' }, value: 'hahaha' }; } }; new Vue({ el: '#root', components: { CompOne: component }, data() { return { value: '123' }; }, template: ` &lt;div> &lt;comp-one ref=\"comp\"> &lt;span ref=\"span\" slot-scope=\"props\">{{props.value}} {{value}}&lt;/span> &lt;/comp-one> &lt;/div> `, mounted() { console.log(this.$refs.comp, this.$refs.span); } }); 注意：this.$refs.comp 会打印出组件的实例，可以调用 options。而 this.$refs.span 打印的是 html 节点。\b 2.4.4 provide 跨级数据联动 子孙组件获取祖先组件的方式使用 provide，跨级数据联动 import Vue from 'vue'; const ChildComponent = { template: '&lt;div>child component: {{value}}&lt;/div>', inject: ['grandParent', 'value'], mounted() { console.log(this.grandParent); } }; const component = { name: 'comp', components: { ChildComponent }, template: ` &lt;div :style=\"style\"> &lt;slot :value=\"value\" aaa=\"111\">&lt;/slot> &lt;child-component /> &lt;/div> `, data() { return { style: { width: '200px', height: '200px', border: '1px solid #aaa' }, value: 'component value' }; } }; new Vue({ el: '#root', components: { CompOne: component }, provide() { return { grandParent: this, value: this.value }; }, data() { return { value: '123' }; }, template: ` &lt;div> &lt;comp-one> &lt;span slot-scope=\"props\">{{props.value}}&lt;/span> &lt;/comp-one> &lt;/div> ` }); 默认 provide 不提供响应式属性，不管父组件怎么变，子组件都不会显示。要想数据能够传递，我们需要自己定义响应式 import Vue from 'vue'; const ChildComponent = { template: '&lt;div>child component: {{data.value}}&lt;/div>', inject: ['grandParent', 'data'], mounted() { console.log(this.grandParent, this.value); } }; const component = { name: 'comp', components: { ChildComponent }, template: ` &lt;div :style=\"style\"> &lt;slot :value=\"value\" aaa=\"111\">&lt;/slot> &lt;child-component /> &lt;/div> `, data() { return { style: { width: '200px', height: '200px', border: '1px solid #aaa' }, value: 'component value' }; } }; new Vue({ el: '#root', components: { CompOne: component }, provide() { const data = {}; Object.defineProperty(data, 'value', { //指定这方法相当于子组件每次调用value值时实际调用的是get方法，这个方法每次会获取最新的value get: () => this.value, enumerable: true // 可以被读取 }); return { grandParent: this, data //必须作为\breturn的整个object属性返回，\b如果直接返回data，会直接调用value.get()方法，每次得到的就是一个值，不会进行更新，只有通过data.value去调用的时候每次才会再次调用get方法。 }; }, data() { return { value: '123' }; }, template: ` &lt;div> &lt;comp-one> &lt;span slot-scope=\"props\">{{props.value}}&lt;/span> &lt;/comp-one> &lt;input type=\"text\" v-model=\"value\" /> &lt;/div> ` }); 官方不推荐这么使用，vue 版本升级可能会改变 2.5 组件的 render function2.5.1 渲染函数template 是字符串，要经过编译转换成 html 节点这个过程。在使用 template 的时候会经过生命周期的一个过程，叫做编译，编译成一个 js 的函数，叫做 render function new Vue({ el: '#root', template: ` &lt;div> &lt;comp-one> &lt;span ref=\"span\">{{value}}&lt;/span> &lt;/comp-one> &lt;/div> `, render() { return this.$createElement(); }, // 也可以写成 render(createElement) { return createElement(); } }); import Vue from 'vue'; const component = { name: 'comp', // template: ` // &lt;div :style=\"style\"> // &lt;slot>&lt;/slot> // &lt;/div> // `, render(createElement) { return createElement( 'div', { style: this.style }, this.$slots.default ); }, data() { return { style: { width: '200px', height: '200px', border: '1px solid #aaa' }, value: 'component value' }; } }; new Vue({ el: '#root', components: { CompOne: component }, data() { return { value: '123' }; }, // template: ` // &lt;div> // &lt;comp-one> // &lt;span ref=\"span\">{{value}}&lt;/span> // &lt;/comp-one> // &lt;/div> // `, render(createElement) { return createElement( 'comp-one', { ref: 'comp' }, [ createElement( 'span', { ref: 'span' }, this.value ) ] ); } }); createElement 就是 vue 中虚拟 dom 的概念。创建出来的并不是真正的 dom 节点，而是 vnode 的一个类，\bvnode 会在内存中存储，会和真正的 dom 进行对比，如果发现需要更新，才会把 vnode 转换成 dom 内容，插入到真正的 dom 中。 render (createElement) { return createElement( 'comp-one', { ref: 'comp', props: { props1\b: this.value }, on: { click: this.handleClick } }, [ createElement('span', { ref: 'span' }, this.value) ]) }","tags":[{"name":"编程笔记","slug":"编程笔记","permalink":"http://coder.liusixin.cn/tags/编程笔记/"},{"name":"Vue","slug":"Vue","permalink":"http://coder.liusixin.cn/tags/Vue/"}]},{"title":"web开发bug&小技巧整理","date":"2017-09-21T12:12:53.000Z","path":"posts/4b06823/","text":"html 页面写 IE hack 详细说明资料的请参看网址：关于 IE 的一些 hack - ！win ！ - 博客园 ie 的条件语句常用的有几下几种（所有条件注释语句在非 IE 浏览器下都是普通的注释，不要用非 ie 去给非 IE 的浏览执行操作）： lt ：就是 Less than 的简写，也就是小于的意思。 lte ：就是 Less than or equal to 的简写，也就是小于或等于的意思。 gt ：就是 Greater than 的简写，也就是大于的意思。 gte：就是 Greater than or equal to 的简写，也就是大于或等于的意思。 !：就是不等于的意思，跟 javascript 里的不等于判断符相同。 &lt;!--[if IE]> 只有IE才支持 &lt;![endif]--> &lt;!--[if !IE 7]> IE7不支持 &lt;![endif]--> &lt;!--[if lt IE 8]> IE8以下浏览器才支持 &lt;![endif]--> &lt;!--[if lte IE 8]> IE8及以下浏览器才支持 &lt;![endif]--> &lt;!--[if gt IE 8]> IE8以上浏览器才支持 &lt;![endif]--> &lt;!--[if gte IE 8]> IE8及以上浏览器才支持 &lt;![endif]--> &lt;!--[if lt IE 9]> IE9 以下 &lt;![endif]--> iOS 端页面中做弹窗，当弹窗弹出时会出现一个：上下滑动时影响到弹窗下面的内容也就是 container 内容的滚动条 在 layout css 全局中新增一个类名样式 /* 弹窗专用 禁止滚轮 滚动*/ .scrollnone { width: 100%; height: 100%; overflow: hidden; position: fixed; max-width: 640px; min-width: 320px; left: 0; right: 0; margin: auto; } //公用的手机端处理 iOS 弹窗 bug this.ioslayopenpopup = function() { var _me = this; $('body,html').addClass('scrollnone'); return _me; }; //公用的手机端处理 iOS 弹窗 bug this.ioslayclosepopup = function() { var _me = this; $('body,html').removeClass('scrollnone'); return _me; }; //公用的关闭弹窗 this.closelaypopup = function() { var _me = this; $('#lay-popup-bg,.lay-popup').hide(); _me.ioslayclosepopup(); return _me; }; //打开报名弹窗 this.openlaypopup0 = function() { var _me = this; _me.closelaypopup(); $('#lay-popup-bg,.lay-popup0').show(); _me.ioslayopenpopup(); return _me; }; 手机端使用的一些全局的样式代码片段/*文本单行溢出隐藏*/ .txtoneline { overflow: hidden; white-space: nowrap; text-overflow: ellipsis; } /*文本多行溢出隐藏 -webkit-line-clamp: 2; 溢出行数*/ .txtmorline { display: -webkit-box; -webkit-box-orient: vertical; overflow: hidden; text-overflow: ellipsis; } /* 公用限制最大最小宽，且居中显示类名 */ .limitcen { max-width: 640px; min-width: 320px; margin: 0 auto; width: 100%; } /* 公用完美居中样式 */ .perfectcen { position: absolute; left: 0; right: 0; top: 0; bottom: 0; margin: auto; } html { font-size: calc(100vw / 3.75); } /* 对浏览器兼容性要求较高 CSS3 属性 */ html, body { font-size: 14px; font-family: 'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'Heiti SC', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif; background: #f3f3f3; color: #333; -webkit-text-size-adjust: none; -moz-text-size-adjust: none; -ms-text-size-adjust: none; text-size-adjust: none; padding: 0; margin: 0 auto; max-width: 640px; min-width: 320px; -webkit-tap-highlight-color: rgba(0, 0, 0, 0); /* 取消链接高亮 */ } /*清除浮动*/ .clearfix:after { content: ' '; display: block; height: 0; clear: both; } .clearfix { *zoom: 1; } /*IE6/7*/ /*表单元素统一初始化样式*/ input, select, button { vertical-align: middle; margin: 0; font-family: microsoft yahei; -webkit-appearance: none; /*去除阴影*/ border: 0; outline: 0; background-color: transparent; } .checkbox { -webkit-appearance: checkbox; } input[type='checkbox'] { -webkit-appearance: checkbox; } select { background: url('/Images/share/icon-select-arrow.png') no-repeat scroll right center transparent; background-size: 0.14rem 0.08rem; } /*input palceholder 样式自定义*/ input::-webkit-input-placeholder, textarea::-webkit-input-placeholder { color: #999; } /* 使用webkit内核的浏览器 */ input:-moz-placeholder, textarea::-webkit-input-placeholder { color: #999; } /* Firefox版本4-18 */ input::-moz-placeholder, textarea::-webkit-input-placeholder { color: #999; } /* Firefox版本19+ */ input:-ms-input-placeholder, textarea::-webkit-input-placeholder { color: #999; } PC 端滚动条样式自定义代码片段/*自定义滚动条样式*/ .common-scrollbar::-webkit-scrollbar { width: 5px; } .common-scrollbar::-webkit-scrollbar-thumb { background-color: rgba(0, 0, 0, 0.2); border-radius: 10px; } HTML5 中的 data-*属性和 jQuery 中的.data()方法使用 参考文章链接：http://blog.csdn.net/fly_zxy/article/details/50687691 参考 demo 链接：https://codepen.io/voronianski/pen/aicwk?q=Typewriter&amp;limit=all&amp;type=type-pens HTML5 中的 data-*属性 我们往往会根据需要在 HTML 标记上添加自定义的属性来存储和操作数据，我们自定义的属性名字也千奇百怪，五花八门。我们可以通过原生的 getAttribute()或 jQuery 中的.attr()来获取我们自定义的属性。但是前端技术在向着规范化前进。HTML5 标准规定，自定义的属性都已 data—*开头，这样就区分开了固有属性和自定义属性。HTML5 代码示例如下： &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>data-* 在 HTML5 和 jQ 中的用法&lt;/title> &lt;/head> &lt;body> &lt;div id=\"container\" data-name=\"你好\" data-english-name=\"hello\" data-Age=\"26\">&lt;/div> &lt;script> // JS 的写法 var element = document.getElementById('container'); var dataObject = element.dataset; //获取到的是一个键值对的对象 console.log(dataObject); //DOMStringMap {name: \"你好\", englishName: \"hello\", age: \"26\"} for (var key in dataObject) { //遍历对象的键与值 console.log(key); //name englishName age console.log(dataObject[key]); //你好 hello 26 } &lt;/script> &lt;/body> &lt;/html> 在获取自定义属性的值时，使用dataset属性，然后通过自定义属性data-name的名称去掉data如：dataObject[name]去获取值。dataset是 JS5 规范中新增加的属性，用于和data-*配合使用。 需要注意的是： 如果data-后面包含了“-”，例如 english-name，”-“会被去掉，自动的转换成为骆驼峰式的命名 englishName。这是因为 JSON Object 的 key 不能包含”-“。 如果 data-后面的单词有大写，例如 Age，将会转存成小写 age。 如果你想删除一个 data-*属性，请使用 delete dataset.name或者dataset.name=null; data-*属性看起来很好，但是不幸的是只有在 Chrome 8+ Firefox(Gecko) 6.0+ Internet Explorer 11+ Opera 11.10+ Safari 6+的浏览器中实现了此标准。如果你需要兼容各主流浏览器的不同版本建议还是使用原生的getAttribute()或 jQuery 中的.attr()。 jQuery 中的.data() jQuery 中的.data()方法作用：在 jQuery 对象对应的 DOM 元素上获取或存放 key-value 对。我们可以通过 html5 的 data-属性在元素上存取数据，在 jQuery 也可以通过 data()来实现。data()方法有多个重载，传递一个参数是获取 value 值，传递两个参数是存储或覆盖已存在的值，传递一个 JSON Object 是在元素上存储或覆盖已存在的多个 key-value 对。如果通过 data() 在元素上存储 key-value，value 可以是一个对象，而不是像 data-只能存储一个字符串的 value。下面给出一个综合示例： &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>data-* 在 HTML5 和 jQ 中的用法&lt;/title> &lt;/head> &lt;body> &lt;div id=\"container\" data-name=\"你好\" data-english-name=\"hello\" data-Age=\"26\">&lt;/div> &lt;script> //jQ 写法 var element = $('#container'); var dataObject = element.data(); //获取到的是一个键值对的对象 console.log(dataObject); //{age: 26, englishName: \"hello\", name: \"你好\"} 这个输出的整个的结构和上面的是一样的 但是顺序是相反的 从后往前 $.each(dataObject, function(key, value) { //遍历对象的键与值 console.log(key); //age englishName name console.log(value); //26 hello 你好 console.log($(this)); //r.fn.init [Number] r.fn.init(9) [\"x\", \"i\", \"a\", \"o\", \"c\", \"h\", \"u\", \"a\", \"n\"] r.fn.init(2) [\"你\", \"好\"] element.data(key, value + '1'); //修改 value // element.removeData(key);//删除属性的方法 }); console.log(dataObject); //{age: \"261\", englishName: \"hello1\", name: \"你好1\"} 修改后的对象 但是这个修改并不会影响页面中的属性的值 只是在 jq 中可以调用 &lt;/script> &lt;/body> &lt;/html> .data()可以获取通过 data-属性存储的值。通过.data()修改 data-属性的值不会显示在 HTML 标记中，我们只是通过.data()在元素存储了一个新值。.removeData()也不能删除通过 data-*存储的真正的页面上的数据。由于 jQuery 是一个通用的 JS 框架，对浏览器兼容性做的非常好，大多数情况，我们应该通过.data()在元素上存取数据(有一个好处是可以存储一个对象)。 jQ 官网 API 示例：http://api.jquery.com/jquery.data/ css 实现简单的关闭按钮/*css 实现关闭叉号*/ .css-close-btn(@width: 30px, @height: 30px, @bgcolor: @colorwhite, @linewidth: 30px, @lineheight: 30px, @linebgcolor: @colorwhite) { background-color: @bgcolor; width: @width; height: @height; &amp;:before { content: ''; display: block; position: absolute; width: @linewidth; height: @lineheight; background-color: @linebgcolor; top: 50%; left: 50%; -moz-transform: translate(-50%, -50%) rotate(45deg); -ms-transform: translate(-50%, -50%) rotate(45deg); -o-transform: translate(-50%, -50%) rotate(45deg); -webkit-transform: translate(-50%, -50%) rotate(45deg); transform: translate(-50%, -50%) rotate(45deg); } &amp;:after { content: ''; display: block; position: absolute; width: @linewidth; height: @lineheight; background-color: @linebgcolor; top: 50%; left: 50%; -moz-transform: translate(-50%, -50%) rotate(-45deg); -ms-transform: translate(-50%, -50%) rotate(-45deg); -o-transform: translate(-50%, -50%) rotate(-45deg); -webkit-transform: translate(-50%, -50%) rotate(-45deg); transform: translate(-50%, -50%) rotate(-45deg); } } /*具体的引用实现*/ .rule__close-btn { .css-close-btn( 42 / @layremvalue, 42 / @layremvalue, #ddd, 18 / @layremvalue, 2 / @layremvalue, @colorwhite ); position: absolute; border-radius: 50%; right: 30 / @layremvalue; top: 26 / @layremvalue; } 在手机端上自定义的一些可公用的 less 变量/*配合 js 计算的 rem 使用具体换算设计稿的 20px = 20 / @layremvalue*/ @layremvalue: 100rem; /*flex 垂直居中布局*/ .flex(@align: center) { display: -webkit-flex; display: flex; /*y轴对齐方式 可传参*/ align-items: @align; /*x轴对齐方式*/ /*justify-content:center;*/ } /*换行，第一行在上方*/ .flex_wrap { -ms-flex-wrap: wrap; -webkit-flex-wrap: wrap; flex-wrap: wrap; } /*transform: translateZ(0); 开启动画硬件加速*/ .openanimatequick { -moz-transform: translateZ(0); -ms-transform: translateZ(0); -o-transform: translateZ(0); -webkit-transform: translateZ(0); transform: translateZ(0); /*修复卡顿*/ -moz-backface-visibility: hidden; -webkit-backface-visibility: hidden; backface-visibility: hidden; } /*背景渐变 线性渐变 由下到上 可传色值参数*/ .bggradient-bot-top(@colorstart, @colorend) { background-image: -ms-linear-gradient(bottom, @colorstart, @colorend); background-image: -moz-linear-gradient(bottom, @colorstart, @colorend); background-image: -webkit-gradient( linear, bottom, top, from(@colorstart), to(#872ccf) ); background-image: -webkit-linear-gradient(bottom, @colorstart, @colorend); background-image: -o-linear-gradient(bottom, @colorstart, @colorend); background-image: linear-gradient(0, @colorstart, @colorend); } /*内边框 用阴影实现*/ .shadow-inset(@width: 1px, @color: @coloryellow1, @style: inset) { box-shadow: 0 0 0 @width @color @style; } 手机端的 rem 具体实现方法：将下面的 js 片段放置于 &lt;head&gt;&lt;/head&gt; 标签内部，确保页面加载时优先计算这部分的 js 否则会出现闪屏的 bug//初始化 html fontSize 值 //设计稿 720 //除以7.2 这里是以iphone6 的宽度375px为标准，为了保证html的字体大小为100px。这样我们在换算的时候，1px 就是0.01rem，就很容易计算。（设计稿是 750 w，实际是 720 所以 除以7.2） function calcHtmlFontSize() { var htmlEle = document.documentElement; var htmlWidth = document.documentElement.clientWidth || document.body.clientWidth || window.innerWidth || window.screen.width; //console.log(htmlWidth); //强制改变可视区域的宽度 页面最宽为 640 最窄为320 if (htmlWidth > 640) { htmlWidth = 640; } else if (htmlWidth &lt; 320) { htmlWidth = 320; } //console.log(htmlWidth); htmlEle.style.fontSize = htmlWidth / 7.2 + 'px'; } calcHtmlFontSize(); window.onresize = function() { calcHtmlFontSize(); }; PC 端常用的右侧固定定位的导航条 css 和 js 配合实现less /*活动页面专用右侧固定定位导航 参数的数值可以在引用时随意的修改*/ .activity-fixed__nav(@width: @px120, @height: @px400, @backgroundColor: @coloryellow4, @marginRight: -(600 + @width)) { .openanimatequick; .box-style; position: fixed; width: @width; height: @height; right: 50%; top: 0; bottom: 0; margin: auto @marginRight auto auto; -moz-transition: all 0.5s; -o-transition: all 0.5s; -webkit-transition: all 0.5s; transition: all 0.5s; -moz-transform: scale(0); -ms-transform: scale(0); -o-transform: scale(0); -webkit-transform: scale(0); transform: scale(0); background-color: @backgroundColor; z-index: 99; } /*具体的引用实现*/ .fixed__nav { .activity-fixed__nav; } js //滚轮滚动事件 $(window).scroll(function() { var _this = $(this); var targetTop = _this.scrollTop(); //活动页面专用右侧固定定位导航 动画 if (targetTop > $(window).height() - 600) { $('#fixed__nav').css({ transform: 'scale(1)', '-ms-transform': 'scale(1)', '-moz-transform': 'scale(1)', '-webkit-transform': 'scale(1)', '-o-transform': 'scale(1)' }); } else { $('#fixed__nav').css({ transform: 'scale(0)', '-ms-transform': 'scale(0)', '-moz-transform': 'scale(0)', '-webkit-transform': 'scale(0)', '-o-transform': 'scale(0)' }); } }); 向上的三角形 less/*向上三角形可传参数*/ .triangle-top(@size: @px5, @color: @colorwhite) { width: 0; height: 0; border: solid @size; border-color: transparent transparent @color transparent; } /*具体的引用实现*/ &amp;:before { content: ''; position: absolute; .triangle-top; top: @px7; right: @px13; } 全屏 canvas 不能被选中/*全屏 canvas 不能被选中*/ .full-canvas { position: fixed; left: 0; right: 0; top: 0; bottom: 0; z-index: 999; pointer-events: none; }","tags":[{"name":"javascript","slug":"javascript","permalink":"http://coder.liusixin.cn/tags/javascript/"},{"name":"性能优化","slug":"性能优化","permalink":"http://coder.liusixin.cn/tags/性能优化/"},{"name":"CSS","slug":"CSS","permalink":"http://coder.liusixin.cn/tags/CSS/"}]},{"title":"webpack实践--多页面应用","date":"2017-09-17T12:10:26.000Z","path":"posts/105e749d/","text":"要实现多页面应用 web 我们需要注意几点，首先我们要明白多页应用： 多入口 entry 多页面 html 每个页面不同的 chunk 每个页面不同的参数 实现多页面有两种方式 多配置(webpack3.1.0) parallel-webpack 单配置 多配置 优点 可以使用 parallel-webpack 来提高打包速度 配置更加独立，灵活 缺点 不能多页面之间共享代码(不能提取公用代码) 单配置 优点 共享各个 entry 之间的公用代码 缺点 打包速度比较慢 输出的内容比较复杂 多页面多配置 // parallel-webpack并行处理 parallel-webpack parallel-webpack --watch parallel-webpack --config 以下面项目结构为例 ├── src │ ├── components │ │ └── module.js │ ├── css │ │ ├── a.css │ │ ├── b.css │ │ └── c.css │ ├── pages │ │ ├── a.js │ │ ├── b.js │ │ └── c.js │ └── index.html ├── webpack.config.js ├── package.json └── README.md 基本配置 同时每个页面都引入了 react 公共模块 // webpack.config.js const merge = require('webpack-merge') const webpack = require('webpack') const HtmlWebpackPlugin = require('html-webpack-plugin') const CleanWebpack = require('clean-webpack-plugin') const path = require('path') const baseConfig = { entry: { react: 'react' }, output: { path: path.resolve(__dirname, 'dist'), filename: 'js/[name].[chunkhash].js' }, plugins: [ new CleanWebpack(path.resolve(__dirname, 'dist')), new webpack.optimize.CommonsChunkPlugin({ name : 'react', minChunks: Infinity }) ] } 我们把多页面配置抽离出来封装 // webpack.config.js const generatePage = function ({ title = '', entry = '', template = './src/index.html', name = '', chunks = [] } = {}){ return { entry, plugins: [ new HtmlWebpackPlugin({ chunks, template, filename: name + '.html' }) ] } } const pages = [ generatePage({ title: 'page a', entry: { a: './src/pages/a' }, name: 'a', chunks: ['react', 'a'] }), generatePage({ title: 'page b', entry: { b: './src/pages/b' }, name: 'b', chunks: ['react', 'b'] }), generatePage({ title: 'page c', entry: { c: './src/pages/c' }, name: 'c', chunks: ['react', 'c'] }) ] module.exports = pages.map(page => merge(baseConfig, page)) 同时再抽离 css 模块 // webpack.config.js const ExtractTextWebpack = require('extract-text-webpack-plugin') { module: { rules: [ { text: /\\.css$/, use: ExtractTextWebpack.extract({ fallback: 'style-loader', use: 'css-loader' }) } ] }, plugins: [ new ExtractTextWebpack({ filename: 'css/[name].[hash].css' }) ] } 打包之后可以看到 dist 目录下，css，js，html 都已经划分好，但是会发现 react 模块被生成多次 这里可以使用 parallel-webpack 并行打包提升打包速度。如果是在全局安装的，可以直接调用 parallel-webpack 进行打包，如果是局部安装，我们需要在 node_modules 里找到 parallel-webpack 调用 node_modules/parallel-webpack/bin/run.js 多页面单配置 我们只需要在多配置基础上稍作修改 // webpack.config.js module.exports = pages.map(page => merge(baseConfig, page)) // 改为 module.exports = merge([baseConfig].concat(pages)) 这样我们就把所有配置都 merge 到一个配置里做打包 从打包结果可以很清晰的看到，react 模块只打了一个包，但是在 html 中我们发现 title 属性并没有 \b 传过去。HtmlWebpackPlugin 默认使用 ejs 模板语法传参,我们修改下 html // inex.html &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>&lt;%= htmlWebpackPlugin.options.title %>&lt;/title> &lt;/head> &lt;body> &lt;/body> &lt;/html> 这样参数就可以传过去了。以上就是 webpack 多页应用的配置","tags":[{"name":"性能优化","slug":"性能优化","permalink":"http://coder.liusixin.cn/tags/性能优化/"},{"name":"webpack","slug":"webpack","permalink":"http://coder.liusixin.cn/tags/webpack/"}]},{"title":"web高性能动画及渲染原理","date":"2017-09-13T08:03:18.000Z","path":"posts/129b39a1/","text":"如何实现动画？ jQuery animation:setTimeout，top/left animatin，transition，transform javascript+canvas/webGL/SVG requestAnimationFrame GPU acceleration（硬件加速） webkit 的渲染流程 浏览器渲染小结 渲染三个阶段： Layout，Paint，Composite Layers 修改不同 CSS 属性会触发不同阶段 触发的阶段越前，渲染的代价越高 硬件加速（GPU 加速） Texture，即 GPU 传输到 GPU 的一个 Bitmap GPU 能快速对 texture 进行偏移、缩放、旋转、修改透明度等操作 相同之处：两者都有总线和外界联系，有自己缓存体系，以及数字和逻辑运算单元。一句话，两者都为了完成计算任务而设计。 不同之处：CPU 主要负责操作系统和应用程序，GPU 主要负责跟显示相关的数据处理，GPU 的活 CPU 一般都可以干，但是效率低下 Layer 模型 浏览器根据 CSS 属性为元素生成 Layers 将 Layers 作为 texture 上传到 GPU 当改变 Layer 的 transform,opacity 属性时，渲染会跳过 Layout，paint，直接通知 GPU 对 Layer 做变换。 Layer 创建标准 拥有 3d transform 属性 使用 animation，transition 实现 opacity，transform 的动画 video canvas Flash 使用 CSS filters 的元素 z-index 大于某个相邻节点的 Layer 的元素 为什么使用硬件加速快呢？ 如果使用 jquery 或者 js 来做一个 top 移动 100px 的动画，每次都会重主线程发传到合成器线程 但是，如果用 GPU transform 来做的话，主线程只会传一次到合成器线程，其余任务全部是在合成器线程，所以效率比较高。 节省了哪些时间？ CPU 进行 Layout 和 paint 的时间 CPU 向 GPU 传输位图的时间 完美的 Animation对眼睛来说：60FPS 更舒服更完美，约等于 16.7ms 内，我们准备好一帧的动画 开始绘制的时间 绘制一帧的时间 setTimeout(callback,1/60) 依靠浏览器内置时钟更新频率，eg、IE8 及以前更新间隔为 15.6，setTimeout 16.7，它需要两个 15.6ms 触发。超过 14.5ms，所以会出现丢帧的现象main thread 队列 requestAnimationFrame - 定义绘制每一帧的工作requestAnimationFrame(callback) 自动调节频率 ，callback 工作太多无法再一帧内完成，会自动降低为 30fps，虽然频率降低但比丢帧好。 Layout触发 Layout 改变 widht,height 等和大小、位置相关的属性 读取 size、positoin 相关的属性 尽量不触发 Layout，使用 transform 代替 top，left 的动画。 但是，如果是这样 我们可以这样改 介绍一个库 fastdom.js 在每一帧，先将读操作批量运行，在批量运行写操作 Layout 小结 不但改变 css 可能导致 Layout，读取位置大小相关属性也会导致 Layout（滚动条也会导致 Layout） 分离读写，减少 Layout 面对解耦代码，可以使用 rAF 推迟的方法分离读写 如何开发不会导致重拍 样式表越简单，重拍和重汇越快 重拍和重绘的 DOM 元素层级越高，成本就越高 table 元素的重排和重绘成本，要高于 div 元素 尽量不要把读操作和写操作，放在一个语句里 统一改变样式 缓存重排结果 离线 DOM Fragment/clone 虚拟 DOM React 必要的时候 display:none 不可见元素不影响重排重绘。 visibility 对重排影响不影响重绘 Paint触发 paint 当修改 border-radius,box-shadow,color 等展示相关属性，会触发 paint paint 的代价 continuous painting mode paint prefiler 在经常 paint 的区域，要避免代价太高的 style（比如不要的 gif 图设置 display:none） 减少不必的绘制 gif 图即使被其他 Layout 盖住不可见，也可能导致 paint，不需要时应将 gif 图的 display 属性设为 none。轮播图也一样 http://jsbin.com/dizak/3/edit?html,css,output (可以用调试工具去测试性能，z-index:0,也会重排重绘，应该直接设置 display:none) 减少绘制区域，为引起大范围 Paint 的元素生成独立的 Layout 以减小 Paint 的范围 Paint 小结 简化绘制的复杂度 避免不必要的绘制 减少绘制区域 composite Layout GPU 也是有限度的，不要滥用 GPU 资源生成不必要的 Layout 留意以外生成的 Layout 国外一个关于高性能动画研究: https://link.jianshu.com/?t=http%3A%2F%2Fjankfree.org%2F","tags":[{"name":"性能优化","slug":"性能优化","permalink":"http://coder.liusixin.cn/tags/性能优化/"},{"name":"CSS","slug":"CSS","permalink":"http://coder.liusixin.cn/tags/CSS/"},{"name":"动画","slug":"动画","permalink":"http://coder.liusixin.cn/tags/动画/"},{"name":"webkit","slug":"webkit","permalink":"http://coder.liusixin.cn/tags/webkit/"}]},{"title":"CSS 网页布局--圣杯布局、双飞翼布局","date":"2017-09-12T13:10:39.000Z","path":"posts/ba1040d2/","text":"CSS 基础布局 &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>layout&lt;/title> &lt;style type=\"text/css\"> * { margin: 0; padding: 0; } .con { width: 980px; margin: 0 auto; } .header { height: 150px; background-color: orange; } .footer { height: 150px; background-color: yellow; } .content { height: 300px; background-color: green; } .content .left { height: 300px; background-color: aquamarine; float: left; width: 20%; } .content .right { height: 300px; background-color: coral; float: right; width: 10%; } .middle { height: 300px; background-color: red; } .fx { clear: both; } &lt;/style> &lt;/head> &lt;body> &lt;div class=\"con\"> &lt;div class=\"header\"> 我是header &lt;/div> &lt;div class=\"content\"> &lt;!-- 如果是中间的内容比较重要的话需要放到前面这样在渲染时先渲染出来 这样的话就需要在 浮动同级的最后面加上一个 div.fx 清除浮动了 --> &lt;div class=\"middle\"> 中间 &lt;/div> &lt;div class=\"left\"> 左 &lt;/div> &lt;div class=\"right\"> 右 &lt;/div> &lt;div class=\"fx\">&lt;/div> &lt;/div> &lt;div class=\"footer\"> 版权信息 &lt;/div> &lt;/div> &lt;/body> &lt;/html> 在浏览器中展现的效果，上面将 .content 的高度设置为了 300px 才会出现下面这样的情况 圣杯布局照着上面的基础布局的基础上进行代码的修改 .middle{float:left;width:100%;} .left{width:100px;margin-left:-100%;} .right{float:left;width:150px;margin-left:-150px;} 再给容器 .content 加了 padding-left:100px;padding-right:150px; .left{position:relative;left:-100px;} .right{position:relative;left:150px;} &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>layout&lt;/title> &lt;style type=\"text/css\"> * { margin: 0; padding: 0; } .con { width: 980px; margin: 0 auto; } .header { height: 150px; background-color: orange; } .footer { height: 150px; background-color: yellow; } .content { height: 300px; background-color: green; padding-left: 100px; padding-right: 150px; } .content .left { height: 300px; background-color: aquamarine; float: left; width: 100px; margin-left: -100%; position: relative; left: -100px; } .content .right { height: 300px; background-color: coral; float: left; width: 150px; margin-left: -150px; position: relative; left: 150px; } .middle { height: 300px; background-color: red; float: left; width: 100%; } .fx { clear: both; } &lt;/style> &lt;/head> &lt;body> &lt;div class=\"con\"> &lt;div class=\"header\"> 我是header &lt;/div> &lt;div class=\"content\"> &lt;!-- 如果是中间的内容比较重要的话需要放到前面这样在渲染时先渲染出来 这样的话就需要在 浮动同级的最后面加上一个 div.fx 清除浮动了 --> &lt;div class=\"middle\"> 中间 &lt;/div> &lt;div class=\"left\"> 左 &lt;/div> &lt;div class=\"right\"> 右 &lt;/div> &lt;div class=\"fx\">&lt;/div> &lt;/div> &lt;div class=\"footer\"> 版权信息 &lt;/div> &lt;/div> &lt;/body> &lt;/html> 在浏览器中的效果 双飞翼布局 双飞翼布局 = 圣杯布局 + inner div 将 .left 和 .right 中的 position 属性全都去掉，将 .content 的 padding 也都去掉 之后再在 .middle 元素中增加一个 div.inner 元素 给这个元素设置样式 .middle .inner{margin-left:100px;magin-right:150px;} &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>layout&lt;/title> &lt;style type=\"text/css\"> * { margin: 0; padding: 0; } .con { width: 980px; margin: 0 auto; } .header { height: 150px; background-color: orange; } .footer { height: 150px; background-color: yellow; } .content { height: 300px; background-color: green; /*padding-left: 100px; padding-right: 150px;*/ } .content .left { height: 300px; background-color: aquamarine; float: left; width: 100px; margin-left: -100%; /*position: relative; left: -100px;*/ } .content .right { height: 300px; background-color: coral; float: left; width: 150px; margin-left: -150px; /*position: relative; left: 150px;*/ } .middle { height: 300px; background-color: red; float: left; width: 100%; } .middle .inner { margin-left: 100px; margin-right: 150px; } .fx { clear: both; } &lt;/style> &lt;/head> &lt;body> &lt;div class=\"con\"> &lt;div class=\"header\"> 我是header &lt;/div> &lt;div class=\"content\"> &lt;!-- 如果是中间的内容比较重要的话需要放到前面这样在渲染时先渲染出来 这样的话就需要在 浮动同级的最后面加上一个 div.fx 清除浮动了 --> &lt;div class=\"middle\"> &lt;div class=\"inner\"> 中间 &lt;/div> &lt;/div> &lt;div class=\"left\"> 左 &lt;/div> &lt;div class=\"right\"> 右 &lt;/div> &lt;div class=\"fx\">&lt;/div> &lt;/div> &lt;div class=\"footer\"> 版权信息 &lt;/div> &lt;/div> &lt;/body> &lt;/html> 扩展参照上面的【双飞翼】布局的源码，如果说 .left .right .inner 这三个元素不设置固定的高度，就会出现下面的问题，这里我给 .inner 设置了一个背景颜色 blueviolet 接下来我们要实现的就是如何使三列布局可以等高 给 .left .right .inner 都加上两个样式 padding-bottom:9999px;margin-bottom:-9999px; 再给 .content 加上 overflow:hidden; 上面的 padding 是增加了元素的高度，margin 是变相的将增加的高度给减去了，尽管在视觉上市一样的效果，这个 margin 是必须要加上的，这样值相互抵消使得元素也就是这个盒子模型中的内容还是在原来的位置上。 &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>layout&lt;/title> &lt;style type=\"text/css\"> * { margin: 0; padding: 0; } .con { width: 980px; margin: 0 auto; } .header { height: 150px; background-color: orange; } .footer { height: 150px; background-color: yellow; } .content { height: 300px; background-color: green; /*padding-left: 100px; padding-right: 150px;*/ overflow: hidden; } .content .left { /*height: 300px;*/ background-color: aquamarine; float: left; width: 100px; margin-left: -100%; /*position: relative; left: -100px;*/ padding-bottom: 9999px; margin-bottom: -9999px; } .content .right { /*height: 300px;*/ background-color: coral; float: left; width: 150px; margin-left: -150px; /*position: relative; left: 150px;*/ padding-bottom: 9999px; margin-bottom: -9999px; } .middle { /*height: 300px;*/ background-color: red; float: left; width: 100%; } .middle .inner { margin-left: 100px; margin-right: 150px; background-color: blueviolet; padding-bottom: 9999px; margin-bottom: -9999px; } .fx { clear: both; } &lt;/style> &lt;/head> &lt;body> &lt;div class=\"con\"> &lt;div class=\"header\"> 我是header &lt;/div> &lt;div class=\"content\"> &lt;!-- 如果是中间的内容比较重要的话需要放到前面这样在渲染时先渲染出来 这样的话就需要在 浮动同级的最后面加上一个 div.fx 清除浮动了 --> &lt;div class=\"middle\"> &lt;div class=\"inner\"> 中间 &lt;/div> &lt;/div> &lt;div class=\"left\"> 左 &lt;/div> &lt;div class=\"right\"> 右 &lt;/div> &lt;div class=\"fx\">&lt;/div> &lt;/div> &lt;div class=\"footer\"> 版权信息 &lt;/div> &lt;/div> &lt;/body> &lt;/html>","tags":[{"name":"CSS","slug":"CSS","permalink":"http://coder.liusixin.cn/tags/CSS/"},{"name":"响应式","slug":"响应式","permalink":"http://coder.liusixin.cn/tags/响应式/"}]},{"title":"OO CSS -- 面向对象的CSS","date":"2017-09-11T12:26:05.000Z","path":"posts/916f577d/","text":"面向对象的 CSS 官网：面向对象的 CSS OO CSS 的概念解读 OO CSS 的作用和注意事项 OO CSS 代码实战 众多开发者忽视了 CSS 的表现（认为他太过简单，是一种机械的工作），而且更多关注在 JavaScript 的性能上或者其他方面。 OO CSS 将页面可重用元素抽象成一个类，用 Class 加以描述，而与其对应的 HTML 即可看成是此类的一个实例。 OO CSS 的作用 加强代码复用以方便维护 减小 CSS 体积 提升渲染效率（逐层渲染） 组件库思想（和美工对接）、栅格布局可共用、减少选择器、方便扩展 OO CSS 注意事项1.不要直接定义子节点，应把共性声明放到父类 .inner { } // 不是很建议的声明 .mod .inner { } //.mod下面的inner 2.结构与皮肤相分离 &lt;div class=\"container simpleExt\">&lt;/div> //html结构 （不建议这样） .container { } //控制结构的class .simpleExt { } // 控制皮肤的class 3.容器和内容相分离 &lt;div class='container' > &lt;ul > &lt;li > 排行&lt;/li > &lt;/ul > &lt;/div > .container ul { } //ul依赖了容器 &lt;div class='container' > &lt;ul class='rankList' > &lt;li > 排行&lt;/li > &lt;/ul > &lt;/div > .rankListul li { } //解除与容器的依赖，可以从一个容器转移到其他容器 4.抽象出可重用的元素，建好组件库，在组件库内寻找可用的元素组装页面（只要把最外层的 class 引进来，然后去组件库找类，组装页面） 5.往你想要扩展的对象本身添加 class 而不是他的父节点 6.对象应保持独立性 &lt;div class=\"container\">&lt;div class=\"mod\">&lt;/div>&lt;/div> //htlm结构 .container{} .container .mod{} //控制结构的class &lt;div class=\"container mod\">&lt;/div> 7.避免使用 ID 选择器，权重太高，无法重用 8.避免位置相关的样式 #header .container{},#footer .container{} .container{} //上面的直接提出来就行，肯定有共性的。 #header h1{},#footer h1{}//如果是有不同的，可以像下面这样 h1 .h1{} h2 .h2{} &lt;h1>&lt;div class=\"h6\">&lt;/div>&lt;/h1> 9.保证选择器相同的权重（不要去嵌套太多，不然状态改变很麻烦） 10.类名 剪短 清晰 语义化 OOCSS 的名字并不影响 HTML 语义化 常用 CSS 库 对于 OO CSS 来说，这些库就相当于父类，父类做了本不该你做的事情 Reset CSS 杀伤力也较大，会把我们想要的不想要的都给设置一个初始样式 做了一个统一回归 之后有了 normalize.css，做了一个改进 normalize.css 它只给 body 设置了 padding:0;margin:0; 它做的是保证每个浏览器显示效果统一，相当于一种补充，但是有些默认的还没置掉，支队 body 做了重置 Neat.css 它是基于 normalize 和 reset 结合的 解决低级浏览器 Bug（这是 normalize 的优点） 统一效果，但不盲目重置为 0 向后兼容 考虑响应式 考虑移动设备 还有一些特色等可以到官网查看，在我们项目中也可以直接下载使用","tags":[{"name":"CSS","slug":"CSS","permalink":"http://coder.liusixin.cn/tags/CSS/"}]},{"title":"CSS workflow","date":"2017-09-10T05:22:04.000Z","path":"posts/d41e0dd/","text":"CSS 预处理器（处理浏览器） sass、less、stylus 预处理器常用规范 变量 混合（Mixin）Extend 嵌套规则 运算 函数 Namespaces &amp; Accessors Scope 注释 CSS 后处理器（该删的删，该加的加，增加前缀，包括可以兼容 IE6） CSS 压缩 CLEAN-CSS 自动添加浏览器前缀 Autoprefixer CSS 更加美观排序 CSScomb Rework（编译压缩等）取代 Stylus（只能负责编译） 后处理器发热 前后通吃 PostCSS css 处理被分成了两步，一步是 sass、less，一步是到上线前的后处理器（通过 AST‘抽象语法树’去分析） PostCSS 值得收藏的插件 POSTCSS-CUSTOM-PROPERTIES 运行时变量 POSTCSS-SIMPLE-VARS 与 SASS 一致的变量实现 POSTCSS-MIXINS 实现类似 SASS 的@MIXIN 的功能 POSTCSS-EXTEND 实现类似 SASS 的继承功能 POSTCSS-IMPORT 实现类似 SASS 的 IMPORT CSSNEXT 面向未来 CSS Grace 修复过去 编译 node 不需要 webpack，我们用 gulp+rollup（tree shaking）。 面向对象的 CSS OO CSS 的概念解读 OO CSS 的作用和注意事项 OO CSS 代码实战 众多开发者忽视了 CSS 的表现（认为他太过简单，是一种机械的工作），而且更多关注在 JavaScript 的性能上或者其他方面。 OO CSS 将页面可重用元素抽象成一个类，用 Class 加以描述，而与其对应的 HTML 即可看成是此类的一个实例。 CSS 分层与面向对象为什么要分层？ SMACSS BEM SUIT ACSS ITCSS 原因： CSS 有语义化的命名约定和 CSS 层的分离，将有助于它的可扩展性，性能的提高和代码的组织管理。 大量的样式、覆盖、权重和很多！important，分好层可以让团队命名统一规范，方便维护。 有责任感地去命名你的选择器。 BEM BEM 和 SMACSS 非常类似，主要用来如何给项目命名。一个简单命名更容易让别人一起工作。比如选项卡导航是一个块（Block），这个块里的元素是其中标签之一（Element），而当前选项卡是一个修饰状态（Modifier） block 代表了更高级别的抽象或组件 block__element 代表 block 后代，用于形成一个完整的 block 的整体 block_modifier 代表 block 的不用状态或不同版本 修饰符使用的是‘’，子模块使用‘_’，单词连接用‘-’ ACSS 考虑如何设计一个系统的接口。原子（Atoms）是创建一个区块的最基本的特质，比如说表单按钮。分子（Molecules）是很多个原子（Atoms）的组合，比如说一个表单中包括了一个标签，输入框和按钮。生物（Organisms）是众多分子（Molecules）的组合物，比如一个网站的顶部区域，他包括了网站的标题、导航等。而模板（Templates）又是众多生物（Organisms）的结合体。比如一个网站页面的布局。而最后的页面就是特殊的模板。","tags":[{"name":"CSS","slug":"CSS","permalink":"http://coder.liusixin.cn/tags/CSS/"}]},{"title":"JS中解决跨域问题","date":"2017-09-08T13:18:56.000Z","path":"posts/f4712658/","text":"前端开发中，跨域是我们经常遇到的问题，同时面试中也会经常问到这类问题，这里就来总结下 参考文档： 阮一峰的 跨域资源共享 CORS 详解 https://segmentfault.com/a/1190000011145364 什么是跨域跨域是浏览器为执行同源策略所造成的，是浏览器对 JavaScript 脚本实施的安全限制。 同源策略限制了一下行为： Cookie、LocalStorage 和 IndexDB 无法读取 DOM 和 JS 对象无法获取 Ajax 请求发送不出去 解决跨域jsonp 跨域jsonp 跨域其实也是 JavaScript 设计模式中的一种代理模式。在 html 页面中通过相应的标签从不同域名下加载静态资源文件是被浏览器允许的，所以我们可以通过这个“漏洞”来进行跨域。一般，我们可以动态的创建 script 标签，再去请求一个带参网址来实现跨域通信 原生 js 实现 let script = document.createElement('script'); script.src = 'http://www.baidu.com/login?username=Liusxin&amp;callback=callback'; document.body.appendChild(script); function callback(res) { console.log(res); } jquery 实现 $.ajax({ url: 'http://www.baidu.com/login', type: 'GET', dataType: 'jsonp', //请求方式为jsonp jsonpCallback: 'callback', data: { username: 'Liusixin' } }); 虽然这种方式非常好用，但是一个最大的缺陷是，只能够实现 get 请求 document.domain + iframe 跨域这种跨域的方式最主要的是要求主域名相同。什么是主域名相同呢？ a.liusixin.cn b.liusixin.cn a.b.liusixin.cn 这三个主域名都是 liusixin.cn,而主域名不同的就不能用此方法。 假设目前 a.liusixin.cn 和 b.liusixin.cn 分别对应指向不同 ip 的服务器。 a.liusixin.cn 下有一个 test.html 文件 &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>html&lt;/title> &lt;script type=\"text/javascript\" src=\"jquery-1.12.1.js\">&lt;/script> &lt;/head> &lt;body> &lt;div>a页面&lt;/div> &lt;iframe style=\"display : none\" name=\"iframe1\" id=\"iframe\" src=\"http://b.liusixin.cn/1.html\" frameborder=\"0\">&lt;/iframe> &lt;script type=\"text/javascript\"> $(function() { try { document.domain = \"liusixin.cn\" } catch (e) {} $(\"#iframe\").load(function() { var jq = document.getElementById('iframe').contentWindow.$ jq.get(\"http://liusixin.cn/test.json\", function(data) { console.log(data); }); }) }) &lt;/script> &lt;/body> &lt;/html> &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>b页面&lt;/title> &lt;script type=\"text/javascript\" src=\"jquery-1.12.1.js\">&lt;/script> &lt;script type=\"text/javascript\"> $(function() { try { document.domain = \"liusixin.com\" } catch (e) {} }) &lt;/script> &lt;/head> &lt;body> &lt;div id=\"div1\">B页面&lt;/div> &lt;/body> &lt;/html> 利用 iframe 加载 其他域下的文件（liusixin.cn/1.html）, 同时 document.domain 设置成 liusixin.cn ，当 iframe 加载完毕后就可以获取 liusixin.cn 域下的全局对象， 此时尝试着去请求 liusixin.cn 域名下的 test.json，就会发现数据成功拿到。 window.name + iframe 跨域window.name 属性可设置或者返回存放窗口名称的一个字符串。他的神奇之处在于 name 值在不同页面或者不同域下加载后依旧存在，没有修改就不会发生变化，并且可以存储很大的数据 name(2MB) 假设 index 页面请求远端服务器上的数据，我们在该页面下创建 iframe 标签，该 iframe 的 src 指向服务器文件的地址（iframe 标签 src 可以跨域），服务器文件里设置好window.name的值，然后再在index.html里面读取改 iframe 中的window.name的值。 &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>title&lt;/title> &lt;script type=\"text/javascript\" src=\"jquery-1.12.1.js\">&lt;/script> &lt;/head> &lt;body> &lt;script type=\"text/javascript\"> iframe = document.createElement('iframe'); iframe.src = 'http://localhost:8080/data.php'; document.body.appendChild(iframe); iframe.onload = function() { console.log(iframe.contentWindow.name) }; &lt;/script> &lt;/body> &lt;/html> 当然，这样还是不够的。 因为规定如果 index.html 页面和和该页面里的 iframe 框架的 src 如果不同源，则也无法操作框架里的任何东西，所以就取不到 iframe 框架的 name 值了。既然要同源，那就换个 src 去指，前面说了无论怎样加载window.name值都不会变化，于是我们在index.html相同目录下，新建了个proxy.html的空页面，修改代码如下： &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>proxy&lt;/title> &lt;script type=\"text/javascript\" src=\"jquery-1.12.1.js\">&lt;/script> &lt;/head> &lt;body> &lt;script type=\"text/javascript\"> iframe = document.createElement('iframe'); iframe.src = 'http://localhost:8080/data.php'; document.body.appendChild(iframe); iframe.onload = function() { iframe.src = 'http://localhost:81/cross-domain/proxy.html'; console.log(iframe.contentWindow.name) }; &lt;/script> &lt;/body> &lt;/html> 理想似乎很美好，在 iframe 载入过程中，迅速重置iframe.src的指向，使之与index.html同源，那么 index 页面就能去获取它的 name 值了！但是现实是残酷的，iframe 在现实中的表现是一直不停地刷新， 也很好理解，每次触发 onload 时间后，重置 src，相当于重新载入页面，又触发 onload 事件，于是就不停地刷新了（但是需要的数据还是能输出的）。修改后代码如下： &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>proxy&lt;/title> &lt;script type=\"text/javascript\" src=\"jquery-1.12.1.js\">&lt;/script> &lt;/head> &lt;body> &lt;script type=\"text/javascript\"> iframe = document.createElement('iframe'); iframe.style.display = 'none'; var state = 0; iframe.onload = function() { if (state === 1) { var data = JSON.parse(iframe.contentWindow.name); console.log(data); iframe.contentWindow.document.write(''); iframe.contentWindow.close(); document.body.removeChild(iframe); } else if (state === 0) { state = 1; iframe.contentWindow.location = 'http://localhost:81/cross-domain/proxy.html'; } }; iframe.src = 'http://localhost:8080/data.php'; document.body.appendChild(iframe); &lt;/script> &lt;/body> &lt;/html> 所以如上，我们就拿到了服务器返回的数据，但是有几个条件是必不可少的： iframe 标签的跨域能力 window.names 属性值在文档刷新后依然存在的能力 location.hash + iframe 跨域此跨域方法和上面介绍的比较类似，一样是动态插入一个 iframe 然后设置其 src 为服务端地址，而服务端同样输出一端 js 代码，也同时通过与子窗口之间的通信来完成数据的传输。 关于锚点相信大家都已经知道了，其实就是设置锚点，让文档指定的相应的位置。锚点的设置用 a 标签，然后 href 指向要跳转到的 id，当然，前提是你得有个滚动条。 而location.hash其实就是 url 的锚点。比如http://www.liusixin.cn#test 的网址打开后，在控制台输入location.hash就会返回 #test 的字段。 基础知识补充完毕，下面我们来说下如何实现跨域 如果 index 页面要获取远端服务器的数据，动态的插入一个 iframe，将 iframe 的 src 执行服务器的地址，这时候的 top window 和包裹这个 iframe 的子窗口是不能通信的，因为同源策略，所以改变子窗口的路径就可以了，将数据当做改变后的路径的 hash 值加载路径上，然后就可以通信了。将数据加在 index 页面地址的 hash 上， index 页面监听 hash 的变化，h5 的hashchange方法 &lt;body> &lt;script type=\"text/javascript\"> function getData(url, fn) { var iframe = document.createElement('iframe'); iframe.style.display = 'none'; iframe.src = url; iframe.onload = function() { fn(iframe.contentWindow.location.hash.substring(1)); window.location.hash = ''; document.body.removeChild(iframe); }; document.body.appendChild(iframe); } // get data from server var url = 'http://localhost:8080/data.php'; getData(url, function(data) { var jsondata = JSON.parse(data); console.log(jsondata.name + ' ' + jsondata.age); }); &lt;/script> &lt;/body> location.hash和 window.name 都是差不多的，都是利用全局对象属性的方法，然后这两种方法和 jsonp 也是一样的，就是只能够实现get请求 postMessage 跨域这是由 HTML5 提出来的一个新的的 API，IE8+，chrome,ff 都已经支持实现了这个功能。这个功能也是非常的简单，其中包括接受信息的 Message 时间，和发送信息的postMessage方法。 发送信息的 postMessage 方法是向外界窗口发送信息 otherWindow.postMessage(message, targetOrigin); otherWindow指的是目标窗口，也就是要给哪一个 window 发送消息，是window.frames属性的成员或者是window.open方法创建的窗口。 Message是要发送的消息，类型为String，Object(IE8、9 不支持 Obj)，targetOrigin是限定消息接受范围，不限制就用星号 * 接受信息的message事件 var onmessage = function(event) { var data = event.data; var origin = event.origin; }; if (typeof window.addEventListener != 'undefined') { window.addEventListener('message', onmessage, false); } else if (typeof window.attachEvent != 'undefined') { window.attachEvent('onmessage', onmessage); } 举个例子 a.html(http://www.liusixin.cn/a.html) &lt;body> &lt;iframe id=\"iframe\" src=\"http://www.lsx.cn/b.html\" style=\"display:none;\">&lt;/iframe> &lt;script> var iframe = document.getElementById('iframe'); iframe.onload = function() { var data = { name: 'lsx' }; // 向lsx传送跨域数据 iframe.contentWindow.postMessage(JSON.stringify(data), 'http://www.lsx.cn'); }; // 接受domain2返回数据 window.addEventListener('message', function(e) { alert('data from lsx ---> ' + e.data); }, false); &lt;/script> &lt;/body> b.html(http://www.lsx.cn/b.html) &lt;body> &lt;script> // 接收domain1的数据 window.addEventListener('message', function(e) { alert('data from liusixin ---> ' + e.data); var data = JSON.parse(e.data); if (data) { data.number = 16; // 处理后再发回liusixin window.parent.postMessage(JSON.stringify(data), 'http://www.liusixin.cn'); } }, false); &lt;/script> &lt;/body> 跨域资源共享 CORS 是目前主流的跨域解决方案 CORS 是一个 W3C 标准，全称是”跨域资源共享”（Cross-origin resource sharing）。 它允许浏览器向跨源服务器，发出 XMLHttpRequest 请求，从而克服了 AJAX 只能同源使用的限制。 CORS 需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE 浏览器不能低于 IE10。IE8+：IE8/9 需要使用 XDomainRequest 对象来支持 CORS。 整个 CORS 通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS 通信与同源的 AJAX 通信没有差别，代码完全一样。浏览器一旦发现 AJAX 请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。 因此，实现 CORS 通信的关键是服务器。只要服务器实现了 CORS 接口，就可以跨源通信。 两种请求 分为两种请求，一种是简单请求，另一种是非简单请求。只要满足下面条件就是简单请求 请求方式为 HEAD、POST 或者 GET http 头信息不超出以下字段：Accept、Accept-Language 、 Content-Language、 Last-Event-ID、 Content-Type(限于三个值：application/x-www-form-urlencoded、multipart/form-data、text/plain) 浏览器对这两种请求方式的处理方式是不同的。 简单请求 对于简单请求，浏览器直接发出 CORS 请求。具体来说，就是在头信息之中，增加一个 Origin 字段。 下面是一个例子，浏览器发现这次跨源 AJAX 请求是简单请求，就自动在头信息之中，添加一个 Origin 字段。 GET /cors HTTP/1.1 Origin: http://api.bob.com Host: api.alice.com Accept-Language: en-US Connection: keep-alive User-Agent: Mozilla/5.0 ... Origin 字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。 如果 Origin 指定的源，不在许可范围内，服务器会返回一个正常的 HTTP 回应。 浏览器发现，这个回应的头信息没有包含Access-Control-Allow-Origin字段（详见下文），就知道出错了，从而抛出一个错误，被XMLHttpRequest的onerror回调函数捕获。 注意，这种错误无法通过状态码识别，因为 HTTP 回应的状态码有可能是 200。 如果 Origin 指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。 Access-Control-Allow-Origin: http://api.bob.com Access-Control-Allow-Credentials: true Access-Control-Expose-Headers: FooBar Content-Type: text/html; charset=utf-8 上面的头信息之中，有三个与 CORS 请求相关的字段，都以 Access-Control- 开头 Access-Control-Allow-Origin :该字段是必须的。它的值要么是请求时 Origin 字段的值，要么是一个*，表示接受任意域名的请求 Access-Control-Allow-Credentials: 该字段可选。它的值是一个布尔值，表示是否允许发送 Cookie。默认情况下，Cookie 不包括在 CORS 请求之中。设为 true，即表示服务器明确许可，Cookie 可以包含在请求中，一起发给服务器。这个值也只能设为 true，如果服务器不要浏览器发送 Cookie，删除该字段即可。 Access-Control-Expose-Headers:该字段可选。CORS 请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到 6 个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers 里面指定。 withCredentials属性 上面说到，CORS 请求默认不发送 Cookie 和 HTTP 认证信息。如果要把 Cookie 发到服务器，一方面要服务器同意，指定Access-Control-Allow-Credentials字段。另一方面，开发者必须在 AJAX 请求中打开withCredentials属性。 var xhr = new XMLHttpRequest(); // IE8/9需用window.XDomainRequest兼容 // 前端设置是否带cookie xhr.withCredentials = true; xhr.open('post', 'http://www.domain2.com:8080/login', true); xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded'); xhr.send('user=admin'); xhr.onreadystatechange = function() { if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) { alert(xhr.responseText); } }; // jquery $.ajax({ ... xhrFields: { withCredentials: true // 前端设置是否带cookie }, crossDomain: true, // 会让请求头中包含跨域的额外信息，但不会含cookie ... }); 否则，即使服务器同意发送 Cookie，浏览器也不会发送。或者，服务器要求设置 Cookie，浏览器也不会处理。 但是，如果省略withCredentials设置，有的浏览器还是会一起发送 Cookie。这时，可以显式关闭withCredentials。 需要注意的是，如果要发送 Cookie，Access-Control-Allow-Origin就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie 依然遵循同源政策，只有用服务器域名设置的 Cookie 才会上传，其他域名的 Cookie 并不会上传，且（跨源）原网页代码中的document.cookie也无法读取服务器域名下的 Cookie。 非简单请求 非简单请求是那种对服务器有特殊要求的请求，比如请求方法是 PUT 或 DELETE，或者Content-Type字段的类型是application/json。 非简单请求的 CORS 请求，会在正式通信之前，增加一次 HTTP 查询请求，称为”预检”请求（preflight）。 浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些 HTTP 动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。 var url = 'http://api.alice.com/cors'; var xhr = new XMLHttpRequest(); xhr.open('PUT', url, true); xhr.setRequestHeader('X-Custom-Header', 'value'); xhr.send(); 浏览器发现，这是一个非简单请求，就自动发出一个”预检”请求，要求服务器确认可以这样请求。下面是这个”预检”请求的 HTTP 头信息。 OPTIONS / cors HTTP / 1.1 Origin: http: //api.bob.com Access - Control - Request - Method: PUT Access - Control - Request - Headers: X - Custom - Header Host: api.alice.com Accept - Language: en - US Connection: keep - alive User - Agent: Mozilla / 5.0 ... “预检”请求用的请求方法是 OPTIONS，表示这个请求是用来询问的。头信息里面，关键字段是 Origin，表示请求来自哪个源。 除了 Origin 字段，”预检”请求的头信息包括两个特殊字段。 Access-Control-Request-Method：该字段是必须的，用来列出浏览器的 CORS 请求会用到哪些 HTTP 方法，上例是 PUT。 Access-Control-Request-Headers：该字段是一个逗号分隔的字符串，指定浏览器 CORS 请求会额外发送的头信息字段，上例是X-Custom-Header 预检请求的回应 服务器收到”预检”请求以后，检查了Origin、Access-Control-Request-Method 和 Access-Control-Request-Headers 字段以后，确认允许跨源请求，就可以做出回应 HTTP/1.1 200 OK Date: Mon, 01 Dec 2008 01:15:39 GMT Server: Apache/2.0.61 (Unix) Access-Control-Allow-Origin: http://api.bob.com Access-Control-Allow-Methods: GET, POST, PUT Access-Control-Allow-Headers: X-Custom-Header Content-Type: text/html; charset=utf-8 Content-Encoding: gzip Content-Length: 0 Keep-Alive: timeout=2, max=100 Connection: Keep-Alive Content-Type: text/plain 上面的 HTTP 回应中，关键的是 Access-Control-Allow-Origin 字段，表示 http://api.bob.com 可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。 如果浏览器否定了”预检”请求，会返回一个正常的 HTTP 回应，但是没有任何 CORS 相关的头信息字段。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被XMLHttpRequest对象的 onerror 回调函数捕获。控制台会打印出如下的报错信息。 服务器回应的其他 CORS 相关字段如下： Access-Control-Allow-Methods: GET, POST, PUT Access-Control-Allow-Headers: X-Custom-Header Access-Control-Allow-Credentials: true Access-Control-Max-Age: 1728000 Access-Control-Allow-Methods：该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次”预检”请求。 Access-Control-Allow-Headers：如果浏览器请求包括Access-Control-Request-Headers字段，则Access-Control-Allow-Headers字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在”预检”中请求的字段。 Access-Control-Allow-Credentials： 该字段与简单请求时的含义相同。 Access-Control-Max-Age： 该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是 20 天（1728000 秒），即允许缓存该条回应 1728000 秒（即 20 天），在此期间，不用发出另一条预检请求。 浏览器正常请求回应 一旦服务器通过了”预检”请求，以后每次浏览器正常的 CORS 请求，就都跟简单请求一样，会有一个Origin头信息字段。服务器的回应，也都会有一个Access-Control-Allow-Origin头信息字段。 PUT /cors HTTP/1.1 Origin: http://api.bob.com Host: api.alice.com X-Custom-Header: value Accept-Language: en-US Connection: keep-alive User-Agent: Mozilla/5.0... 览器的正常 CORS 请求。上面头信息的Origin字段是浏览器自动添加的。下面是服务器正常的回应。 Access-Control-Allow-Origin: http://api.bob.com Content-Type: text/html; charset=utf-8 Access-Control-Allow-Origin 字段是每次回应都必定包含的 CORS 与 JSONP 的使用目的相同，但是比 JSONP 更强大。JSONP 只支持 GET 请求，CORS 支持所有类型的 HTTP 请求。JSONP 的优势在于支持老式浏览器，以及可以向不支持 CORS 的网站请求数据。 WebSocket 协议跨域WebSocket protocol 是 HTML5 一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是 server push 技术的一种很好的实现。 原生 WebSocket API 使用起来不太方便，我们使用 Socket.io，它很好地封装了 webSocket 接口，提供了更简单、灵活的接口，也对不支持 webSocket 的浏览器提供了向下兼容。 前端代码 &lt;body> &lt;div>user input：&lt;input type=\"text\">&lt;/div> &lt;script src=\"./socket.io.js\">&lt;/script> &lt;script> var socket = io('http://www.domain2.com:8080'); // 连接成功处理 socket.on('connect', function() { // 监听服务端消息 socket.on('message', function(msg) { console.log('data from server: ---> ' + msg); }); // 监听服务端关闭 socket.on('disconnect', function() { console.log('Server socket has closed.'); }); }); document.getElementsByTagName('input')[0].onblur = function() { socket.send(this.value); }; &lt;/script> &lt;/body> 服务端代码 var http = require('http'); var socket = require('socket.io'); // 启http服务 var server = http.createServer(function(req, res) { res.writeHead(200, { 'Content-type': 'text/html' }); res.end(); }); server.listen('8080'); console.log('Server is running at port 8080...'); // 监听socket连接 socket.listen(server).on('connection', function(client) { // 接收信息 client.on('message', function(msg) { client.send('hello：' + msg); console.log('data from client: ---> ' + msg); }); // 断开处理 client.on('disconnect', function() { console.log('Client socket has closed.'); }); }); node 代理跨域node 中间件实现跨域代理，是通过启一个代理服务器，实现数据的转发，也可以通过设置cookieDomainRewrite参数修改响应头中 cookie 中域名，实现当前域的 cookie 写入，方便接口登录认证。 利用 node + express + http-proxy-middleware 搭建一个 proxy 服务器 前端代码 var xhr = new XMLHttpRequest(); // 前端开关：浏览器是否读写cookie xhr.withCredentials = true; // 访问http-proxy-middleware代理服务器 xhr.open('get', 'http://www.domain1.com:3000/login?user=admin', true); xhr.send(); 服务端代码 var express = require('express'); var proxy = require('http-proxy-middleware'); var app = express(); app.use( '/', proxy({ // 代理跨域目标接口 target: 'http://www.domain2.com:8080', changeOrigin: true, // 修改响应头信息，实现跨域并允许带cookie onProxyRes: function(proxyRes, req, res) { res.header('Access-Control-Allow-Origin', 'http://www.domain1.com'); res.header('Access-Control-Allow-Credentials', 'true'); }, // 修改响应信息中的cookie域名 cookieDomainRewrite: 'www.domain1.com' // 可以为false，表示不修改 }) ); app.listen(3000); console.log('Proxy server is listen at port 3000...'); nginx 代理跨域1、nginx 配置解决 iconfont 跨域 浏览器跨域访问 js、css、img 等常规静态资源被同源策略许可，但 iconfont 字体文件(eot|otf|ttf|woff|svg)例外，此时可在 nginx 的静态资源服务器中加入以下配置。 location / { add_header Access-Control-Allow-Origin *; } 2、nginx 反向代理接口跨域 跨域原理： 同源策略是浏览器的安全策略，不是 HTTP 协议的一部分。服务器端调用 HTTP 接口只是使用 HTTP 协议，不会执行 JS 脚本，不需要同源策略，也就不存在跨越问题。 实现思路：通过 nginx 配置一个代理服务器（域名与 domain1 相同，端口不同）做跳板机，反向代理访问 domain2 接口，并且可以顺便修改 cookie 中 domain 信息，方便当前域 cookie 写入，实现跨域登录。 nginx 具体配置 #proxy服务器 server { listen 81; server_name www.domain1.com; location / { proxy_pass http://www.domain2.com:8080; #反向代理 proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名 index index.html index.htm; # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用 add_header Access-Control-Allow-Origin http://www.domain1.com; #当前端只跨域不带cookie时，可为* add_header Access-Control-Allow-Credentials true; } } 前端代码示例 var http = require('http'); var server = http.createServer(); var qs = require('querystring'); server.on('request', function(req, res) { var params = qs.parse(req.url.substring(2)); // 向前台写cookie res.writeHead(200, { 'Set-Cookie': 'l=a123456;Path=/;Domain=www.domain2.com;HttpOnly' // HttpOnly:脚本无法读取 }); res.write(JSON.stringify(params)); res.end(); }); server.listen('8080'); console.log('Server is running at port 8080...');","tags":[{"name":"javascript","slug":"javascript","permalink":"http://coder.liusixin.cn/tags/javascript/"},{"name":"HTTP","slug":"HTTP","permalink":"http://coder.liusixin.cn/tags/HTTP/"},{"name":"Nodejs","slug":"Nodejs","permalink":"http://coder.liusixin.cn/tags/Nodejs/"},{"name":"Nginx","slug":"Nginx","permalink":"http://coder.liusixin.cn/tags/Nginx/"},{"name":"跨域","slug":"跨域","permalink":"http://coder.liusixin.cn/tags/跨域/"}]},{"title":"git 常用命令总结","date":"2017-09-05T15:07:02.000Z","path":"posts/509c5367/","text":"一、新建代码库# 在当前目录新建一个Git代码库 $ git init # 新建一个目录，将其初始化为Git代码库 $ git init [project-name] # 下载一个项目和它的整个代码历史 $ git clone [url] 二、配置Git 的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。 # 显示当前的Git配置 $ git config --list # 编辑Git配置文件 $ git config -e [--global] # 设置提交代码时的用户信息 $ git config [--global] user.name \"[name]\" $ git config [--global] user.email \"[email address]\" 三、增加/删除文件# 添加指定文件到暂存区 $ git add [file1] [file2] ... # 添加指定目录到暂存区，包括子目录 $ git add [dir] # 添加当前目录的所有文件到暂存区 $ git add . # 添加每个变化前，都会要求确认 # 对于同一个文件的多处变化，可以实现分次提交 $ git add -p # 删除工作区文件，并且将这次删除放入暂存区 $ git rm [file1] [file2] # 停止追踪指定文件，但该文件会保留在工作区 $ git rm --cached [file] # 改名文件，并且将这个改名放入暂存区 $ git mv [file-original] [file-renamed] 四、代码提交# 提交暂存区到仓库区 $ git commit -m [message] # 提交暂存区的指定文件到仓库区 $ git commit [file1] [file2] ... -m [message] # 提交工作区自上次commit之后的变化，直接到仓库区 $ git commit -a # 提交时显示所有diff信息 $ git commit -v # 使用一次新的commit，替代上一次提交 # 如果代码没有任何新变化，则用来改写上一次commit的提交信息 $ git commit --amend -m [message] # 重做上一次commit，并包括指定文件的新变化 $ git commit --amend [file1] [file2] 五、分支# 列出所有本地分支 $ git branch # 列出所有远程分支 $ git branch -r # 列出所有本地分支和远程分支 $ git branch -a # 新建一个分支，但依然停留在当前分支 $ git branch [branch-name] # 新建一个分支，并切换到该分支 $ git checkout -b [branch] # 新建一个分支，指向指定commit $ git branch [branch] [commit] # 新建一个分支，与指定的远程分支建立追踪关系 $ git branch --track [branch] [remote-branch] # 切换到指定分支，并更新工作区 $ git checkout [branch-name] # 切换到上一个分支 $ git checkout - # 建立追踪关系，在现有分支与指定的远程分支之间 $ git branch --set-upstream [branch] [remote-branch] # 合并指定分支到当前分支 $ git merge [branch] # 选择一个commit，合并进当前分支 $ git cherry-pick [commit] # 删除分支 $ git branch -d [branch-name] # 删除远程分支 $ git push origin --delete [branch-name] $ git branch -dr [remote/branch] 六、标签# 列出所有tag $ git tag # 新建一个tag在当前commit $ git tag [tag] # 新建一个tag在指定commit $ git tag [tag] [commit] # 删除本地tag $ git tag -d [tag] # 删除远程tag $ git push origin :refs/tags/[tagName] # 查看tag信息 $ git show [tag] # 提交指定tag $ git push [remote] [tag] # 提交所有tag $ git push [remote] --tags # 新建一个分支，指向某个tag $ git checkout -b [branch] [tag] 七、查看信息# 显示有变更的文件 $ git status # 显示当前分支的版本历史 $ git log # 显示commit历史，以及每次commit发生变更的文件 $ git log --stat # 搜索提交历史，根据关键词 $ git log -S [keyword] # 显示某个commit之后的所有变动，每个commit占据一行 $ git log [tag] HEAD --pretty=format:%s # 显示某个commit之后的所有变动，其\"提交说明\"必须符合搜索条件 $ git log [tag] HEAD --grep feature # 显示某个文件的版本历史，包括文件改名 $ git log --follow [file] $ git whatchanged [file] # 显示指定文件相关的每一次diff $ git log -p [file] # 显示过去5次提交 $ git log -5 --pretty --oneline # 显示所有提交过的用户，按提交次数排序 $ git shortlog -sn # 显示指定文件是什么人在什么时间修改过 $ git blame [file] # 显示暂存区和工作区的差异 $ git diff # 显示暂存区和上一个commit的差异 $ git diff --cached [file] # 显示工作区与当前分支最新commit之间的差异 $ git diff HEAD # 显示两次提交之间的差异 $ git diff [first-branch]...[second-branch] # 显示今天你写了多少行代码 $ git diff --shortstat \"@{0 day ago}\" # 显示某次提交的元数据和内容变化 $ git show [commit] # 显示某次提交发生变化的文件 $ git show --name-only [commit] # 显示某次提交时，某个文件的内容 $ git show [commit]:[filename] # 显示当前分支的最近几次提交 $ git reflog 八、远程同步# 下载远程仓库的所有变动 $ git fetch [remote] # 显示所有远程仓库 $ git remote -v # 显示某个远程仓库的信息 $ git remote show [remote] # 增加一个新的远程仓库，并命名 $ git remote add [shortname] [url] # 取回远程仓库的变化，并与本地分支合并 $ git pull [remote] [branch] # 上传本地指定分支到远程仓库 $ git push [remote] [branch] # 强行推送当前分支到远程仓库，即使有冲突 $ git push [remote] --force # 推送所有分支到远程仓库 $ git push [remote] --all 九、撤销# 恢复暂存区的指定文件到工作区 $ git checkout [file] # 恢复某个commit的指定文件到暂存区和工作区 $ git checkout [commit] [file] # 恢复暂存区的所有文件到工作区 $ git checkout . # 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变 $ git reset [file] # 重置暂存区与工作区，与上一次commit保持一致 $ git reset --hard # 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变 $ git reset [commit] # 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致 $ git reset --hard [commit] # 重置当前HEAD为指定commit，但保持暂存区和工作区不变 $ git reset --keep [commit] # 新建一个commit，用来撤销指定commit # 后者的所有变化都将被前者抵消，并且应用到当前分支 $ git revert [commit] # 暂时将未提交的变化移除，稍后再移入 $ git stash $ git stash pop 十、其他# 生成一个可供发布的压缩包 $ git archive","tags":[{"name":"Git","slug":"Git","permalink":"http://coder.liusixin.cn/tags/Git/"},{"name":"编程笔记","slug":"编程笔记","permalink":"http://coder.liusixin.cn/tags/编程笔记/"}]},{"title":"webpack实践--长缓存优化","date":"2017-08-25T02:56:58.000Z","path":"posts/22ed3b4c/","text":"1.1 场景有时候，我们在开发项目时只会写有关 app 的代码，不会改 vender 第三方库源码，当我们改变 app 代码的时候，我们希望打包出来 bundle 不要被 app 所影响而去 \b 改变它的版本号。比如页面已经缓存了 vue，但我们并没有改变 vue 的代码，只改变自己的业务代码，用户完全没有下载新的打包出来的 vue 的代码。 改变 app 代码，vender 变化 1.2 解决 提取 vendor hash -&gt; chunkhash(代码块 hash) webpack runtime 或者 manifest 接下来我们用代码演示 // src/main.js import React from 'react'; console.log('hello world'); // webpack.conf.js const path = require('path'); const webpack = require('webpack'); module.exports = { entry: { main: './src/main', vendor: ['react'] }, output: { path: path.resolve(__dirname, 'dist'), filename: '[name].[hash].js' }, plugins: [ new webpack.optimize.CommonsChunkPlugin({ name: 'vender', minChunks: Infinity }) ] }; 打包结果 从打包结果来看，公共代码已经被抽离出来，但是哈希值还是一样，如果修改一个，另一个肯定也会跟着变化，我们使用 chunkhash output: { path: path.resolve(__dirname, 'dist'), filename: '[name].[chunkhash].js' } 来看结果 从结果看，两个文件哈希值不一样了，试试修改 main 文件的代码，你会发现，两个文件还是同时会改变。 这里我们需要把 webpack runtime 提取出来 plugins: [ new webpack.optimize.CommonsChunkPlugin({ name: 'vender', minChunks: Infinity }), new webpack.optimize.CommonsChunkPlugin({ name: 'runtime' }) ]; 这时修改 main 的代码，发现 vender 不会再改变，这样就达到了我们第一个目的，改变业务代码，不改变 vender 2.1 场景引入新模块，模块顺序变化，vendor hash 变化 // src/main.js import React from 'react'; import module from './module'; console.log('hello world'); // src/module.js export default 'module'; 打包发现，vendor 的哈希值还是会变化，即便没有被修改。 原因是在打包的同时，webpack 会给每个模块，每个 chunk 一个 id，id 发生变化的时候也会导致哈希发生变化 2.2 解决 NamedChunksPlugin NamedModulesPlugin 来解决模块顺序的变化而导致的 vendor hash 的变化 plugins: [ new webpack.NamedChunksPlugin(), new webpack.optimize.CommonsChunkPlugin({ name: 'vender', minChunks: Infinity }), new webpack.optimize.CommonsChunkPlugin({ name: 'runtime' }) ]; 可以看到，chunks id 从 0，1，2 变为了名字，修改 main 代码，也会发现 vendor 的哈希值没变，main 和 manifest 变化了。 可以通过 NamedModulesPlugin 看到更清晰的模块，chunk 是有哪些模块组成，模块的顺序也会影响哈希值的生成 plugins: [new webpack.NamedChunksPlugin(), new webpack.NamedModulesPlugin()]; 3.1 场景动态引入模块时，vendor hash 变化 // src/async.js export default { name: 'async' }; // src/main.js import React from 'react'; import module from './module'; import('./async').then(function(a) { console.log(a); }); console.log('hello world'); 结果来看，vendor 不会变化，最新版本可能做了改进，但是还是会给这个 \b 模块新加了 \b 一个 id 0 ，而且没有 chunkName 3.2 解决 定义动态模块的 chunkName // src/main.js import React from 'react'; import module from './module'; import(/* webpackChunkName: 'async' */ './async').then(function(a) { console.log(a); }); console.log('hello world'); 4 总结 独立打包 vendor 抽出 manifest(webpack runtime) 使用 NamedChunksPlugin 和 NamedModulePlugin 动态模块给定模块名称","tags":[{"name":"性能优化","slug":"性能优化","permalink":"http://coder.liusixin.cn/tags/性能优化/"},{"name":"webpack","slug":"webpack","permalink":"http://coder.liusixin.cn/tags/webpack/"}]},{"title":"webpack实践--打包速度优化","date":"2017-08-24T11:56:58.000Z","path":"posts/9f161534/","text":"webpack 在打包过程中可能会有各种因素导致打包速度很慢进而影响开发体验，接下来我们就逐个分析。 可能因素 文件多 依赖多 页面多 解决 方法一 分开 vendor(第三方代码)和 app(业务代码) DllPlugin(如果业务代码引入第三方库，通过这两个插件可以解决重复打包) DllReferencePlugin 方法二 UglifyJsPlugin(耗时，并行处理) parallel(默认线程数-1 的速度) cache 方法三 HappyRack(文件处理串行变并行) HappyRack.ThreadPool(线程池) 方法四 babel-loader options.cacheDirectory(缓存) include(尽可能的缩小范围) exclude(尽可能的缩小范围) 其它 减少 resolve Devtool：去除 sourcemap cache-loader 升级 node 升级 webpack 我们以 vue 项目为例 方法一const path = require('path') const webpack = require('webpack') module.exports = { entry: { vue: ['vue', 'vue-router'], ui: ['element-ui'] }, output: { path: path.join(__dirname, '../src/dll/'), filename: '[name].dll.js', library: '[name]' }, plugins: [ new webpack.DllPlugin({ path: path.join(__dirname, '../src/dll/', '[name]-manifest.json'), name: '[name]' }), new webpack.optimize.UglifyJsPlugin() ] } // webpack.prod.conf.js plugins: [ new webpack.DllReferencePlugin({ manifest: require('../src/dll/ui-manifest.json') }), new webpack.DllReferencePlugin({ manifest: require('../src/dll/vue-manifest.json') }) } 方法二new webpack.optimize.UglifyJsPlugin({ parallel: true, cache: true, sourceMap: \b去掉 }) 方法三$ npm i happypack -D const HappyPack = require('happypack') { test: /\\.vue$/, loader: 'happypack/loader?id=vue', options: vueLoaderConfig } plugins: [ new HappyPack({ id: 'vue', loaders: [{ loader: 'vue-loader', option: require('./vue-loader.conf') }] }) ] happypack 会并行处理 loader，但是如果文件过少反而会增加打包时间，一般在文件较多的大型项目下使用","tags":[{"name":"性能优化","slug":"性能优化","permalink":"http://coder.liusixin.cn/tags/性能优化/"},{"name":"webpack","slug":"webpack","permalink":"http://coder.liusixin.cn/tags/webpack/"}]},{"title":"造轮子系列：JS封装拖拽组件","date":"2017-08-20T05:57:39.000Z","path":"posts/b1ea6a64/","text":"封装一个拖拽对象1. 如何让一个 DOM 元素动起来拖拽的本质就是让 DOM 元素能够跟着鼠标运动起来。 在页面中创建一个 class 名为 drag 的 div 标签，它的基本样式如下: &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"> &lt;title>拖拽封装&lt;/title> &lt;style> .drag { width: 50px; height: 50px; background-color: red; } &lt;/style> &lt;/head> &lt;body> &lt;div class=\"drag\">&lt;/div> &lt;/body> &lt;/html> 由于 left/top 会导致频繁的重排与回流，因此我们在处理元素运动时控制 translate 的值。 .drag { width: 50px; height: 50px; background-color: red; transform: translateX(0px); } 首先要考虑兼容性，需要判断当前浏览器环境支持的 transform 属性是哪一种 // 获取当前浏览器支持的 transform 兼容写法 function getTransform() { var transform = '', divStyle = document.createElement('div').style, _transforms = [ 'transform', 'webkitTransform', 'MozTransform', 'msTransform', 'OTransform' ], i = 0, len = _transforms.length; for (; i &lt; len; i++) { if (_transforms[i] in divStyle) { // 找到之后立即返回，结束函数 return (transform = _transforms[i]); } } // 如果没有找到，就直接返回空字符串 return transform; } 该方法用于获取当前浏览器支持的 transform 属性。 如果返回空字符串，则表示该浏览器不支持 transform，这个时候就要考虑使用 left/top。 2. 如何获取元素的初始位置获取元素的初始位置，需要声明一个专门用来获取元素样式的功能函数。获取元素样式的方法在 IE 中与其他浏览器中有所不同，所以需要考虑兼容性: function getStyle(elem, property) { // IE通过 currentStyle 来获取元素的样式， // 其他浏览器通过 getComputedStyle 来获取 return document.defaultView.getComputedStyle ? document.defaultView.getComputedStyle(elem, false)[property] : elem.currentStyle[property]; } 有了这个方法，然后来实现一个获取元素位置的方法 function getTargetPos(elem) { var pos = { x: 0, y: 0 }; var transform = getTransform(); if (transform) { var transformValue = getStyle(elem, transform); if (transformValue == 'none') { elem.style[transform] = 'translate(0, 0)'; return pos; } else { var temp = transformValue.match(/-?\\d+/g); return (pos = { x: parseInt(temp[4].trim()), y: parseInt(temp[5].trim()) }); } } else { if (getStyle(elem, 'position') == 'static') { elem.style.position = 'relative'; return pos; } else { var x = parseInt(getStyle(elem, 'left') ? getStyle(elem, 'left') : 0); var y = parseInt(getStyle(elem, 'top') ? getStyle(elem, 'top') : 0); return (pos = { x: x, y: y }); } } } 在拖拽过程中，需要不停地设置目标元素的位置，这样它才能够移动起来，因此还需要声明一个设置元素位置的方法。 // pos = { x: 200, y: 100 } function setTargetPos(elem, pos) { var transform = getTransform(); if (transform) { elem.style[transform] = 'translate(' + pos.x + 'px, ' + pos.y + 'px)'; } else { elem.style.left = pos.x + 'px'; elem.style.top = pos.y + 'px'; } return elem; } 有了这几个工具方法后，就可以使用更为完善的方式来实现上述要求的效果了 var drag = document.querySelector('.drag'); drag.addEventListener('click', function() { var curPos = getTargetPos(this); setTargetPos(this, { x: curPos.x + 5, y: curPos.y }); }, false); 拖拽的原理结合 mousedown、mousemove、mouseup 这三个事件来实现拖拽。在这些事件触发的回调函数中得到了一个事件对象，通过事件对象获取当前鼠标所处的位置。 当鼠标按下 mousedown 时，记住鼠标的初始位置与目标元素的初始位置。当鼠标移动时，目标元素也跟着移动，因此鼠标与目标元素的位置有如下关系: 移动后鼠标位置-鼠标初始位置=移动后目标元素位置-目标元素初始位置； 如果鼠标位置的差值用变量 dis 来表示，那么目标元素的位置就等于: 移动后目标元素位置=dis+目标元素的初始位置； 通过事件对象中提供的鼠标位置，在鼠标移动时可以计算出鼠标移动位置的差值，然后根据上面的关系，计算出目标元素的当前位置，这样拖拽就能够实现了。 代码实现 第一步：准备工作 // 获取目标元素对象 var drag = document.querySelector('.drag'); // 声明2个\b变量用来保存鼠标初始位直的x, y坐标 var startX = 0; var startY = 0; // 声明2个变量用来保存目标元素初始位直的X, y坐标 var sourceX = 0; var sourceY = 0; 第二步：功能函数 // 获取当前浏览器支持的 transform 兼容写法 function getTransform() {} // 获取元素属性 function getStyle(elem, property) {} // 获取元素的初始位直 function getTargetPos(elem) {} // 设置元素的初始位直 function setTargetPos(elem, potions) {} 第三步：声明三个事件的回调 drag.addEventListener('mousedown', start, false); // 绑定在 mousedown 上的回调，event为传入的事件对象 function start(event) { // 获取鼠标初始位直 startX = event.pageX; startY = event.pageY; // 获取元素初始位置 var pos = getTargetPos(drag); sourceX = pos.x; sourceY = pos.y; // 绑定 document.addEventListener('mousemove', move, false); document.addEventListener('mouseup', end, false); } function move(event) { // 获取鼠标当前位置 var currentX = event.pageX; var currentY = event.pageY; // 计算差值 var distanceX = currentX - startX; var distanceY = currentY - startY; // 计算并设直元素当前位置 setTargetPos(drag, { x: (sourceX + distanceX).toFixed(), y: (sourceY + distanceY).toFixed() }) } function end(event) { document.removeEventListener('mousemove', move); document.removeEventListener('mouseup', end); // do something } 至此，一个简单的拖拽就实现了。 使用面向对象进行封装我们的目标是，只要声明一个拖拽实例，然后传入目标元素就自动具备可以被拖拽的功能。 为了避免变量污染，我们需要将模块放置在一个函数自执行方式模拟的块级作用域中。 (function() { // ... })(); 接下来我们如何用面向对象的思维合理地处理属性与方法的位置，需要考虑以下问题： 构造函数中：属性与方法为当前实例所单独拥有，只能被当前实例访问，并且每声明一个实例，其中的方法都会被重新创建一次。 原型中： 属性与方法为所有实例共同拥有，可以被所有实例访问，新声明的实例不会重复创建方法。 模块作用域中：属性和方法不能被任何实例访问，但是能被内部方法访问，新声明的实例不会重复创建相同的方法。 对于方法的判断则比较简单，因为构造函数中的方法总是在声明一个新的实例时被重复创建，因此声明方法时应尽量避免出现在构造函数中。如果你的方法中需要用到构造函数中的变量，或者想要公开，那么就需要放在原型中。如果方法需要私有不被外界访问，那么就放置在模块作用域中。 使用面向对象封装上面的几点必须认真思考。如果在封装时没有思考清楚，很可能会遇到很多意想不到的 bug。 直接上代码： (function() { // 这是一个私有属性，不需要被实例访问 var transform = getTransform(); function Drag(selector) { // 放在构造函数中的属性，被每一个实例所单独拥有 this.elem = typeof selector == 'Object' ? selector : document.getElementById(selector); this.startX = 0; this.startY = 0; this.sourceX = 0; this.sourceY = 0; this.init(); } // 原型 Drag.prototype = { constructor: Drag, init: function() { // 初始时需要做哪些事情 this.setDrag(); }, // 稍作改造，仅用于获取当前元素的属性，类似于getName getStyle: function(property) { return document.defaultView.getComputedStyle ? document.defaultView.getComputedStyle(this.elem, false)[property] : this.elem.currentStyle[property]; }, // 用来获取当前元素的位直信息，注意与之前的不同之处 getPosition: function() { var pos = { x: 0, y: 0 }; if (transform) { var transformValue = this.getStyle(transform); if (transformValue == 'none') { this.elem.style[transform] = 'translate(0, 0)'; } else { var temp = transformValue.match(/-?\\d+/g); pos = { x: parseInt(temp[4].trim()), y: parseInt(temp[5].trim()), } } } else { if (this.getStyle('position') == 'static') { this.elem.style.position = 'relative'; } else { pos = { x: parseInt(this.getStyle('left') ? this.getStyle('left') : 0), y: parseInt(this.getStyle('top') ? this.getStyle('top') : 0) } } } return pos; }, // 用来设直当前元素的位置 setPosition: function(pos) { if (transform) { this.elem.style[transform] = 'translate(' + pos.x + 'px, ' + pos.y + 'px)'; } else { this.elem.style.left = pos.x + 'px'; this.elem.style.top = pos.y + 'px'; } }, // 该方法用来绑定事件 setDrag: function() { var self = this; this.elem.addEventListener('mousedown', start, false); function start(event) { self.startX = event.pageX; self.startY = event.pageY; var pos = self.getPosition(); self.sourceX = pos.x; self.sourceY = pos.y; document.addEventListener('mousemove', move, false); document.addEventListener('mouseup', end, false); } function move(event) { var currentX = event.pageX; var currentY = event.pageY; var distanceX = currentX - self.startX; var distanceY = currentY - self.startY; self.setPosition({ x: (self.sourceX + distanceX).toFixed(), y: (self.sourceY + distanceY).toFixed() }) } function end(event) { document.removeEventListener('mousemove', move); document.removeEventListener('mouseup', end); // do other things } } } // 私有方法，仅仅用来获取 transform 的兼容写法 function getTransform() { var transform = '', divStyle = document.createElement('div').style, transformArr = ['transform', 'webkitTransform', 'MozTransform', 'msTransform', 'OTransform'], i = 0, len = transformArr.length; for (; i &lt; len; i++) { if (transformArr[i] in divStyle) { return transform = transformArr[i] } } return transform; } // 对外暴露方法 window.Drag = Drag; })(); 使用时只需 // 使用 new Drag('target'); 这样一个拖拽对象就封装完成了，封装过程代码都有注释详解，很简单。 将拖曳对象扩展为一个 jQuery 插件jQuery 中可以使用 $.extend 扩展 jQuery 工具方法，来使用 $.fn.extend 扩展原型方法。当然，这里的拖拽插件扩展为原型方法是最合适的。 在上面封装的代码基础上我们再加一些 //通过扩展方法将拖曳扩展为 jQuery 的一个实例方法 (function($) { $.fn.extend({ canDrag: function() { new Drag(this[0]); return this; // 注意:为了保证 jQuery 所有的方法都能够链式访问， // 每一个方法的最后都需妥返回 this, 即返回 jQuery 实例 } }) })(jQuery);\b 这样就能够很轻松地让目标 DOM 元素具备拖拽能力了，使用时只需 $('#target').canDrag();","tags":[{"name":"javascript","slug":"javascript","permalink":"http://coder.liusixin.cn/tags/javascript/"},{"name":"jQuery","slug":"jQuery","permalink":"http://coder.liusixin.cn/tags/jQuery/"}]},{"title":"Nginx的服务器缓存策略","date":"2017-08-18T12:42:27.000Z","path":"posts/cd5a0d4f/","text":"前言要了解缓存首先我们先了解下浏览器的执行机制是怎样的，先看一张图： 浏览器对我们的静态资源，比如说 js css html 图片 字体 等都是有缓存策略的，如果说浏览器自身有缓存，它就会从自己本身的缓存里读了，我们也可以通过网络层类似于我们的服务器包括 Nginx 还有各种各样的静态资源服务器来设置我们的缓存。 如果本机的浏览器有缓存的话，那么他直接就在这个缓存里就获取到了，然后呈现给用户 那么这个缓存还需要查看，如果是在网络上会查看它是否是过期的： 如果不是过期的，它也是从本地的缓存中读取之后就可以了； 如果是过期的就需要看一下这个资源有没有 Etag 这样的东西，Etag 是浏览器向服务器发送请求时的一个请求报头，服务器那边也会响应这个请求报头，然后两边共同的匹配一下资源是否过期，如果有 Etag 的话，它就会向浏览器注入 If-None-Match 这样的头。然后向我们的 webserver 发过去，然后服务器那边做一个基础的策略：是否是匹配的 Etag ，如果是匹配的就返回一个 304，如果没有匹配就给 Etag 这个文件一个戳，然后返回 200 更新，这样下次再请求的时候有了这个 Etag 就不会再把整个的资源再重新拉回来了。 如果没有发现 Etag 的话，在我们服务器还可以设 Expires ，Expires 这个东西就是过期时间，他发现 Last-Modified 这样一个策略，它会向我们的服务器发送一个 If-Modified-Since ，就是说上次的修改时间，然后和服务器的 Expires 做一个对比，如果发现过期了就返回一个新的，如果是没过期就返回一个 304。 如果是上面的 Etag 和 Last-Modified 两个值都没有，那么他就会直接向我们的 web服务器发送一个请求，然后是请求响应–缓存协商 如果是上面的 Etag 和 Last-Modified 这两个值都进行设置了，那么就是会将两个值都比较，都满足了之后才会最终得到一个响应，没有谁先谁后的问题，那么当我们设置对应的文件的时候，你会发现很多对应的服务器都是同时的对他们进行设置的，就是设置了 Etag 又设置了 Last-Modified ，所以说当你这个文件有对应的修改的时候，你还要及时的去修改这个 Last-Modified 就是里面的一个 Expires 的东西。 Etag 相比于 Expires 有很多优点，它是一个基于文件的一个戳的比较，可以实现一个实时的更新，Expires 这个东西实际上是做不到那种秒秒级别的，它是一个 Unix 的一个时间戳，他做不到那种特别精细的时间的控制。 现在的话你也可以在 Header 里面设 control ，可以直接重写掉 Expires 这样的东西。 如果是一个整个的项目，你不是运维工程师的话，你可以跟运维去说：我需要设置这个文件对应的强缓，就比如说：这个文件 30 年不过期，例如 jquery 这种长时间不过期的文件，这个的话一般就用 Expires 的比较多，就是说过期时间设置较长这个就是强缓，那么 Etag 的话一般是针对的我们的业务的文件。 实践 你需要知道的是：在任何的其他的服务器里面，它们这个的逻辑、思维是一样的，关键是要去看你是怎么去配置的。 操作 Nginx 的基础是你已经在服务器端安装并配置好了，这里以 Centos 为例。 编辑nginx.conf 找到对应的静态资源路径 比如 /usr/share/nginx/ 下的 html 文件夹下 index.html，我们在 body 中加入 jquery 文件 &lt;script src=\"https://cdn.bootcss.com/jquery/3.2.1/jquery.js\">&lt;/script> 同时在同级目录下添加 img 文件夹，放入几张图片。 在 index.html 中添加这些 img 标签引入图片。配置nginx.conf 文件。 在请求所有的目录的路径中匹配 图片 正则表达式，如果匹配的话就是下面的 第一行是 文件的具体路径；第二行是过期时间 30天。 还有一个需要注意的是：再进行验证的时候不能把下图中的这个 Disable cache 勾选上，这个勾选上的话就是禁用缓存了，这里我们实现的是需要缓存的，所以是绝对不能勾选的 来分析下请求到的东西 document 请求报文中的 Accept-Encoding 这个可以看到是支持 gzip 压缩的。 返回报文中的 ETag 加了一个戳，这个是 nginx 默认就开启的，如果是想要关闭的话，在 nginx.conf 文件中的 http 对象里加 etag: off; 即可，开启就是 on，不加的话默认的就是 on 可以看到下面请求报文中有一个 If-None-Match 的值也是和上面的 Etag 的值是一样的。 jquery 因为这这里默认开启了 Etag 所以当你下次刷新的时候，它会跟服务器做对比，如果 Etag 的值是一样的说明没有改变就返回的是 304 ，可以看到下面请求报文中有一个 If-None-Match 的值也是和上面的 Etag 的值是一样的 再次刷新浏览器，查看 document 这个返回的是 304 是因为我们的 index.html 文件没有改变，ETag 的值也没有发生改变，如果 Etag 值是一样的说明没有改变就返回的是 304 ，可以看到下面请求报文中有一个 If-None-Match 的值也是和上面的 Etag 的值是一样的 开启gzip，同时为了看出效果我们在第二个命令行窗口中修改 index.html 文件之后再刷新浏览器 也会发现 document 返回的报文中多了一个 gzip 的属性，然后是可以看到下面请求报文中有一个 If-None-Match 的值和上面的 Etag 的值已经不一样的，这个的机制是以 If-None-Match 后面的戳去匹配 Etag 也就是服务器响应的戳，发现是不一样的就会重新将更新后的资源拿过来 状态码也是 200 如果是没有这个 Etag ，它会校验 Last-Modified 和 If-Modified-Since 的戳是否一样，服务器来返回相应的状态。 接下来在第一个命令行窗口中在 nginx.conf 文件中增加一个 epirse，过期时间的属性，对比一下效果 这个时候再刷新浏览器查看 这个时候会发现返回报文中多了一个 Expires 过期时间的属性，后面的值刚好是今天再加上 30 天之后的具体日期 还可以在 nginx.conf 文件中加一句话：告诉浏览器不要缓存文件 add_header Cache-Control no-cache; 再刷新浏览器，第一次是 200 第二次是 304 ，还有就是服务器返回时也有明确的标识：Cache-Control: no-cache 就是告诉浏览器不要缓存，然后具体的资源文件是像服务器请求的，服务器来决定返回的状态码 总结将上面的东西都尝试的设置一遍之后，那么 Nginx 上比较关键的东西：Gzip 、Etag、 Expires （过期时间）、Cache-Control 这些就都配置好了； Cache-Control 下面还会有一些非常细致的东西：如果你在 Cache-Control 中配置了更多的过期时间就可以直接把 Expires 直接重写掉了，在一些不支持 HTTP.1 的浏览器里设置 Expires 是没有用的，所以你还是要再设置一个 Cache-Control 百度官网的一个 js 文件的响应头部，有颜色的那些对我们来说都是需要掌握的东西 掌握这个东西之后，对于以后来讲我们就可以跟运维去聊这个东西，比如说：我们的 jquery ，你就可以直接告诉他，我的这个jquery需要在页面上缓存多久多久，这个就可以设置一个 过期时间 Expires 或者是 Cache-Control，我的其他业务文件可能会临时变，所以需要配置 Etag 。","tags":[{"name":"Nginx","slug":"Nginx","permalink":"http://coder.liusixin.cn/tags/Nginx/"}]},{"title":"Nginx的反向代理与负载均衡","date":"2017-08-17T14:40:27.000Z","path":"posts/75614776/","text":"前言Nginx 是一个非常轻量级的服务器，他虽轻但是他最大的优点就是可以承载大量的并发，所以说一般的话很少有用 Node 直接去做服务器让用户去访问的，因为 Node 本身就需要做非 常非常多的事情，虽然说简单的可以使用 Node 直接开启，但是对于负载和并发 Node 是弱项，就是反向代理和并发是 Node 整个的弱项，所以我们需要在前面用 Nginx 挡一层，这样的话对于我们整个的系统的运维架构来讲也是一个非常得力的一个助手，还有就是跟其他的比如说我们后层整个架构的设计属于运维的这一块，它也是有一种先天优势的这样的服务器 概述 什么是反向代理与负载均衡 反向代理 负载均衡 Nginx 负载均衡的实现 HTTP UPstream 模块 什么是 HTTP Upstream 模块 ip_hash 指令 – 落到哪个上 server 指令 – server 的权重 UPstream 指令 其他负载均衡的方法 1. 什么是反向代理与负载均衡1.1 反向代理 比如说平时我们上谷歌上不了然后需要翻墙，谷歌是我们明确的去要访问的站点，这个时候我们会用一些翻墙的工具（代理服务器），这个代理服务器帮我们取回谷歌给我们看，这个就是一个正向的代理。 那么反向 代理刚好是相反的：我们不知道去取哪一台机器，然后代理帮我们去取，然后把取到的内容返回给我们。 一个是明确的知道，一个是不知道，这就是正向代理和反向代理 就是用自己的计算机 A 想访问国外的网站 B ，访问不了，就有一个中间的服务器 C 它去访问国外的网站 B ，其实如果是把这个 C 装到我们自己的电脑上，我们自己的电脑访问 C ，然后 C 再去访问 B ，这个时候这个 C 就叫代理服务器，这个时候就是正向代理，他有一个特点，就是我们一定知道要访问哪个网站。 还有就是当我们有一个服务器集群，而且服务器集群中的每台服务器的内容都是一样的时候，同样我们从个人的电脑访问到比如说 现在我们有四台 Node 的机器 ，但是我们无法访问，这个时候有第三方的服务器是可以访问到 那四个 Node 的机器的 ，这个时候我们就可以借助这个第三方的服务器去访问， 但是我们并不知道它最后会落到四台中的哪一台机器上，这个就是反向代理。 1.2 负载均衡跟上面的反向代理有一个息息相关的东西就是负载均衡，就是上面的四台机器，你不知道最终要找的是谁，但是 Nginx 知道，它会帮你找到压力最小的那个服务器然后返回给你，就这样的可以分担你的压力 2. Nginx 负载均衡的实现 3. HTTP UPstream 模块3.1 什么是 HTTP UPstream 模块 3.2 ip_hash 指令 比如用户落在这样一台服务器上了，然后下次用户一刷新又落到别的上面了，这个就不太对了，所以 ip_hash 是为了保证用户再次刷新的时候还能落到他之前落到的那台服务器上，这样就 ok 了 3.3 server 指令 可以指定这台服务器的权重，就是说如果你知道了这台机器要比别的优秀，那么你可以给它的权重给标的高一点，那么更多的请求就会落到这个你认为优秀的机器上面，默认是 1:1:1 的，这个 1:1:1 可以举成 2:1:1 的例子来说明：就是现在有三台机器，第一台的权重被设置为了 2 后面两台都是 1 ，这样的话落到第一台的几率就是 2 / 3，后面两台的都是 1 / 3。 3.4 UPstream 指令 4. 其他负载均衡的方法 实践macOS 部署 Nginx 这个时候你会发现页面 title 的 icon 是 Jenkins 的头像，这个原因是因为如果你装过 Jenkins 的话，它是非常顽固的会不停的去折腾、重启你的 8080 端口，你如果是 kill 是杀不掉的，你需要用下面的命令就可以把它给停掉了 ## 停掉 jenkins sudo launchctl unload/Library/LaunchDaemons/org.jenkins-ci.plist ## 停掉之后如果想启动 jenkins systemctl start jenkins 想要进行上面的 反向代理和负载均衡 还需要对 nginx 进行配置 /etc/nginx/ 这个是 macOS 下 nginx 的安装目录，其他系统的可能会不大一样 ## 先进入 nginx 目录 cd /etc/nginx/ ## 查看该目录下的所有文件，可以在下图看到 nginx 目录 ls 可以看到里面有个 nginx.conf 的文件，这个就是 nginx 的配置文件 ##user 指的是哪个用户能用，可以将后面的 nobody 修改成你指定谁用的那个用户的用户名 worker_processes 这个是你的一个工作的进程，其实实际上指的就是 CPU 的核数，如果你是 4 核的话，这个值就是 4，你需要看到自己的电脑是几核的处理器，然后你可以在这里面做相应的设置，最多就是 2 倍，一般就是标准的几核就是几个 或者 2 倍，这个不能乱设 error_log 这个就是整个产生错误的日志 nginx 的日志跟我们 Node 的日志比一点都不逊色，它们的区别是：nginx 可以完全的记录所有的请求的日志，因为它是一个向外去扩散的一个去做负载均衡的口子，你的那个 Node 是你的项目里的一些 log ，两个人都各自有分工。 这个 log 是会非常庞大的，所以像有的一些大公司会有专门去存 log 的服务器，那些数据挖掘的人或者是运维会每天去查这个日志，从这些日志里其实可以拿到很多很多的东西，所以这个日志是至关重要的，对于大公司来讲这个是比命还重要的东西，所以 nginx 的日志是万万不能丢的，任何语言里的日志它们都会分成 level（级别）。 上面的第一行就是 出错的日志 ，第二行是警告的，第三行是基本信息。 pid 这个是 nginx 非常重要的一个配置文件，这个就别动就好了 events -&gt; worker_connections 这个就是整个的连接数，就是说你一下子往你的这个上面压多少 http 模块 在这个里面可以去指定一下所谓的我们平时的 gzip 、Etag 等等都是从这里去开启的 server listen 这里是监听 8080 端口 charset koi8-r这个是它输出的语言 access_log 这个是它的日志 location 这个非常重要，里面的 root 不是指的同户名，而是当前的 html 文件夹，它会从下面的顺序依次开始找，直到找到对应的一个文件然后去给你吐 error_page 这个是 Node 控制出错的，有时你会发现百度、腾讯或者是其他的一些公司的 404 是一样的，原因就是在这的，所有的请求都固定到这，然后他把一些出错都控制好 是这样的一个原因 下面还有一些 500 502 503 504 ，他都把这些出错导到 50x 去了，所以这些不是真正的内部的系统去做的。而是一些做负载均衡的服务器去做的 location ~ \\.php$ 这些就是用正则去匹配一些更复杂的，就是你真正的路由都可以在这里面去写 ## 这个就是我们前端需要给运维做的东西，这个是从复杂的 nginx 里去抽出来的 worker_processes 4; ## 这个是你的一个工作的进程，其实实际上指的就是 CPU 的核数 events{ worker_connections 1024; ## 这个就是整个的连接数，就是说你一下子往你的这个上面压多少 } ## 上面两个其实你不给运维的话也是可以的，他都不要，你写了也没用，关键的就是下面的 http http{ ## 这个是负载均衡的所有的 server ，这里的 IP 地址需要写成你需要用到的真实有效的才行 upstream firsttest{ server 192.168.230.128; server 192.168.230.129; } server{ ## 通过 server 监听的是 8080 listen 8080; ## 当你访问 / 这个路由地址的时候 通过下面的 proxy_pass 代理去访问 firsttest 然后就可以了 location / { proxy_pass http://firsttest; } } }","tags":[{"name":"Nginx","slug":"Nginx","permalink":"http://coder.liusixin.cn/tags/Nginx/"}]},{"title":"如何开发一个响应式页面","date":"2017-08-13T05:58:59.000Z","path":"posts/e5c359b0/","text":"本文主要介绍如何开发一个移动端响应式页面。 步骤 1 - 添加 viewport meta 标签在页头 head 标签内添加 viewport meta 标签是实现响应式页面的第一步，以便优化在移动设备上的展示效果，其推荐的设置为： &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"> 步骤 2 - 使用 Media QueriesMedia Queries 是为指定特性的浏览器视窗应用指定样式的手段，不同的样式代码，相当于为不同的设备应用了不同的 CSS 样式。 参数 属性 介绍 min-width | 当视窗宽度大于或等于指定值时，@media 规则下的样式将被应用max-width | 当视窗宽度小于或等于指定值时，@media 规则下的样式将被应用min-height | 当视窗高度大于或等于指定值时，@media 规则下的样式将被应用max-height | 当视窗高度小于或等于指定值时，@media 规则下的样式将被应用orientation=portrait | 当视窗高度大于或等于宽度时，@media 规则下的样式将被应用orientation=landscape | 当视窗宽度大于高度时，@media 规则下的样式将被应用… 用法 方法 1，使用 link 标签，根据指定特性引入特定的外部样式文件&lt;link rel=\"stylesheet\" media=\"(max-width: 640px)\" href=\"max-640px.css\"> 方法 2，直接在 style 标签或 样式文件内使用 @media 规则@media (max-width: 640px) { /*当视窗宽度小于或等于 640px 时，这里的样式将生效*/ } 样式断点 Media Queries 所使用的查询参数的临界值又可称为「样式断点」。 依据目标设备的分辨率，制定一套合适的样式断点，并为不同的断点定制必要的 CSS 样式。 移动端优先的页面，可使用 min-width 查询参数从小到大来定义断点。常见的样式断点： 属性 说明 mobile | 移动设备断点，视窗宽度 ≤ 768 pxtablet | 平板电脑设备断点，视窗宽度 ≥ 769 pxdesktop | 桌面电脑断点，视窗宽度 ≥ 1024 pxwidescreen | 宽屏电脑断点，视窗宽度 ≥ 1216 pxfullhd | 高清宽屏电脑断点，视窗宽度 ≥ 1408 px… 如果针对 tablet 及以上的设备定制样式，我们就可以这样写了： @media (min-width: 769px) { /* tablet 及以上的设备，页面背景色设置为红色 */ body { background-color: red; } } 步骤 3 - 使用 Viewport 单位及 remMedia Queries 只解决了「为不同特性的浏览器视窗使用不同的样式代码」的问题，而 Viewport 单位及 rem 的应用，则是为了解决第二个问题：让页面元素的尺寸能够依据浏览器视窗尺寸变化而平滑变化。 方法 1 - 仅使用 vw 作为 CSS 长度单位在仅使用 vw 单位作为唯一 CSS 单位时，我们需遵守： 利用 Sass 函数将设计稿元素尺寸的像素单位转换为 vw 单位 // iPhone 6尺寸作为设计稿基准 $vw_base: 375; @function vw($px) { @return ($px / $vm_base) * 100vw; } 无论是文本字号大小还是布局高宽、间距、留白等都使用 vw 作为 CSS 单位 .mod_nav { background-color: #fff; &amp;_list { display: flex; padding: vw(15) vw(10) vw(10); // 内间距 &amp;_item { flex: 1; text-align: center; font-size: vw(10); // 字体大小 &amp;_logo { display: block; margin: 0 auto; width: vw(40); // 宽度 height: vw(40); // 高度 img { display: block; margin: 0 auto; max-width: 100%; } } &amp;_name { margin-top: vw(2); } } } } 1 物理像素线（也就是普通屏幕下 1px ，高清屏幕下 0.5px 的情况）采用 transform 属性 scale 实现 .mod_grid { position: relative; &amp;::after { // 实现1物理像素的下边框线 content: ''; position: absolute; z-index: 1; pointer-events: none; background-color: #ddd; height: 1px; left: 0; right: 0; top: 0; @media only screen and (-webkit-min-device-pixel-ratio: 2) { -webkit-transform: scaleY(0.5); -webkit-transform-origin: 50% 0%; } } ... } 对于需要保持高宽比的图，应改用 padding-top 实现 .mod_banner { position: relative; // 使用padding-top 实现宽高比为 100:750 的图片区域 padding-top: percentage(100/750); height: 0; overflow: hidden; img { width: 100%; height: auto; position: absolute; left: 0; top: 0; } } 由此，我们不需要增加其他任何额外的脚本代码就能够轻易实现一个常见布局的响应式页面。 方法 2 - vw 搭配 rem，寻找最优解方法 1 实现的响应式页面虽然看起来适配得很好，但是你会发现由于它是利用 Viewport 单位实现的布局，依赖于视窗大小而自动缩放，无论视窗过大还是过小，它也随着视窗过大或者过小，失去了最大最小宽度的限制，有时候不一定是我们所期待的展示效果。试想一下一个 750px 宽的设计稿在 1920px 的大屏显示器上的糟糕样子。 我们可以结合 rem 单位来实现页面的布局。rem 弹性布局的核心在于根据视窗大小变化动态改变根元素的字体大小，那么我们可以通过以下步骤来进行优化： 给根元素的字体大小设置随着视窗变化而变化的 vw 单位，这样就可以实现动态改变其大小 其他元素的文本字号大小、布局高宽、间距、留白都使用 rem 单位 限制根元素字体大小的最大最小值，配合 body 加上最大宽度和最小宽度，实现布局宽度的最大最小限制… 核心代码实现如下： // rem 单位换算：定为 75px 只是方便运算，750px-75px、640-64px、1080px-108px，如此类推 $vw_fontsize: 75; // iPhone 6尺寸的根元素大小基准值 @function rem($px) { @return ($px / $vw_fontsize ) * 1rem; } // 根元素大小使用 vw 单位 $vw_design: 750; html { font-size: ($vw_fontsize / ($vw_design / 2)) * 100vw; // 同时，通过Media Queries 限制根元素最大最小值 @media screen and (max-width: 320px) { font-size: 64px; } @media screen and (min-width: 540px) { font-size: 108px; } } // body 也增加最大最小宽度限制，避免默认100%宽度的 block 元素跟随 body 而过大过小 body { max-width: 540px; min-width: 320px; } 总结在实际工作过程中，考虑到设计以及开发成本，视觉设计师是不大可能为每种不同分辨率的设备分别设计不同的稿子的，拿移动端页面来说，通常会以 iPhone 6 的分辨率（宽为 750 px）作为基准分辨率来出设计稿。","tags":[{"name":"CSS","slug":"CSS","permalink":"http://coder.liusixin.cn/tags/CSS/"},{"name":"响应式","slug":"响应式","permalink":"http://coder.liusixin.cn/tags/响应式/"},{"name":"移动端","slug":"移动端","permalink":"http://coder.liusixin.cn/tags/移动端/"}]},{"title":"造轮子系列：封装一个简化版的jQuery","date":"2017-08-11T14:28:44.000Z","path":"posts/1d3e321c/","text":"jQuery 封装详解我们来实现一个简化版的 jQuery 库 一个库就是一个单独的模块，因此应使用自执行函数的方式模拟一个模块。 (function() { // do something }); 既然能够在全局直接调用 jQuery，则说明 jQuery 被挂载在了全局对象上。 块中对外提供接口时，可以采取 window.jQuery 的方式。 var jQuery = function() {}; // ... window.jQuery = jQuery; 我们在使用过程中，使用了 $，其实只是多加了一个赋值操作。 window.$ = window.jQuery = jQuery; 在使用过程中直接使用 $，其实相当于直接调用构造函数 jQuery 创建了一个实例，而没有用 new。 我们知道创建实例 new 关键字是必不可少的，由此说明 new 的操作被放在了 jQuery 方法中来实现，而 jQuery 并不是真正的构造函数。 (function(ROOT) { // 构造函数 var jQuery = function(selector) { // 在该方法中直接返回new创建的实例， // 因此这里的 init 才是真正的构造函数 return new jQuery.fn.init(selector); }; jQuery.fn = jQuery.prototype = { constructor: jQuery, version: '1.0.0', init: function(selector) { var elem, selector; elem = document.querySelector(selector); this[0] = elem; // 在jQuery中返回的是一个由所有原型属性方法组成的数组， // 这里做了简化，直接返回this即可 return this; }, // 在原型上添加一堆方法 toArray: function() {}, get: function() {}, each: function() {}, ready: function() {}, first: function() {}, slice: function() {} // ...more }; // 让 init 方法的原型指向jQuery的原型 jQuery.fn.init.prototype = jQuery.fn; ROOT.jQuery = ROOT.$ = jQuery; })(window); 在上面的实现中，首先在 jQuery 构造函数中声明了一个 fn 属性，并将其指向了原型 jQuery.prototype。 随后在原型对象中添加了 init 方法。 jQuery.fn = jQuery.prototype = { init: function() {} }; 之后又将 init 的原型指向了 jQuery.prototype。 jQuery.fn.init.prototype = jQuery.fn; 而在构造函数 jQuery 中 ，则返回了 init 的实例对象。 var jQuery = function(selector) { return new jQuery.fn.init(selector); }; 最后对外暴露接口时，将字符 $ 与方法 jQuery 对等起来。 ROOT.jQuery = ROOT.$ = jQuery; 因此当使用 $(&#39;#test&#39;) 创建一个 jQuery 实例时，实际上调用的是 jQuery(&#39;#test&#39;) 创建的一个 init 实例。这里正在构造函数的是原型中的 init 方法。 扩展方法jQuery 提供了两个扩展接口来帮助自定义 jQuery 的方法，通常称自定义的 jQuery 方法为 jQuery 桶件。 (function(ROOT) { // 构造函数 var jQuery = function(selector) { // 在该方法中直接返回new创建的实例， // 因此这里的 init 才是真正的构造函数 return new jQuery.fn.init(selector); }; jQuery.fn = jQuery.prototype = { constructor: jQuery, version: '1.0.0', init: function(selector) { var elem, selector; elem = document.querySelector(selector); this[0] = elem; // 在jQuery中返回的是一个由所有原型属性方法组成的数组， // 这里做了简化，直接返回this即可 return this; }, // 在原型上添加一堆方法 toArray: function() {}, get: function() {}, each: function() {}, ready: function() {}, first: function() {}, slice: function() {} // ...more }; // 让 init 方法的原型指向jQuery的原型 jQuery.fn.init.prototype = jQuery.fn; // 实现 jQuery 的两种扩展方法 jQuery.extend = jQuery.fn.extend = function(options) { // 在jQuery源码中根据参数不同进行不同的判断，这里假设只有一种方式 var target = this; var copy; for (name in options) { copy = options[name]; target[name] = copy; } return target; }; // jQuery利用上面实现的扩展机制，添加了许多方法 // 添加静态扩展方法，即工具方法 jQuery.extend({ isFunction: function() {}, type: function() {}, parseHTML: function() {}, parseJSON: function() {}, ajax: function() {} // ...more }); // 添加原型方法 jQuery.fn.extend({ queue: function() {}, promise: function() {}, attr: function() {}, prop: function() {}, addClass: function() {}, removeClass: function() {}, val: function() {}, css: function() {} // ...more }); ROOT.jQuery = ROOT.$ = jQuery; })(window); 在上面的代码中，我们通过下面的方式简单实现了两个扩展方法。 jQuery.extend = jQuery.fn.extend = function(options) { // 在jQuery源码中根据参数不同进行不同的判断 // 而这里直接用了一种方式 ，所以就不用判断了 var target = this; var copy; for (name in options) { copy = options[name]; target[name] = copy; } return target; }; 要理解它的实现，首先要明确知道内部 this 的指向。传人的参数 options 对象是一个 key-value 模式的对象。我们可以通过 for in 遍历 options，将 key 作为新的属性，value作为该属性对应的新方法，分别添加到 jQuery 与 jQuery.fn 中。 也就是说，当通过 $.extend 扩展 jQuery 时，方法被添加到了静态方法中;而通过 $.fn.extend 扩展 jQuery 时，方法被添加到了原型对象中。静态方法可以直接调用，因此也被称为工具方法。 $.ajax(); $.isFunction(); $.each(); 原型方法必须通过声明的实例才能调用 $('#test').css(); $('#test').attr();","tags":[{"name":"javascript","slug":"javascript","permalink":"http://coder.liusixin.cn/tags/javascript/"},{"name":"jQuery","slug":"jQuery","permalink":"http://coder.liusixin.cn/tags/jQuery/"}]},{"title":"HTTP性能优化指南","date":"2017-08-06T14:48:57.000Z","path":"posts/9b8e26f4/","text":"概述 浏览器渲染过程 DNS TCP 三次握手 HTTP 缓存机制 CDN 与集群 还记得 HTTP 协议吗？ 浏览器先输入一个网址 然后浏览器先会去互联网上找 DNS 服务器进行解析 从 DNS 服务器拿到服务器 IP 以后，在回到浏览器中 然后浏览器拿着 IP 去发送 HTTP 请求 服务器处理请求 服务器响应请求 浏览器处理响应 继续请求其它资源 从 prompt 到 response 是和网络相关的，从 processing 到 onload 是和浏览器相关的。 prompt for unload 这一步是先把之前的页面干掉 redirect、upload 这一步是衔接前面的，也是和缓存相关的，浏览器发一个请求，是从缓存取，还是从服务器拿 app cache 如果要从缓存拿的话，我就处理本地应用 cache，如果没有就无所谓了 DNS 开始解析 解析结束 有这些事件我们就可以去在这些节点上进行优化 TCP 层面 三次握手 开始连接 connectStart https 连接 secureConnectionStart 连接结束 connectEnd 然后服务器会拿到你的请求路径 Request 发送响应，但是连接还没完 Processing 处理文档 domLoading 开始载入 dom dominteractive 把文档设置为交互状态 domContentLoaded 触发这个事件 domComplete 浏览器把文档设置为 complete（表示文档与网络相关的修改已经结束了） onLoad (这个 onload 和，绑定那个 onload 事件是可以对应的) loadEventStart loadEventEnd 上面这是一次连接，然后下次再发请求的时候，回直接从 Request 开始。 是因为浏览器做了个优化，可以复用这个连接。 资源少就一个 tcp 连接，多任务就会打开多个 tcp 连接。keep-Alive 模式 如何优化 网络：DNS、TCP 连接 传输 浏览器 缓存，包括浏览器本身的缓存和服务器中的缓存 DNS DNS 是域名系统，用于将域名转化为 IP 顶级域名 域名资源记录 域名服务器 域名解析 TCP 三次握手与四次挥手（如果少一次就不能保证，多一次就浪费。 三次握手 你发起连接请求 服务源接受你发送的连接，然后服务源会给你发送一个数据 然后你再发一条数据，告诉服务端我收到了 四次挥手 浏览器给服务源发送数据说我要挂了。 服务源响应说我收到你的请求了可以挂，我也要挂了。 然后浏览器发送数据可以断开。 服务源断开连接。 osiiso 模型和 TCP/IP 模型 应用层（data 数据。HTTP、FTP、DNS、DHCP） 表示层 会话层（TCPIC 把上面三个合并为应用层。HTTP 就在这层。这一层会加一个） 传输层（TCP 协议、UDP 协议） 网络层（它封装的是二进制，它是帮助你找到对方主机，IP、ICMP 这个是 ping 发的包） 数据链路层（这一块是做了封装，数据链路层传递的是电脉冲信号，也是有一种规则的。网卡的 MAC 地址。ARP 是在局域网广播 MAC 地址，也有这种攻击，如我叫小明。） 物理层（硬件、网卡、网线、承载你数据的基础设施。纯硬件） tcpdump -n 以 ip 地址显示 host 192.168.0.200 and 111.13.100.92 -i enp1s0 显卡地址 curl 用命令行进行远程 http 通讯 CDN 主机模式 CDN 离你最近的那台服务器","tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://coder.liusixin.cn/tags/HTTP/"},{"name":"性能优化","slug":"性能优化","permalink":"http://coder.liusixin.cn/tags/性能优化/"}]},{"title":"前端性能优化--雅虎军规","date":"2017-08-02T06:02:23.000Z","path":"posts/8eb3b102/","text":"前言1. 雅虎军规显而易见的就是雅虎公司出的，雅虎公司一直都是相应的各种规范上的践行者，有一种系列的书都是雅虎出的，它们每一本书的封面都有一只动物，下图是其中一本的示例，如果说你是想要一直从事前端这个行业的话，建议你把这一系列的书都看一下，这些书有些之前的是 雅虎 出的，后来就是 图灵 出的了 2. 参考网址: 雅虎军规官网地址：英文版 雅虎军规：中文翻译版 3. 什么是雅虎军规？ 随着移动端现在的崛起，已经不止是上面的 35 条军规了，还有非常非常多的军规，这些军规是你必须要践行的，因为像上面的 35 条军规一样，这些都是在进行网站性能优化中必须掌握的，不是说一定要全都用上，只是说这些能用的你要尽量的用上，这些军规可以结合一些使前端工程自动化的工具来进行开发，自动化就是说：能用框架或者是自动化工具解决的问题，从来不用人工去介入。 正文1. 减少 HTTP 请求次数对 js 和 css 请求数量进行优化 将多个 js 文件合并成可以是两三个 js 文件，这样请求就会减少了，相应的 css link 也是这个道理 雪碧图 在和美工配合的时候页面上的图标之类的可以进行合并，将多个图片合并到一个画布上，这样就可以减少很多的请求。 2. 减少 DNS 的查找次数什么是 DNS 的查找次数？ 假如说我们访问 map.baidu.com 的时候，这个网址是需要进行查找的，他需要通过你输入的这个网址去查找相应的域名（IP），之后才会到真正的服务器上 一般 DNS 的设置都是运维工程师来负责的，但是对于我们前端也是有几点需要注意的 尽量不要让页面上的 DNS 过多，因为查找起来很慢 我们前端可以使用 DNS 预解析的方法提升页面速度 上面的 meta 将 控制 dns 预解析 的值设置为了 on 这样就可以开启 dns 预解析下面的 link 可以强制主机名查询 ，假设在页面其他位置如果引用了 该 link 的 dns 中的资源的话， 实际上在其引用之前就已经提前将其所需要的 DNS 给解析好了，这样的话就可以直接找到资源，不需要再解析 DNS 耗时了，速度也就会非常的快了，这也是我们前端可以做到的一点，下图的是其在 京东 官网上的使用 3. 避免跳转什么是避免跳转？ 这个就是说人家好不容易到你这台机器上来了，发现你这个页面不是之前的页面了，然后你这边再次做了一个跳转 打开了别的页面，尽量不要做成这种不必要的多次跳转 跳转时会建立一个 301 或者是 302 的请求报头 下图的示例是我在浏览器上以开发者模式下的手机模式输入了 PC 端的网址，打开之后会发现请求报头是 302，这个 302 被永久的建立在了这个 Header 上 ，如果没有这个 Header 的话，浏览器也分不清到底是 301 还是 302 ，他就是靠这个来标识的 301 或者 302 这样的状态码可以参考 HTTP 状态码_百度百科 中的说明进行了解，在做性能优化这方面，一些常见的状态码是必须要了解的为了去向全栈工程师发展，这个东西是必会的，全栈的话会让你在公司或者是开发项目时所占的权重会更高一些 4. 可缓存的 AJAX什么是可缓存的 AJAX？ 这个就是说我们在进行这样的请求的时候，可以把这样的 AJAX 进行一次缓存 实现的方法 gzip 组件 一般前台请求的资源都会在后台通过 gzip 组件将资源压缩之后再发送回来，然后再在客户端这边来解压，这样再传输过程中相应的资源文件就会变小很多 设置 ETags 这个全称为：Entity Tag，意思是实体标签，从名字上看，是对于某种实体的一个标识。它属于 HTTP 协议的一部分，也就是所有的 Web 服务器都应该（也确实能）支持这个特性。它的作用是用一个特殊的字符串来标识某个资源的“版本”，客户端（浏览器）来请求的时候，可以比较，如果 ETag 一致，则表示该资源并没有修改过，客户端（浏览器）可以使用自己缓存的版本。 如何实现 AJAX 的缓存，具体可参考 Ajax 请求与浏览器缓存 - ted - 博客园 ，这个实现是需要服务端来进行配合的，但是这个整个的过程你得知道，还有如果想要实现 AJAX 缓存的话请求方式尽量设置成 get ， 5. 推迟加载内容具体可参考 微距摄影_百度图片搜索 ，这个网站使用的就是滚动加载的方式，你在往下滚动时下面的图片的边滚动边请求的 6. 预加载 参考：详解 HTML5 中 rel 属性的 prefetch 预加载功能使用 7. 减少 DOM 元素数量 要尽量的去控制页面的 HTML 的数量，最好的方式是遵循 一个标签三个元素的方式：div before after 8. 根据域名划分页面内容 尽量不要把所有的资源都放在同一台服务器上，至少将 js css images 这些静态的东西放在一个 CDN 的服务器上，这样就需要多个机器来支撑这样的分离 9. 使 iframe 的数量最小 iframe 在页面中能尽量不用的话就不用，这个标签可以在页面页面中插入一个新的 HTML 文档，iframe 也有相应的优缺点 10. 不要出现 404 错误 这个意思就是页面尽量不要丢东西，HTTP 请求是会耗时的即使这个资源已经不存在了 11. 使用内容分发网络 这个就是上面所说的 CDN ，也就是说如果服务器有多余的话就一定要将 html js css 这些静态的资源单独放到一个静态资源服务器中，这样可以让用户最快的去访问到 12. 为文件头指定 Expires 或 Cache-Control 这个就是将该缓存的东西在浏览器中缓存起来，这样的话下次访问时如果请求的资源没发生改变就会直接用缓存里的，不会再去重新的请求耗时了 13. Gzip 压缩文件内容 将 Gzip 组件压缩网站的 js css 文件的状态设置为 on，如果没有开启的话需要告诉后台让其开启 14. 配置 ETag 这个和上面提到的是一样的 15. 尽早刷新输出缓存 早一点刷新 buffer（尽早给浏览器数据）。 当用户请求一个页面，服务器一般要花 200-500ms 来拼凑整个页面。这段时间，浏览器是空闲的（等数据返回）。在 php，有个方法 flush()允许你传输部分准备好的 html 响应给浏览器。这样的话浏览器就可以开始下载组件，而同时后台可以继续生成页面剩下的部分。这种好处更多是在忙碌的后台或轻前端网站可以看到。 一个比较好的 flush 的位置是在 head 之后，因为浏览器可以加载其中的样式和脚本文件，而后台继续生成页面剩余部分。 //这个示例是用的 PHP 做的中间层 &lt;!-- css, js --> &lt;/head> &lt;?php flush(); ?> &lt;body> &lt;!-- content --> 16. 使用 GET 来完成 AJAX 请求 ajax 请求用 get。 Yahoo! Mail 团队发现当使用XMLHttpRequest，POST 被浏览器实现为两步：首先发送头部，然后发送数据。所以使用 GET 最好，仅用一个 TCP 包发送（除非 cookie 太多）。IE 的 url 长度限制是 2K。 POST 不提交任何数据跟 GET 行为类似，但从语义上讲，获取数据应该用 GET，提交数据到服务器用 POST。 17. 把样式表置于顶部 研究雅虎网页性能时发现把样式表移到&lt;head&gt;里会让页面更快。这是因为把样式表移到&lt;head&gt;里允许页面逐步渲染。 关注性能的前端工程师希望页面被逐步渲染，这时因为，我们希望浏览器尽早渲染获取到的任何内容。这对大页面和网速慢的用户很重要。给用户视觉反馈，比如进度条的重要性已经被大量研究和记录。在我们的情况中，HTML页面就是进度条。当浏览器逐步加载页面头部，导航条，logo 等等，这些都是给等待页面的用户的视觉反馈。这优化了整体用户体验。 把样式表放在文档底部的问题是它阻止了许多浏览器的逐步渲染，包括 IE。这些浏览器阻止渲染来避免在样式更改时需要重绘页面元素。所以用户会卡在白屏。 HTML 规范清楚表明样式应该在&lt;head&gt;里。 18. 避免使用 CSS 表达式 CSS 表达式是强大的（可能也是危险的）设置动态 CSS 属性的方法。IE5 开始支持，IE8 开始不赞成使用。例如，背景颜色可以设置成每小时轮换： background-color: expression( (new Date()) .getHours() %2 ? '#B8D4FF': '#F08A00' ); CSS 表达式的问题是它们可能比大多数人预期的计算的更频繁。它们不仅在页面载入和调整大小时重新计算，也在滚动页面甚至是用户在页面上移动鼠标时计算。比如在页面上移动鼠标可能轻易计算超过 10000 次。 要避免 CSS 表达式计算太多次，可以在它第一次计算后替换成确切值，或者用事件处理函数而不是 CSS 表达式。 19. 使用外部 JavaScript 和 CSS 尽量不要在 html 行内写 js 或者 css 20. 削减 JavaScript 和 CSS 使用一些工具将 js 和 css 分别进行压缩和大打包 21. 用 代替 @import 之前的一个最佳原则是说 CSS 应该在顶部来允许逐步渲染。但是在 IE 用@import 和把 CSS 放到页面底部行为一致，所以最好别用。 22. 避免使用滤镜 这个是 IE 独有的东西，但是不到万不得已尽量不要使用，因为这个对渲染性能要求很高 23. 把脚本置于页面底部24. 剔除重复脚本25. 减少 DOM 访问 这个示例就是说你在 js 中使用了某个 DOM 元素，你可以先将其储存起来，这样的话下次再用的时候就会相应的快一点 26. 开发智能事件处理程序 有时候页面看起来不那么响应（响应速度慢），是因为绑定到不同元素的大量事件处理函数执行太多次。这是为什么使用事件委托是一种好方法，事件委托就是将事件绑定给相应的父级，多个子集可以根据相应的区别去执行不同的事件 另外，你不必等到 onload 事件来开始处理 DOM 树，DOMContentLoaded 更快。大多时候你需要的只是想访问的元素已在 DOM 树中，所以你不必等到所有图片被下载。 27. 减少 Cookie 体积 比如说在你每次在某个网站中的链接相互跳转的时候这些个 cookie 会把所有的 cookie 全部都带到服务器去然后服务器会把这些东西再带回了，相当的麻烦，所以若是不是特别必要的东西建议写在 local storage 里面 28. 对于页面内容使用无 cookie 域名 当浏览器请求静态图片并把 cookie 一起发送到服务器时，cookie 此时对服务器没什么用处。所以这些 cookie 只是增加了网络流量。所以你应该保证静态组件的请求是没有 cookie 的。可以创建一个子域名来托管所有静态组件。 比如说在页面中请求了一个图片，这个图片的域名需要使用不会记录到 cookie 中的（基本上是说和 cookie 中设置的 domain 域名不一样），这样的话就比较的轻，不会带来带去的了，这个图片使用的域名就是专门存放图片的地方 29. 优化图像 用一些工具把图像压缩 图片的背后是很多的二进制数据来构成的，你可以将一张图片拖进一个编辑器里查看会发现都是 01 组合成的二进制码，这里面会有比如说是哪个软件处理的、处理时间等等一些无用的东西，可以通过压缩来把它们都干掉，我目前在项目中使用的是 TinyPNG 在线压缩，你也可以将它扩展到 PhotoShop 软件中使用 30. 优化 CSS Spirite31. 不要在 HTML 中缩放图像 不要因为你可以设置图片的宽高就去用比你需要的大得多的图片。如果你需要 &lt;img width=\"100\" height=\"100\" src=\"mycat.jpg\" alt=\"My Cat\" /> 那么，就用 100x100px 的图片，而不是 500x500px 的。 32. favicon.ico 要小而且可缓存 favicon.ico 是在你服务器根路径的图片。邪恶的是即使你不关心它，浏览器仍然会请求它。所以最好不要响应 404。另外由于在同一服务器，每次请求 favicon.ico 时也会带上 cookie。这个图片还会影响下载顺序，比如在 IE，如果你在 onload 时下载额外的组件，fcvicon 会在这些组件之前被下载。 怎么减轻 favicon.ico 的缺点？ 小，最好 1K 以下 设置 Expires 头部。也许可以安全地设置为几个月。 33. 保持单个内容小于 25K 这个限制与 iPhone 不缓存大于 25K 的组件相关。注意，这是非压缩（uncompressed）的文件大小。在这里 minification（压缩，不要与 compress 混淆）很重要，因为 gzip 无法满足（iPhone）。 34. 打包组件成复合文本 这个的意思就是建议将 js 和 css 打包到一起，然后再通过其他的一些方法将他们区分开，现在已经有很多前端自动化构建工具可以实现了 比如 webpack","tags":[{"name":"javascript","slug":"javascript","permalink":"http://coder.liusixin.cn/tags/javascript/"},{"name":"性能优化","slug":"性能优化","permalink":"http://coder.liusixin.cn/tags/性能优化/"},{"name":"CSS","slug":"CSS","permalink":"http://coder.liusixin.cn/tags/CSS/"}]},{"title":"JavaScript数据结构与算法总结","date":"2017-07-28T08:38:51.000Z","path":"posts/b56bb73b/","text":"前言 数组 栈 队列 链表 集合 字典 散列表 树 1. 数组创建和初始化数组由于数组太常见了，一些基本的使用就不说明了 求斐波拉契数列前二十个数字 var fibonacci = []; //{1} fibonacci[1] = 1; //{2} fibonacci[2] = 1; //{3} for (var i = 3; i &lt; 20; i++) { fibonacci[i] = fibonacci[i - 1] + fibonacci[i - 2]; ////{4} } for (var i = 1; i &lt; fibonacci.length; i++) { //{5} console.log(fibonacci[i]); //{6} } 添加和删除元素var numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; // 添加元素 // 尾部添加 numbers[numbers.length] = 10; numbers.push(11); numbers.push(12, 13); // 首部添加 numbers.unshift(-2); numbers.unshift(-4, -3); //对应的 你懂得 numbers.pop(); numbers.shift(); // 在数组的任意位置上添加和删除元素 // 使用splice方法，简单地通过指定位置/索引，就可以删除相应位置和数量的元素 numbers.splice(5, 3); // 把数字2、3、4插入数组里 numbers.splice(5, 0, 2, 3, 4); // splice方法接收的第一个参数，表示想要删除或插入的元素的索引值。第二个参数是删除 元素的个数(这个例子里，我们的目的不是删除元素，所以传入0)。第三个参数往后，就是要添 加到数组里的值(元素2、3、4)。输出会发现值又变成了从3到12。 二维数组和多维数组JavaScript只支持一维数组，并不支持矩阵。但是，我们可以像上面的代码一样，用数组套数组，实现矩阵或任一多维数组 function printMatrix(myMatrix) { for (var i = 0; i &lt; myMatrix.length; i++) { for (var j = 0; j &lt; myMatrix[i].length; j++) { console.log(myMatrix[i][j]); } } } 以此类推，也可以用这种方式来处理多维数组。假如我们要创建一个3×3的矩阵，每一格里包含矩阵的i(行)、j(列)及z(深度)之和: var matrix3x3x3 = []; for (var i = 0; i &lt; 3; i++) { matrix3x3x3[i] = []; for (var j = 0; j &lt; 3; j++) { matrix3x3x3[i][j] = []; for (var z = 0; z &lt; 3; z++) { matrix3x3x3[i][j][z] = i + j + z; } } } JavaScript数组方法参考 方法 解释 concat 连接2个或更多数组，并返回结果 every 对数组中的每一项运行给定函数，如果该函数对每一项都返回true，则返回true filter 对数组中的每一项运行给定函数，返回该函数会返回true的项组成的数组 forEach 对数组中的每一项运行给定函数。这个方法没有返回值 join 将所有的数组元素连接成一个字符串 indexOf 返回第一个与给定参数相等的数组元素的索引，没有找到则返回-1 lastIndexOf 返回在数组中搜索到的与给定参数相等的元素的索引里最大的值 map 对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组 reverse 颠倒数组中元素的顺序，原先第一个元素现在变成最后一个，同样原先的最后一个元素变成了现在 的第一个 slice 传入索引值，将数组里对应索引范围内的元素作为新数组返回 some 对数组的每一项运行指定函数，如果有真则为真 sort 按照字母顺序对数组进行排序，支持传入指定排序函数作为参数 toString 将数组作为字符串返回 valueOf 和toString类似，将数组作为字符串返回 迭代器函数JavaScript内置了许多数组可用的迭代方法。对于本节的例子，我们需要数组和函数。假如有 一个数组，它值是从1到15，如果数组里的元素可以被2整除(偶数)，函数就返回true，否则返回false var isEven = function(x) { return (x % 2 === 0 ? true : false); } var numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]; numbers.every(isEven); //数组numbers的第一个元素是1，它不是2的倍数(1是奇数)，因此isEven 函 数返回false，然后every执行结束。 numbers.some(isEven); //numbers数组中第一个偶数是2(第二个元素)。第一个被迭代的元素是1,isEven会返回false。第二个被迭代的元素是2，isEven返回true——迭代结束。 // 如果要迭代整个数组，可以用forEach方法。它和使用for循环的结果相同: numbers.forEach(function(x) { console.log((x % 2 == 0)); }); var myMap = numbers.map(isEven); //[false, true, false, true, false, true, false, true, false, true, false, true, false, true, false] var evenNumbers = numbers.filter(isEven); //[2, 4, 6, 8, 10, 12, 14] numbers.reduce(function(previous, current, index) { return previous + current; }); //120 搜索和排序首先，我们想反序输出数组numbers(它本来的排序是1, 2, 3, 4,…15)。要实现这样的功能， 可以用reverse方法，然后数组内元素就会反序。 numbers.reverse(); 现在，输出numbers的话就会看到[15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1]。然后，我们用sort方法: numbers.sort(function(a, b){ return a-b; }); 对于一些自定义排序可以这么玩 var friends = [{ name: 'John', age: 30 }, { name: 'Ana', age: 20 }, { name: 'Chris', age: 25 } ]; function comparePerson(a, b) { if (a.age &lt; b.age) { return -1 } if (a.age > b.age) { return 1 } return 0; } console.log(friends.sort(comparePerson)); 2. 栈 栈是一种遵从先进后出(LIFO)原则的有序集合。新添加的或待删除的元素都保存在栈的末尾，称作栈顶，另一端就叫栈底。在栈里，新元素都靠近栈顶，旧元素都接近栈底。 而栈主要是在编程语言的编译器里用来保存变量和方法调用等。 创建栈function Stack() { this.dataStore = []; //保存栈内元素 this.top = 0; //标记可以插入新元素的位置 this.push = push; //入栈操作 this.pop = pop; //出栈操作 this.peek = peek; //返回栈顶元素 this.clear = clear; //清空栈 this.length = length; //栈的长度 } //向栈中压入元素 同时让指针top+1 一定注意++ function push(element) { this.dataStore[this.top++] = element; } //出栈操作 同时将top-1 function pop() { return this.dataStore[--this.top]; } //返回栈顶元素，变量top值减1 返回不删除 function peek() { return this.dataStore[this.top - 1]; } //返回栈内元素个数 function length() { return this.top; } //清空一个栈 function clear() { this.top = 0; } 回文算法//回文算法 function isPalindrome(word){ var s = new Stack(); for(var i=0;i&lt;word.length;i++){ s.push(word[i]); } var rword = \"\"; while(s.length()>0){ rword+=s.pop(); } if(rword == word){ return true; }else{ return false } } var word = \"12321\"; console.log(isPalindrome(word)); 3. 队列 队列是遵循先入先出(FIFO)原则的有序的项。队列在尾部添加新元素，并在顶部移除元素。最新添加的元素必须排列在队列的尾部 function Queue(){ this.dataStore = []; this.enqueue = enqueue;//像队尾增加一个元素 this.dequeue = dequeue;//删除队列元素 this.front = front;//读取队首的元素 this.back = back;//读取队尾的元素 this.toString = toString;//显示队列中的所有元素 this.empty = empty;//判断队列是否为空 } function enqueue(element){ this.dataStore.push(element); } function dequeue(){ return this.dataStore.shift(); } function front(){ return this.dataStore[0]; } function back(){ return this.dataStore[this.dataStore.length-1]; } function empty(){ if(this.dataStore.length == 0)return true; else return false; } function toString(){ var reStr = \"\"; for (var i = 0; i &lt; this.dataStore.length; i++) { reStr += this.dataStore[i] + \"\\n\"; } return reStr; } 算法：实现方块舞的舞伴分配问题/* 实现方块舞的舞伴分配问题 */ function Patient(name, code) { this.name = name; this.code = code; } function dequeue() { var priarity = 0; for (var i = 1; i &lt; this.dataStore.length; ++i) { if (this.dataStore[i].code > this.dataStore[priarity].code) { priarity = i; } } return this.dataStore.splice(priarity, 1); } function toString() { var retStr = \"\"; for (var i = 0; i &lt; this.dataStore.length; ++i) { retStr += this.dataStore[i].name + \" code\" + this.dataStore[i].code + \"\\n\"; } return retStr; } var pa = new Patient(\"小王\", 1); var pa1 = new Patient(\"小张\", 4); var pa2 = new Patient(\"小明\", 9); var pa3 = new Patient(\"小红\", 3); var quePatient = new Queue(); quePatient.enqueue(pa); quePatient.enqueue(pa1); quePatient.enqueue(pa2); quePatient.enqueue(pa3); console.log(\"第一个人\" + quePatient.dequeue()); console.log(quePatient.toString()); 3. 链表链表是一种动态的数据结构，这就意味着我们可以从中任意添加和移除元素，他也可以按需扩容。 链表存储有序的元素集合，但不同于数组，链表中的元素在内存中并不是连续放置的。每个元素由一个存储元素本身的节点和一个指向下一个元素的引用(也称指针或链接)组成。 相对于传统的数组，链表的一个好处在于，添加或移除元素的时候不需要移动其他元素。然而，链表需要使用指针，因此实现链表时需要额外注意。数组的另一个细节是可以直接访问任何位置的任何元素，而要想访问链表中间的一个元素，需要从起点(表头)开始迭代列表直到找到所需的元素。 单向链表function Node(element){ this.element = element; this.next = null; } function LList(){ this.head = new Node(\"head\"); this.find = find; this.insert = insert; this.display = display; this.findPrevious = findPrevious; this.remove = remove; } function find(item){ var currNode = this.head; while(currNode.element != item){ currNode = currNode.next; } return currNode; } function insert(newElement, item){ var newNode = new Node(newElement); var currNode = this.find(item); newNode.next = currNode.next; currNode.next = newNode; } function display(){ var currNode = this.head; while(currNode.next != null){ console.log(currNode.next.element); currNode=currNode.next; } } function findPrevious(item){ var currNode = this.head; while ((currNode.next!=null)&amp;&amp;(currNode.next.element!=item)) { currNode = currNode.next; } return currNode; } function remove(item){ var preNode = this.findPrevious(item); var currNode = this.find(item); if(preNode.next!=null){ preNode.next = currNode.next; currNode.next = null; } } var cities = new LList(); cities.insert('first','head'); cities.insert('second','first'); cities.insert('third','second'); cities.display(); console.log(cities.find('third')); console.log(\"=====================\"); // cities.remove('second'); // cities.display(); 双向链表function Node(element,next,pre){ this.element = element; this.next = null; this.pre = null; } function LList(){ this.head = new Node('head'); this.find = find; this.insert = insert; this.display = display; this.remove = remove; this.displReverse = displReverse; this.findLast = findLast; } function find(item){ var currNode = this.head; while (currNode.element != item) { currNode = currNode.next; } return currNode; } function insert(newElement, item){ var newNode = new Node(newElement); var currNode = this.find(item); newNode.next = currNode.next; newNode.pre = currNode; currNode.next = newNode; if(newNode.next == null){ newNode.next.pre = newNode; } } function display(){ var currNode = this.head; while(currNode.next != null){ console.log(currNode.next.element); currNode=currNode.next; } } function remove(item){ var currNode = this.find(item); if(currNode.next != null){ currNode.pre.next = currNode.next; currNode.next.pre = currNode.pre; currNode.next = null; currNode.pre = null; }else{ currNode.pre.next = null; currNode.pre = null; } } function findLast(){ var currNode = this.head; while (!(currNode.next == null)) { currNode = currNode.next; } return currNode; } function displReverse(){ var currNode = this.findLast(); while (!(currNode.pre==null)) { console.log(currNode.element); currNode = currNode.pre; } } try{ var cities = new LList(); cities.insert('first','head'); cities.insert('second','first'); cities.insert('third','second'); cities.remove('second'); cities.display(); cities.displReverse(); }catch(err){ console.log(err); } 4. 集合 集合是由一组无序且唯一(即不能重复)的项组成的。这个数据结构使用了与有限集合相同 的数学概念，但应用在计算机科学的数据结构中。 结合是一种包含不同元素数据结构 在很多编程语言中并不把集合当成一种数据类型，当你想要创建一个数据结构，用来保存一段独一无二的文字的时候集合就非常有用 集合的成员是无序的 集合中不允许相同成员存在 function Set(){ this.dataStore = []; this.add = add; this.remove = remove; this.show = show; this.union = union;//并集 this.intersect = intersect;//交集 this.difference = difference;//补集 this.contains = contains; this.size = size; this.subset = subset; } function add(data){ if(this.dataStore.indexOf(data) &lt; 0){ this.dataStore.push(data); }else{ return false; } } function remove(data){ var pos = this.dataStore.indexOf(data); if(pos > -1){ this.dataStore.splice(pos, 1); }else{ return false; } } function show(){ return this.dataStore; } function union(set){//全集 var tempSet = new Set(); for(var i=0;i&lt;this.dataStore.length;i++){ tempSet.add(this.dataStore[i]); } for(var i=0;i&lt;set.dataStore.length;i++){ if(!tempSet.contains(set.dataStore[i])){ tempSet.add(set.dataStore[i]); } } return tempSet } function contains(data){ if(this.dataStore.indexOf(data)>-1) return true; else return false; } function intersect(set){//交集 var tempSet = new Set(); for(var i=0;i&lt;this.dataStore.length;i++){ if(set.contains(this.dataStore[i])){ tempSet.add(this.dataStore[i]); } } return tempSet; } function difference(set){//补集 var tempSet = new Set(); for(var i=0;i&lt;this.dataStore.length;i++){ if(!set.contains(this.dataStore[i])){ tempSet.add(this.dataStore[i]); } } return tempSet; } function size(){ return this.dataStore.length; } function subset(set){ if(set.size()>this.size()){ return false; }else{ for(var i=0;i&lt;set.dataStore.length;i++){ if(!this.contains(set.dataStore[i])){ return false; } } return true; } } var names = new Set(); names.add(\"小红\"); names.add(\"小丽\"); names.add(\"小张\"); names.add(\"Tom\"); names.add(\"Jack\"); //console.log(names.show()); var cis = new Set(); cis.add('小张'); cis.add('Jack'); cis.add('Tom'); var it = new Set(); it = names.union(cis); console.log(\"并集+++++++\"+it.show()); it = names.intersect(cis); console.log(\"交集+++++++\"+it.show()); it = names.difference(cis); console.log(\"补集+++++++\"+it.show()); console.log(names.subset(cis)); 5. 字典 字典以一种键-值对形式存储 JavaScript的Object类就是以字典的形式设计的。我们要实现一个Dictionary类，这样会比Object方便，比如显示字典中的所有元素，对属性进行排序等 function Dictionary(){ this.dataStore = new Array(); this.add = add; this.find = find; this.count = count; this.clear = clear; this.remove = remove; this.showAll = showAll; } function add(key, value){ this.dataStore[key] = value; } function find(key){ return this.dataStore[key]; } function remove(key){ delete this.dataStore[key]; } function showAll(){ var datakeys = Object.keys(this.dataStore).sort(); for(var keys in datakeys){ console.log(datakeys[keys]+\"-->\"+this.dataStore[datakeys[keys]]); } } function count(){ return Object.keys(this.dataStore).length; } function clear(){ var datakeys = Object.keys(this.dataStore); for(var keys in datakeys){ delete this.dataStore[datakeys[keys]]; } } var pbook = new Dictionary(); pbook.add('e','1'); pbook.add('b','2'); pbook.add('f','3'); pbook.add('d','4'); //console.log(pbook.find('c')); pbook.showAll(); 6. 散列 散列算法的作用是尽可能快地在数据结构中找到一个值。在之前的章节中，你已经知道如果 要在数据结构中获得一个值(使用get方法)，需要遍历整个数据结构来找到它。如果使用散列函数，就知道值的具体位置，因此能够快速检索到该值。散列函数的作用是给定一个键值，然后返回值在表中的地址。 散列后的数据可以快速插入取用 在散列表上插入、删除和取用数据非常快，但是查找数据却效率低下，比如查找一组数据中的最大值和最小值 JavaScript散列表基于数组设计，理想情况散列函数会将每一个键值映射为唯一的数组索引，数组长度有限制，更现实的策略是将键均匀分布 散列关键概念 \b数组长度是预先设定的，可以随时增加，所有元素根据和该元素对应的键，保存数组特定位置 即使使用高效的散列函数，仍然存在两个键值相同的情况，这种现象成为碰撞 对数组的长度应该是一个质数，所有的策略都基于碰撞 开链法：两个键相同保存位置一样。开辟第二数组，也称第二个数组为链 线性探测法属于开放寻址散列，查找散列位置如果当前位置没有继续寻找下一个位置。存储数据较大较适合。数组大小 &gt;= 1.5 数据（开链法），数组大小 &gt;=2 数据（线性探测法 // 线性探测法 function HashTable(){ this.table = new Array(137); this.simpleHash = simpleHash; this.put = put; this.get = get; this.showDistro = showDistro; this.betterHash = betterHash; this.buildChians = buildChians; } function buildChians(){ for(var i=0;i&lt;this.table.length;i++){ this.table[i] = new Array(); } } //除留余数法 function simpleHash(data){ var total = 0; for(var i=0;i&lt;data.length;i++){ total+=data.charCodeAt(i); } return total%this.table.length; } function betterHash(data){ var H = 31; var total = 0; for(var i=0;i&lt;data.length;i++){ total += H * total + data.charCodeAt(i); } if(total&lt;0){ total += this.table.length-1; } return total%this.table.length; } function put(data){ var pos = this.simpleHash(data); if(this.table[pos] == undefined){ this.table[pos] = data; }else{ while(this.table[pos]!=undefined){ pos++; } this.table[pos] = data; } } function get(key){ var hash = this.simpleHash(key); console.info(hash); for(var i=0;i&lt;this.table.length;i++){ if(this.table[i] == key){ return i; } } return undefined; } function showDistro(){ var n = 0; for(var i=0;i&lt;this.table.length;i++){ if(this.table[i]!=undefined){ console.log(\"键值是-》\"+i+\"值是【\"+this.table[i]+\"】\"); } } } function remove(data){ this.table[this.simpleHash[data]] = undefined; } var hTable = new HashTable(); hTable.put(\"china\"); hTable.put(\"japan\"); hTable.put(\"america\"); hTable.put(\"nicha\"); console.log(hTable.get('nicha')); hTable.showDistro(); 8. 树非顺序数据结构我们之前学习的有散列表，现在，我们接着学习另一个非顺序数据结构，树。树是一种分层数据的抽象模型。现实生活中最常见的树的例子是家谱，或是公司的组织架构图 位于树顶部的节点叫做根节点，它没有父节点。节点分为内部节点和外部节点，至少有一个子节点的节点成为内部节点，一个子节点也没有的成为外部节点也叫做叶节点。 一个节点可以有祖先和后代，一个节点(除了根节点)的祖先包括父节点、祖父节点、曾祖 父节点等。一个节点的后代包括子节点、孙子节点、曾孙节点等。 节点的一个属性是深度，节点的深度取决于它的祖先节点的数量。树的高度取决于所有节点深度的最大值。 二叉树和二叉搜索树二叉树中的节点最多只能有两个子节点:一个是左侧子节点，另一个是右侧子节点。这些定 义有助于我们写出更高效的向/从树中插入、查找和删除节点的算法。二叉树在计算机科学中的 应用非常广泛。 二叉搜索树(BST)是二叉树的一种，但是它只允许你在左侧节点存储(比父节点)小的值， 在右侧节点存储(比父节点)大(或者等于)的值。 而我们今天主要研究的就是二叉搜索树 function Node(data, left, right){ this.data = data; this.left = left; this.right = right; this.show = show; } function show(){ return this.data; } function BST(){ this.root = null; this.insert = insert; this.inOrder = inOrder; this.getMin = getMin; this.getMax = getMax; this.find = find; this.remove = remove; } function insert(data){ var n = new Node(data, null, null); if(this.root == null){ this.root = n; }else{ var current = this.root; var parent; while(true){ parent = current; if(data&lt;current.data){ current = current.left; if(current == null){ parent.left = n; break; } }else{ current = current.right; if(current == null){ parent.right = n; break; } } } } } function inOrder(node){ if(!(node == null)){ inOrder(node.left); console.log(node.data); inOrder(node.right); } } function getMin(root){ var current = this.root || root; while(!(current.left == null)){ current = current.left; } return current.data; } function getMax(){ var current = this.root || root; while(!(current.right == null)){ current = current.right; } return current.data; } function find(data){ var current = this.root; while(current != null){ if(current.data == data){ return current; }else if(data &lt; current.data){ current = current.left; }else{ current = current.right; } } return null; } function remove(data){ removeNode(this.root, data); } function removeNode(node, data){ if(node == null){ return null; } if(data == node.data){ if(node.left == null &amp;&amp; node.right == null){ return null } if(node.left == null){ return node.right; } if(node.right == null){ return node.left; } var tempNode = getmin(node.right); node.data = tempNode.data; node.right = removeNode(node.right, tempNode.data); return node; }else if(data&lt;node.data){ node.left = removeNode(node.left, data); return node; }else{ node.right = removeNode(node.right, data); return node; } } var nums = new BST(); nums.insert(23); nums.insert(45); nums.insert(26); nums.insert(47); nums.insert(37); nums.insert(3); nums.insert(101); //console.log(nums.getMin()) nums.remove(3); nums.inOrder(nums.root);","tags":[{"name":"javascript","slug":"javascript","permalink":"http://coder.liusixin.cn/tags/javascript/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://coder.liusixin.cn/tags/数据结构与算法/"}]},{"title":"JavaScript忍者秘籍--函数操作","date":"2017-07-25T07:13:29.000Z","path":"posts/d9b9b5eb/","text":"总结《JavaScript 忍者秘籍》中函数相关的运用 匿名函数匿名函数的介绍不用多说，通常，匿名函数的使用情况是：创建一个供以后使用的函数。 简单的举个例子如下： window.onload = function() { alert('hello'); }; var templateObj = { shout: function() { alert('作为方法的匿名函数'); } }; templateObj.shout(); setTimeout(function() { alert('这也是一个匿名函数'); }, 1000); 递归就是函数自调用，或者调用另外一个函数，但是函数调用树的某一处又重新调用了自己，就产生了递归 普通命名函数的递归拿普通命名函数的递归最好的举例就是用最简单的递归需求：检测回文。 回文的定义：一个字符串，不管从哪一个方向读，结果一样。检测的工作有很多，我们可以创建一个函数，用待检测的回文字符逆序生成出一个字符，然后检测二者是否相同，如果相同，则为回文字符。 但是这种方法需要分配并创建新的字符，还有一种更简洁的方法： 单个和零个字符都是回文 如果字符串的第一个字符和最后一个字符相同，并且除了两个字符以外，别的字符也满足该要求，那么我们就可以检测出来了这个是回文了 function isPalindrome(txt) { if (txt.length &lt;= 1) { return true; } if (txt.charAt(0) != txt.charAt(txt.length - 1)) return false; return isPalindrome(txt.substr(1, txt.length - 2)); } 方法中的递归所谓的方法，自然离不开对象 var fn = { chirp: function(n) { return n > 1 ? fn.chirp(n - 1) + '-chirp' : 'chirp'; } }; console.log(fn.chirp(3)); //chirp-chirp-chirp 在上述代码中，我们通过对象 fn.chirp 方法的递归调用了自己。但是，因为我们在函数上用了非直接引用，也就是 fn 对象的 chirp 属性，所以才能够实现递归，这也就引出来一个问题：引用丢失 引用丢失的问题上面的示例代码，依赖于一个进行递归调用的对象属性引用。与函数的实际名称不同，因为这种引用可能是暂时的。 var fn = { chirp: function(n) { return n > 1 ? fn.chirp(n - 1) + '-chirp' : 'chirp'; } }; var samurai = { chirp: fn.chirp }; fn = {}; try { console.log(samurai.chirp(3) === 'chirp-chirp-chirp'); } catch (err) { if (err) alert(false); } // false 如上，执行结果会弹出 false，因为这时候 samurai.chirp 引用的同样是空对象，这就是引用丢失问题。 通过完善之前对匿名函数的粗略定义，我们可以修复解决这个问题。在匿名函数中，我们不在使用显式的 fn 引用。这里我们使用 this。 var fn = { chirp: function(n) { return n > 1 ? this.chirp(n - 1) + '-chirp' : 'chirp'; } }; 当函数作为方法被调用的时候，函数的上下文指的是该方法的对象。 使用 this 调用，可以让我们的匿名函数更加的强大且灵活。 内联命名函数上面我们解决了作为函数方法为递归时候的一个完美操作。其实这样写也还是有问题的，问题在于给对象定义方法的时候，方法名称是写死的，如果属性名称不一样，也一样会丢失引用。 这里我们采用另一种解决方案，给匿名函数起名 var fn = { chirp: function signal(n) { return n > 1 ? signal(n - 1) + '-chirp' : 'chirp'; } }; var samurai = { chirps: fn.chirp }; fn = {}; try { console.log(samurai.chirps(3) === 'chirp-chirp-chirp'); } catch (err) { if (err) alert(false); } 所以如上的解决办法，就完美解决了我们之前说到所有问题。内联函数还有一个很重要的一点，就是尽管可以给内联函数进行命名，但是这些名称只能在自身函数内部才可见。 将函数视为对象JavaScript 中的函数和其他语言中的函数有所不同，JavaScript 赋予了函数很多的特性，其中最重要的特性之一就是函数作为第一类型对象。 所以，我们可以给函数添加属性，甚至可以添加方法。 函数存储有时候，我们可能需要存储一组相关但又独立的函数，事件回调管理是最为明显的例子。向这个集合添加函数时候，我们得知道哪些函数在集合中存在，否则不添加。 var store = { nextId: 1, cache: {}, add: function(fn) { if (!fn.id) { fn.id = store.nextId++; return !!(store.cache[fn.id] = fn); } } }; function fn() {} console.log(store.add(fn)); // true console.log(store.add(fn)); // undefined 自记忆函数缓存记忆是构造函数的过程，这种函数能够记住先前计算的结果。通过避免重复的计算，极大地提高性能。 缓存记忆昂贵的计算结果 作为一个简单的例子，这里我来判断一个数字是否为素数。 function isPrime(value) { if (!isPrime.answers) isPrime.answers = {}; if (isPrime.answers[value] != null) { return isPrime.answers[value]; } var prime = value != 1; //1 不是素数 for (var i = 2; i &lt; value; i++) { if (value % 2 === 0) { prime = false; break; } } return (isPrime.answers[value] = prime); } console.log(isPrime(5)); // true console.log(isPrime.answers[5]); // true 可以通过下面的isPrime.answers[value]判断出缓存是否成功。 缓存记忆有两个主要的优点： 在函数调用获取之前计算结果的时候，最终用户享有性能优势 发生在幕后，完全无缝，最终用户和开发者都无需任何特殊的操作或者为此做任何初始化工作。 当然，也会有缺点： 为了提高性能，任何类型的缓存肯定会牺牲内存 纯粹主义者可能认为缓存这个问题不应该与业务逻辑放到一起。一个函数或者方法只应该做一件事。 很难测试和测量一个算法的性能。（比如我们这个“简单”的例子） 缓存 DOM 记忆 通过元素标签名来获取 DOM 元素是一个非常常见的操作。但是性能可能不是特别好。所以从上面的缓存记忆我们可以进行如下的操作： function getElements(name) { if (getElements.cache) getElements.cache = {}; return (getElements.cache[name] = getElements.cache[name] || document.getElementsByTagName(name)); } 上面的代码很简单，而且这个简单的缓存的代码产生了 5 倍以上的性能提升。 我们可以将状态和缓存信息存储在一个封装的独立位置上，不仅在代码组织上有好处，而且外部存储或缓存对象无需污染作用域，就可以获取性能的提升。 伪造数组方法有时候我们想创建一个包含一组数据的对象。如果只是集合，则只需要创建一个数组即可。但是在某些情况下，除了集合本身，可能会有更多的状体需要保存。 一种选择是，每次创建对象新版本的时候都创建一个新数组，然后将元数据作为属性或者方法添加到这个新数组上。但是这个操作太常规了。 欣赏如下骚操作： &lt;html> &lt;head>&lt;/head> &lt;body> &lt;input id=\"first\"> &lt;input id=\"second\"> &lt;script> var elems = { length: 0, add: function(elem) { Array.prototype.push.call(this, elem); }, gather: function(id) { this.add(document.getElementById(id)); } } elems.gather('first'); console.log(elems.length, elems[0].nodeType); elems.gather('second'); console.log(elems.length, elems[1].nodeType); &lt;/script> &lt;/body> &lt;/html> 通常，Array.prototype.push()是通过其函数上下文操作其自身数组的。这里我们通过 call 方法通过自己的对象代理了函数的上下文。push 的方法会增加 length 的值（会认为他就是数组的 length 属性），然后给对象添加一个数字属性，并将其引用到传入的元素上。 可变函数的参数列表JavaScript 灵活且强大的特性之一是函数可以接受任意数量的参数。虽然 JavaScript 没有函数的重载，但是参数列表的灵活性是获取其他语言类似重载功能的关键所在 使用apply()支持可变参数需求：查找数组中的最大值、最小值 一开始，我认为 Math 中提供的min(),max()可以满足，但是貌似他并不能够找到数组中的最大值最小值，难道：Math.min(arr[0],arr[1],arr[3]...)?? 别闹了，来看看怎么做 function smallest(arr) { return Math.min.apply(Math, arr); } function largest(arr) { return Math.max.apply(Math, arr); } console.log(smallest([0, 1, 2, 3, 4])); // 0 console.log(largest([0, 1, 2, 3, 4])); // 4 函数重载函数的隐式传递，arguments，也正是因为这个 arguments 的存在，才让函数有能力处理不同数量的参数。即使我们只定义固定数量的形参，通过 arguments 参数我们还是可以访问到实际传给函数的所有的参数。 检测并遍历参数 方法的重载通常是通过在同名的方法里声明不同的实例来达到目的。但是在 javascript 中并非如此，在 javaScript 中，我们重载函数的时候只有一个实现。只不过这个实现内部是通过函数实际传入的参数的特性和个数来达到相应目的的。 function merge(root) { for (var i = 1; i &lt; arguments.length; i++) { for (var key in arguments[i]) { root[key] = arguments[i][key]; } } return root; } var merged = merge( { name: 'Liusixin' }, { age: 26 }, { city: 'Beijing' } ); console.log(merged); 通过如上代码，我们将传递给函数的对象都合并到一个对象中。在 javascript 中，没有强制函数声明多少个参数就得传入多少个参数。函数是否可以成功处理这些参数，完全取决于函数本身的定义。 注意，我们要做的事情是想让第二个或者第 n 个参数上的属性合并到第一个对象中，所以这个遍历是从 1 开始的。 利用参数个数进行函数的重载基于函数的参数，有很多种办法进行函数的重载。一种通用的方法是，根据传入参数的类型执行不同的操作。另一种办法是，可以通过某些特定参数是否存在来进行判断。还有一种是通过传入参数个数来进行判断。 假如对象上有一个方法，根据传入参数的个数来执行不同的操作，冗长且呆呆的函数应该张这样： var fn = { whatever: function() { switch (arguments.length) { case: 0: //do something break; case: 1: //do something break; case: 2: //do something break; case: 3: //do something break; } } } 这种方式，看起来非常的呆呆的。所以我们换一种方式来说下。 如果按照如下思路，添加重载的方法会怎样呢。 var fn = {}; addMethod(fn, 'whatever', function() { /*do something*/ }); addMethod(fn, 'whatever', function(a) { /*do something*/ }); addMethod(fn, 'whatever', function(a, b) { /*do something*/ }); 这里我们使用同样的名称（whatever）将方法添加到该对象上，只不过每个重载的函数是单独的。注意每一个重载的函数参数是不同的。通过这种方式，我们真正为每一个重载都创建了一个独立的匿名函数。漂亮且简洁。 function addMethod(object, name, fn) { var old = object[name]; object[name] = function() { if (fn.length === arguments.length) { return fn.apply(this, arguments); } else if (typeof old == 'function') { return old.apply(this, arguments); } }; } 首先我们保存原有的函数，针对传参个数做处理，避免不匹配。然后创建一个新的匿名函数，如果该匿名函数的形参和实参个数匹配，就调用这个函数，否则调用原来的函数。 这里的fn.length是返回函数定义时候定义的形参个数。 adMethod第一次调用会创建个新的匿名函数进行调用的时候将会调用这个 fn 函数。此时 fn 是一个新的对象，第二次调用addMethod的时候，会将之前的同名函数缓存到变量old中，然后将新创建的匿名函数作为方法。新方法首先检查传入的个数是否为 1，如果是则调用新传入的 fn，如果不是，则调用旧的。重新调用该函数的时候将在此检查参数个数是否为 0。 function addMethod(object, name, fn) { var old = object[name]; object[name] = function() { if (fn.length === arguments.length) { return fn.apply(this, arguments); } else if (typeof old == 'function') { return old.apply(this, arguments); } }; } var fn = { values: ['a', 'b', 'c', 'd'] }; addMethod(fn, 'find', function() { return this.values; }); addMethod(fn, 'find', function(name) { var ret = []; for (var i = 0; i &lt; this.values.length; i++) { if (this.values[i].indexOf(name) === 0) { ret.push(this.values[i]); } } return ret; }); addMethod(fn, 'find', function(first, last) { var ret = []; for (var i = 0; i &lt; this.values.length; i++) { if (this.values[i] == first + ' ' + last) ret.push(this.values[i]); } return ret; }); console.log(fn.find().length); console.log(fn.find('a')); console.log(fn.find('a', 'c')); 然后使用如上的技巧的时候需要注意下面几点： 重载是适用于不同数量的参数，不区分类型、参数名称或者其他东西这样的重载方法会有一些函数调用的开销。我们要考虑在高性能时的情况。","tags":[{"name":"javascript","slug":"javascript","permalink":"http://coder.liusixin.cn/tags/javascript/"}]},{"title":"Generator函数 -> async 函数","date":"2017-07-20T13:22:35.000Z","path":"posts/ea9682c7/","text":"参考链接：阮一峰的网络日志 function* gen(x) { var y = yield x + 2; return y; } var g = gen(1); g.next(); // { value: 3, done: false } g.next(); // { value: undefined, done: true} 上面代码中，调用 Generator 函数，会返回一个内部指针（即遍历器）g 。这是 Generator 函数不同于普通函数的另一个地方，即执行它不会返回结果，返回的是指针对象。调用指针 g 的 next 方法，会移动内部指针（即执行异步任务的第一段），指向第一个遇到的 yield 语句，上例是执行到 x + 2 为止。换言之，next 方法的作用是分阶段执行 Generator 函数。每次调用 next 方法，会返回一个对象，表示当前阶段的信息（ value 属性和 done 属性）。value 属性是 yield 语句后面表达式的值，表示当前阶段的值；done 属性是一个布尔值，表示 Generator 函数是否执行完毕，即是否还有下一个阶段。 参考资料：yield 原理 如下示例代码，在浏览器中打断点可以一窥 yield 执行方法 function* fib2() { yield 0; //状态0，第一次调用next，返回0，并改变状态 yield 1; //状态1，第二次调用next，返回1，并改变状态 var p1 = 0, p2 = 1, cur = p1 + p2; while (true) { yield cur; //状态2，后面调用next，返回相应的几个，状态不在改变 p1 = p2; p2 = cur; cur = p1 + p2; } } var fibIter2 = fib2(); for (var i = 0; i &lt; 8; i++) { console.log(fibIter2.next().value); } 进阶示例 示例 1： function* gen(x) { var y = yield x + 2; return y; } var g = gen(1); console.log(g.next()); // { value: 3, done: false } console.log(g.next()); //{ value: undefined, done: true} console.log(g.next()); // { value: undefined, done: true} 示例 2： //Iterator 遍历 //Generator（生成器）是ES6标准引入的新的数据类型。一个generator看上去像一个函数，但可以返回多次 //1.类似于将异步变成同步，使函数可以按顺序依次执行，用的已经不多了，有新的东西替代了 let chi = function*() { yield '冰淇淋'; yield '汉堡'; }; // console.log(xiaochuan().next());//Object {value: \"冰淇淋\", done: false} const result = chi(); console.log(result.next()); //Object {value: \"冰淇淋\", done: false} console.log(result.next()); //Object {value: \"汉堡\", done: false} console.log(result.next()); //Object {value: undefined, done: true} 总结yield 返回的是一个指针对象 .next() 执行 -&gt; 发现 yeild 语句执行后返回，返回的值便是当时这个阶段 后面表达式的值，直到执行完毕 done:true 为止。 扩展 - async 函数 async 函数的含义和用法（阮一峰的网络日志） Generator 函数，依次读取两个文件。 var fs = require('fs'); var readFile = function(fileName) { return new Promise(function(resolve, reject) { fs.readFile(fileName, function(error, data) { if (error) reject(error); resolve(data); }); }); }; var gen = function*() { var f1 = yield readFile('/etc/fstab'); var f2 = yield readFile('/etc/shells'); console.log(f1.toString()); console.log(f2.toString()); }; 写成 async 函数 var asyncReadFile = async function() { var f1 = await readFile('/etc/fstab'); var f2 = await readFile('/etc/shells'); console.log(f1.toString()); console.log(f2.toString()); };","tags":[{"name":"javascript","slug":"javascript","permalink":"http://coder.liusixin.cn/tags/javascript/"},{"name":"es6","slug":"es6","permalink":"http://coder.liusixin.cn/tags/es6/"}]},{"title":"web项目常见问题汇总及解决方案","date":"2017-07-14T05:15:21.000Z","path":"posts/11633c1a/","text":"meta 基础知识H5 页面窗口自动调整到设备宽度，并禁止用户缩放页面 //一、HTML页面结构 &lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no\" />; // width 设置viewport宽度，为一个正整数，或字符串‘device-width’ // height 设置viewport高度，一般设置了宽度，会自动解析出高度，可以不用设置 // initial-scale 默认缩放比例，为一个数字，可以带小数 // minimum-scale 允许用户最小缩放比例，为一个数字，可以带小数 // maximum-scale 允许用户最大缩放比例，为一个数字，可以带小数 // user-scalable 是否允许手动缩放 //二、JS动态判断 var phoneWidth = parseInt(window.screen.width); var phoneScale = phoneWidth / 640; var ua = navigator.userAgent; if (/Android (\\d+\\.\\d+)/.test(ua)) { var version = parseFloat(RegExp.$1); if (version > 2.3) { document.write( '&lt;meta name=\"viewport\" content=\"width=640, minimum-scale = ' + phoneScale + ', maximum-scale = ' + phoneScale + ', target-densitydpi=device-dpi\">' ); } else { document.write( '&lt;meta name=\"viewport\" content=\"width=640, target-densitydpi=device-dpi\">' ); } } else { document.write( '&lt;meta name=\"viewport\" content=\"width=640, user-scalable=no, target-densitydpi=device-dpi\">' ); } H5 空白页基本 meta 标签 &lt;!-- 设置缩放 --> &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, user-scalable=no, minimal-ui\" /> &lt;!-- 可隐藏地址栏，仅针对IOS的Safari（注：IOS7.0版本以后，safari上已看不到效果） --> &lt;meta name=\"apple-mobile-web-app-capable\" content=\"yes\" /> &lt;!-- 仅针对IOS的Safari顶端状态条的样式（可选default/black/black-translucent ） --> &lt;meta name=\"apple-mobile-web-app-status-bar-style\" content=\"black\" /> &lt;!-- IOS中禁用将数字识别为电话号码/忽略Android平台中对邮箱地址的识别 --> &lt;meta name=\"format-detection\"content=\"telephone=no, email=no\" /> PC 端基础 meta 标签 &lt;!-- 页面关键词--> &lt;meta name=\"keywords\" content=\"your tags\" /> &lt;!-- 页面描述--> &lt;meta name=\"description\" content=\"150 words\" /> &lt;!-- 搜索引擎索引方式：robotterms是一组使用逗号(,)分割的值，通常有如下几种取值：none，noindex，nofollow，all，index和follow。确保正确使用nofollow和noindex属性值。--> &lt;meta name=\"robots\" content=\"index,follow\" /> &lt;!-- all：文件将被检索，且页面上的链接可以被查询； none：文件将不被检索，且页面上的链接不可以被查询； index：文件将被检索； follow：页面上的链接可以被查询； noindex：文件将不被检索； nofollow：页面上的链接不可以被查询。 --> &lt;!-- 页面重定向和刷新：content内的数字代表时间（秒），既多少时间后刷新。如果加url,则会重定向到指定网页（搜索引擎能够自动检测，也很容易被引擎视作误导而受到惩罚）。--> &lt;meta http-equiv=\"refresh\" content=\"0;url=\" /> 页面缓存设置 &lt;!-- 清除缓存 --> &lt;meta http-equiv=\"pragma\" content=\"no-cache\"> &lt;meta http-equiv=\"cache-control\" content=\"no-cache\"> &lt;meta http-equiv=\"expires\" content=\"0\"> 其他 meta 标签 &lt;!-- 启用360浏览器的极速模式(webkit) --> &lt;meta name=\"renderer\" content=\"webkit\"> &lt;!-- 避免IE使用兼容模式 --> &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"> &lt;!-- 针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓 --> &lt;meta name=\"HandheldFriendly\" content=\"true\"> &lt;!-- 微软的老式浏览器 --> &lt;meta name=\"MobileOptimized\" content=\"320\"> &lt;!-- uc强制竖屏 --> &lt;meta name=\"screen-orientation\" content=\"portrait\"> &lt;!-- QQ强制竖屏 --> &lt;meta name=\"x5-orientation\" content=\"portrait\"> &lt;!-- UC强制全屏 --> &lt;meta name=\"full-screen\" content=\"yes\"> &lt;!-- QQ强制全屏 --> &lt;meta name=\"x5-fullscreen\" content=\"true\"> &lt;!-- UC应用模式 --> &lt;meta name=\"browsermode\" content=\"application\"> &lt;!-- QQ应用模式 --> &lt;meta name=\"x5-page-mode\" content=\"app\"> &lt;!-- windows phone 点击无高光 --> &lt;meta name=\"msapplication-tap-highlight\" content=\"no\"> &lt;meta name=\"author\" content=\"author name\" /> &lt;!-- 定义网页作者 --> &lt;meta name=\"google\" content=\"index,follow\" /> &lt;meta name=\"googlebot\" content=\"index,follow\" /> &lt;meta name=\"verify\" content=\"index,follow\" /> 常见问题移动端如何定义字体 font-family @ --------------------------------------中文字体的英文名称 @ 宋体 SimSun @ 黑体 SimHei @ 微信雅黑 Microsoft Yahei @ 微软正黑体 Microsoft JhengHei @ 新宋体 NSimSun @ 新细明体 MingLiU @ 细明体 MingLiU @ 标楷体 DFKai-SB @ 仿宋 FangSong @ 楷体 KaiTi @ 仿宋_GB2312 FangSong_GB2312 @ 楷体_GB2312 KaiTi_GB2312 @ @ 说明：中文字体多数使用宋体、雅黑，英文用Helvetica body { font-family: Microsoft Yahei,SimSun,Helvetica; } 打电话发短信写邮件怎么实现 // 一、打电话 &lt;a href=\"tel:0755-10086\">打电话给:0755-10086&lt;/a> // 二、发短信，winphone系统无效 &lt;a href=\"sms:10086\">发短信给: 10086&lt;/a> // 三、写邮件 //注：在添加这些功能时，第一个功能以\"?\"开头，后面的以\"&amp;\"开头 //1.普通邮件 &lt;a href=\"mailto:863139978@qq.com\">点击我发邮件&lt;/a> //2.收件地址后添加?cc=开头，可添加抄送地址（Android存在兼容问题） &lt;a href=\"mailto:863139978@qq.com?cc=zhangqian0406@yeah.net\">点击我发邮件&lt;/a> //3.跟着抄送地址后，写上&amp;bcc=,可添加密件抄送地址（Android存在兼容问题） &lt;a href=\"mailto:863139978@qq.com?cc=zhangqian0406@yeah.net&amp;bcc=384900096@qq.com\">点击我发邮件&lt;/a> //4.包含多个收件人、抄送、密件抄送人，用分号(;)隔开多个邮件人的地址 &lt;a href=\"mailto:863139978@qq.com;384900096@qq.com\">点击我发邮件&lt;/a> //5.包含主题，用?subject= &lt;a href=\"mailto:863139978@qq.com?subject=邮件主题\">点击我发邮件&lt;/a> //6.包含内容，用?body=;如内容包含文本，使用%0A给文本换行 &lt;a href=\"mailto:863139978@qq.com?body=邮件主题内容%0A腾讯诚信%0A期待您的到来\">点击我发邮件&lt;/a> //7.内容包含链接，含http(s)://等的文本自动转化为链接 &lt;a href=\"mailto:863139978@qq.com?body=http://www.baidu.com\">点击我发邮件&lt;/a> //8.内容包含图片（PC不支持） &lt;a href=\"mailto:863139978@qq.com?body=&lt;img src='images/1.jpg' />\">点击我发邮件&lt;/a> //9.完整示例 &lt;a href=\"mailto:863139978@qq.com;384900096@qq.com?cc=zhangqian0406@yeah.net&amp;bcc=993233461@qq.com&amp;subject=[邮件主题]&amp;body=腾讯诚邀您参与%0A%0Ahttp://www.baidu.com%0A%0A&lt;img src='images/1.jpg' />\">点击我发邮件&lt;/a> 移动端 touch 事件（区分 webkit 和 winphone） /* 当用户手指放在移动设备在屏幕上滑动会触发的touch事件 */ // 以下支持webkit touchstart——当手指触碰屏幕时候发生。不管当前有多少只手指 touchmove——当手指在屏幕上滑动时连续触发。通常我们再滑屏页面，会调用event的preventDefault()可以阻止默认情况的发生：阻止页面滚动 touchend——当手指离开屏幕时触发 touchcancel——系统停止跟踪触摸时候会触发。例如在触摸过程中突然页面alert()一个提示框，此时会触发该事件，这个事件比较少用 //TouchEvent说明： touches：屏幕上所有手指的信息 targetTouches：手指在目标区域的手指信息 changedTouches：最近一次触发该事件的手指信息 touchend时，touches与targetTouches信息会被删除，changedTouches保存的最后一次的信息，最好用于计算手指信息 //参数信息(changedTouches[0]) clientX、clientY在显示区的坐标 target：当前元素 //事件响应顺序 ontouchstart > ontouchmove > ontouchend > onclick // 以下支持winphone 8 MSPointerDown——当手指触碰屏幕时候发生。不管当前有多少只手指 MSPointerMove——当手指在屏幕上滑动时连续触发。通常我们再滑屏页面，会调用css的html{-ms-touch-action: none;}可以阻止默认情况的发生：阻止页面滚动 MSPointerUp——当手指离开屏幕时触发 移动端 click 屏幕产生 200-300ms 的延时响应 //解决方案： fastclick可以解决在手机上点击事件的300ms延迟 zepto的touch模块，tap事件也是为了解决在click的延迟问题 Rentina 显示屏原理及设计方案 说明：retina屏是一种具备超高像素密度的液晶屏，同样大小的屏幕上显示的像素点由1个变为多个，如在同样带下的屏幕上，苹果设备的retina显示屏中，像素点1个变为4个。 在高清显示屏中的位图被放大，图片会变得模糊，因此移动端的视觉稿通常会设计为传统PC的2倍。 那么，前端的应对方案是：设计稿切出来的图片长宽保证为偶数，并使用backgroud-size把图片缩小为原来的1/2 //例如图片宽高为：200px*200px，那么写法如下 .css{width:100px;height:100px;background-size:100px 100px;} //其它元素的取值为原来的1/2，例如视觉稿40px的字体，使用样式的写法为20px .css{font-size:20px} //image-set设计Rentina背景图 image-set,webkit私有属性，也是CSS4的属性，为解决Rentina屏幕下的图像而生。 .css { background: url(images/bg.jpg) no-repeat center; background: -webkit-image-set( url(images/bg.jpg) 1x, //支持image-set普通屏 url(images/bg-2x.jpg) 2x); //支持image-set的Rentinan } 点击元素产生背景或边框怎么去掉 //ios用户点击一个链接，会出现一个半透明灰色遮罩, 如果想要禁用，可设置-webkit-tap-highlight-color的alpha值为0去除灰色半透明遮罩； //android用户点击一个链接，会出现一个边框或者半透明灰色遮罩, 不同生产商定义出来额效果不一样，可设置-webkit-tap-highlight-color的alpha值为0去除部分机器自带的效果； //winphone系统,点击标签产生的灰色半透明背景，能通过设置&lt;meta name=\"msapplication-tap-highlight\" content=\"no\">去掉； //特殊说明：有些机型去除不了，如小米2。对于按钮类还有个办法，不使用a或者input标签，直接用div标签 a,button,input,textarea { -webkit-tap-highlight-color: rgba(0,0,0,0); -webkit-user-modify:read-write-plaintext-only; //-webkit-user-modify有个副作用，就是输入法不再能够输入多个字符 } // 也可以 * { -webkit-tap-highlight-color: rgba(0,0,0,0); } //winphone下 &lt;meta name=\"msapplication-tap-highlight\" content=\"no\"> 美化表单元素 //一、使用appearance改变webkit浏览器的默认外观 input, select { -webkit-appearance: none; appearance: none; } //二、winphone下，使用伪元素改变表单元素默认外观 //1.禁用select默认箭头，::-ms-expand修改表单控件下拉箭头，设置隐藏并使用背景图片来修饰 select::-ms-expand { display: none; } //2.禁用radio和checkbox默认样式，::-ms-check修改表单复选框或单选框默认图标，设置隐藏并使用背景图片来修饰 input[type='radio']::-ms-check, input[type='checkbox']::-ms-check { display: none; } //3.禁用pc端表单输入框默认清除按钮，::-ms-clear修改清除按钮，设置隐藏并使用背景图片来修饰 input[type='text']::-ms-clear, input[type='tel']::-ms-clear, input[type='number']::-ms-clear { display: none; } 移动端字体单位 font-size 选择 px 还是 rem // 如需适配多种移动设备，建议使用rem。以下为参考值： html { font-size: 62.5%; } //10*16 = 62.5% //设置12px字体 这里注意在rem前要加上对应的px值，解决不支持rem的浏览器的兼容问题，做到优雅降级 body { font-size: 12px; font-size: 1.2rem; } 超实用的 CSS 样式 //去掉webkit的滚动条——display: none; //其他参数 ::-webkit-scrollba //滚动条整体部分 ::-webkit-scrollbar-thumb //滚动条内的小方块 ::-webkit-scrollbar-track //滚动条轨道 ::-webkit-scrollbar-button //滚动条轨道两端按钮 ::-webkit-scrollbar-track-piece //滚动条中间部分，内置轨道 ::-webkit-scrollbar-corner //边角，两个滚动条交汇处 ::-webkit-resizer //两个滚动条的交汇处上用于通过拖动调整元素大小的小控件 // 禁止长按链接与图片弹出菜单 a,img { -webkit-touch-callout: none; } // 禁止ios和android用户选中文字 html, body { -webkit-user-select: none; user-select: none; } // 改变输入框placeholder的颜色值 ::-webkit-input-placeholder { /* WebKit browsers */ color: #999; } :-moz-placeholder { /* Mozilla Firefox 4 to 18 */ color: #999; } ::-moz-placeholder { /* Mozilla Firefox 19+ */ color: #999; } :-ms-input-placeholder { /* Internet Explorer 10+ */ color: #999; } input:focus::-webkit-input-placeholder { color: #999; } // android上去掉语音输入按钮 input::-webkit-input-speech-button { display: none; } // 阻止windows Phone的默认触摸事件 /*说明：winphone下默认触摸事件事件使用e.preventDefault是无效的，可通过样式来禁用，如：*/ html { -ms-touch-action: none; } //禁止winphone默认触摸事件 取消 input 在 ios 下，输入的时候英文首字母的默认大写 &lt;input autocapitalize=\"off\" autocorrect=\"off\" /> 手机拍照和上传图片 //IOS有拍照、录像、选取本地图片功能，部分Android只有选择本地图片功能。Winphone不支持 &lt;input type=\"file\" accept=\"images/*\" /> &lt;input type=\"file\" accept=\"video/*\" /> 屏幕旋转的事件和样式 //JS处理 function orientInit(){ var orientChk = document.documentElement.clientWidth > document.documentElement.clientHeight?'landscape':'portrait'; if(orientChk =='lapdscape'){ //这里是横屏下需要执行的事件 }else{ //这里是竖屏下需要执行的事件 } } orientInit(); window.addEventListener('onorientationchange' in window?'orientationchange':'resize', function(){ setTimeout(orientInit, 100); },false) //CSS处理 //竖屏时样式 @media all and (orientation:portrait){ } //横屏时样式 @media all and (orientation:landscape){ } audio 元素和 video 元素在 ios 和 andriod 中无法自动播放 //音频，写法一 &lt;audio src=\"music/bg.mp3\" autoplay loop controls>你的浏览器还不支持哦&lt;/audio> //音频，写法二 &lt;audio controls=\"controls\"> &lt;source src=\"music/bg.ogg\" type=\"audio/ogg\">&lt;/source> &lt;source src=\"music/bg.mp3\" type=\"audio/mpeg\">&lt;/source> 优先播放音乐bg.ogg，不支持在播放bg.mp3 &lt;/audio> //JS绑定自动播放（操作window时，播放音乐） $(window).one('touchstart', function(){ music.play(); }) //微信下兼容处理 document.addEventListener(\"WeixinJSBridgeReady\", function () { music.play(); }, false); //小结 //1.audio元素的autoplay属性在IOS及Android上无法使用，在PC端正常 //2.audio元素没有设置controls时，在IOS及Android会占据空间大小，而在PC端Chrome是不会占据任何空间 重力感应事件 // 运用HTML5的deviceMotion，调用重力感应事件 if (window.DeviceMotionEvent) { document.addEventListener('devicemotion', deviceMotionHandler, false); } var speed = 30; var x = (y = z = lastX = lastY = lastZ = 0); function deviceMotionHandler(eventData) { var acceleration = event.accelerationIncludingGravity; x = acceleration.x; y = acceleration.y; z = acceleration.z; if ( Math.abs(x - lastX) > speed || Math.abs(y - lastY) > speed || Math.abs(z - lastZ) > speed ) { //这里是摇动后要执行的方法 yaoAfter(); } lastX = x; lastY = y; lastZ = z; } function yaoAfter() { //do something } 微信浏览器用户调整字体大小后页面矬了，怎么阻止用户调整 //以下代码可使Android机页面不再受用户字体缩放强制改变大小，但是会有1S左右延时，期间可以考虑loading来处理 if (typeof(WeixinJSBridge) == \"undefined\") { document.addEventListener(\"WeixinJSBridgeReady\", function (e) { setTimeout(function(){ WeixinJSBridge.invoke('setFontSizeCallback', { 'fontSize':0}, function(res){ alert(JSON.stringify(res)); }) }, 0) }); }else{ setTimeout(function(){ WeixinJSBridge.invoke('setFontSizeCallback', { 'fontSize':0}, function(res){ alert(JSON.stringify(res)); }) }, 0) } //IOS下可使用 -webkit-text-size-adjust禁止用户调整字体大小 body { -webkit-text-size-adjust:100%!important; } //最好的解决方案：最好使用rem或百分比布局 定位的坑 //fixed定位 //1.ios下fixed元素容易定位出错，软键盘弹出时，影响fixed元素定位 //2.android下fixed表现要比iOS更好，软键盘弹出时，不会影响fixed元素定位 //3.ios4下不支持position:fixed //解决方案：使用[Iscroll](http://cubiq.org/iscroll-5)，如： &lt;div id=\"wrapper\"> &lt;ul> &lt;li>&lt;/li> ..... &lt;/ul> &lt;/div> &lt;script src=\"iscroll.js\">&lt;/script> &lt;script> var myscroll; function loaded(){ myscroll=new iScroll(\"wrapper\"); } window.addEventListener(\"DOMContentLoaded\",loaded,false); &lt;/script> //position定位 //Android下弹出软键盘弹出时，影响absolute元素定位 //解决方案: var ua = navigator.userAgent.indexOf('Android'); if(ua>-1){ $('.ipt').on('focus', function(){ $('.css').css({'visibility':'hidden'}) }).on('blur', function(){ $('.css').css({'visibility':'visible'}) }) } 播放视频不全屏 &lt;!-- 1.ios7+支持自动播放 2.支持Airplay的设备（如：音箱、Apple TV)播放 x-webkit-airplay=\"true\" 3.播放视频不全屏 webkit-playsinline=\"true\" --> &lt;video x-webkit-airplay=\"true\" webkit-playsinline=\"true\" preload=\"auto\" autoplay src=\"http://\">&lt;/video> JS 判断设备 function deviceType() { var ua = navigator.userAgent; var agent = [ 'Android', 'iPhone', 'SymbianOS', 'Windows Phone', 'iPad', 'iPod' ]; for (var i = 0; i &lt; len, (len = agent.length); i++) { if (ua.indexOf(agent[i]) > 0) { break; } } } deviceType(); window.addEventListener('resize', function() { deviceType(); }); JS 判断微信浏览器 function isWeixin() { var ua = navigator.userAgent.toLowerCase(); if (ua.match(/MicroMessenger/i) == 'micromessenger') { return true; } else { return false; } } android 2.3 bug //1.@-webkit-keyframes 需要以0%开始100%结束，0%的百分号不能去掉 //2.after和before伪类无法使用动画animation //3.border-radius不支持%单位，如要兼容，可以给radius设置一下较大的值 //4.translate百分比的写法和scale在一起会导致失效，例如： -webkit-transform: translate(-50%,-50%) scale(-0.5, 1) android 4.x bug //1.三星 Galaxy S4中自带浏览器不支持border-radius缩写 //2.同时设置border-radius和背景色的时候，背景色会溢出到圆角以外部分 //3.部分手机(如三星)，a链接支持鼠标:visited事件，也就是说链接访问后文字变为紫色 //4.android无法同时播放多音频audio 消除 transition 闪屏 .css { -webkit-transform-style: preserve-3d; -webkit-backface-visibility: hidden; -webkit-perspective: 1000; } 开启硬件加速 //目前，像Chrome/Filefox/Safari/IE9+以及最新版本Opera都支持硬件加速，当检测到某个DOM元素应用了某些CSS规则时就会自动开启，从而解决页面闪白，保证动画流畅。 .css { -webkit-transform: translate3d(0, 0, 0); -moz-transform: translate3d(0, 0, 0); -ms-transform: translate3d(0, 0, 0); transform: translate3d(0, 0, 0); } 渲染优化 //1.禁止使用iframe（阻塞父文档onload事件） //2.禁止使用gif图片实现loading效果（降低CPU消耗，提升渲染性能） //使用CSS3代码代替JS动画； //开启GPU加速； //使用base64位编码图片(不小图而言，大图不建议使用) // 对于一些小图标，可以使用base64位编码，以减少网络请求。但不建议大图使用，比较耗费CPU。小图标优势在于： //1.减少HTTP请求； //2.避免文件跨域； //3.修改及时生效； 腾讯方案 var autoScale = function(){ var ratio = 320/504, //这是设计稿的宽高比（504是Iphone的高度去掉标题栏高度） winW = document.getElement.clientWidth, winH = document.getElement.clientHeight, ratio2 = winW/winH, scale; if(ratio&lt;ratio2){ scale = (winH/504).toString().substring(0, 6); }else{ scale = (winW/320).toString().substring(0, 6); } var cssText = '-webkit-transform: scale('+scale+');-webkit-transform-origin: top; opacity:1;' $('.wrap').attr('style', cssText); } setTimeout(function(){ if(document.documentElement.clientWidth/document.documentElement.clientHeight !== 320/504){ autoScale(); }else{ $('.page').css({'opacity': 1}); } }, 300) //添加一定时长以确保宽高获取正确 window.addEventListener('onorientationchange' in window?'orientationchange':'resize', autoScale, false){ detectOrientatioin(); } //切换横竖屏 function detectOrientatioin(){ if(window.orientation==180 || window.orientation==0){ //竖屏 } if(window.orientation==90 || window.orientation==-90){ //横屏 } }","tags":[{"name":"javascript","slug":"javascript","permalink":"http://coder.liusixin.cn/tags/javascript/"},{"name":"CSS","slug":"CSS","permalink":"http://coder.liusixin.cn/tags/CSS/"}]},{"title":"Express创建web服务器总结","date":"2017-06-20T13:03:50.000Z","path":"posts/7aa0b5e/","text":"Nodejs 搭建 web 站点的一些记录 1. exports 和 module.exportsrequire 用来加载代码，而 exports 和 module.exports 则用来导出代码。 有时候我们可能会迷惑于 exports 和 module.exports 的区别，我们先来巩固下 js 的基础。示例： var a = { name: 1 }; var b = a; console.log(a); console.log(b); b.name = 2; console.log(a); console.log(b); var b = { name: 3 }; console.log(a); console.log(b); // { name: 1 } // { name: 1 } // { name: 2 } // { name: 2 } // { name: 2 } // { name: 3 } a 是一个对象，b 是对 a 的引用，即 a 和 b 指向同一块内存，所以前两个输出一样。当对 b 作修改时，即 a 和 b 指向同一块内存地址的内容发生了改变，所以 a 也会体现出来，所以第三四个输出一样。当 b 被覆盖时，b 指向了一块新的内存，a 还是指向原来的内存，所以最后两个输出不一样。 明白了上述例子后，我们只需知道三点就知道 exports 和 module.exports 的区别了： module.exports 初始值为一个空对象 {} exports 是指向的 module.exports 的引用 require() 返回的是 module.exports 而不是 exports 我们经常看到这样的写法： exports = module.exports = {...} 上面的代码等价于: module.exports = {...} exports = module.exports module.exports 指向新的对象时，exports 断开了与 module.exports 的引用，那么通过 exports = module.exports 让 exports 重新指向 module.exports。 2. promise网上有许多关于 Promise 的资料： https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise （基础） http://liubin.org/promises-book/ （开源 Promise 迷你书） http://fex.baidu.com/blog/2015/07/we-have-a-problem-with-promises/ （进阶） https://promisesaplus.com/ （官方定义规范） Promise 用于异步流程控制，生成器与 yield 也能实现流程控制（基于 co）。async/await 结合 Promise 也可以实现流程控制，有兴趣请查阅 《ECMAScript6 入门》。 2.1 深入 Promise Promise 必知必会（十道题） 深入 Promise(一)——Promise 实现详解 深入 Promise(二)——进击的 Promise 深入 Promise(三)——命名 Promise 3. 环境变量环境变量不属于 Node.js 的知识范畴，只不过我们在开发 Node.js 应用时经常与环境变量打交道，所以这里简单介绍下。 环境变量（environment variables）一般是指在操作系统中用来指定操作系统运行环境的一些参数。在 Mac 和 Linux 的终端直接输入 env，会列出当前的环境变量，如：USER = xxx。简单来讲，环境变量就是传递参数给运行程序的。 在 Node.js 中，我们经常这么用: NODE_ENV = test node app 通过以上命令启动程序，指定当前环境变量 NODE_ENV 的值为 test，那么在 app.js 中可通过 process.env 来获取环境变量: console.log(process.env.NODE_ENV); //test 另一个常见的例子是使用 debug 模块时: DEBUG = * node app Windows 用户需要首先设置环境变量，然后再执行程序： set DEBUG = * set NODE_ENV = test node app 或者使用 cross-env： npm i cross-env -g 使用方式： cross-env NODE_ENV = test node app 4. package.jsonpackage.json 对于 Node.js 应用来说是一个不可或缺的文件，它存储了该 Node.js 应用的名字、版本、描述、作者、入口文件、脚本、版权等等信息。npm 官网有 package.json 每个字段的详细介绍：https://docs.npmjs.com/files/package.json。 4.1 semver语义化版本（semver）即 dependencies、devDependencies 和 peerDependencies 里的如：&quot;co&quot;: &quot;^4.6.0&quot;。 semver 格式：主版本号.次版本号.修订号。版本号递增规则如下： 主版本号：做了不兼容的 API 修改 次版本号：做了向下兼容的功能性新增 修订号：做了向下兼容的 bug 修正 更多阅读： http://semver.org/lang/zh-CN/ http://taobaofed.org/blog/2016/08/04/instructions-of-semver/ 作为 Node.js 的开发者，我们在发布 npm 模块的时候一定要遵守语义化版本的命名规则，即：有 breaking change 发大版本，有新增的功能发小版本，有小的 bug 修复或优化则发修订版本。 5. Npm 使用注意事项5.1 npm init使用 npm init 初始化一个空项目是一个好的习惯，即使你对 package.json 及其他属性非常熟悉，npm init 也是你开始写新的 Node.js 应用或模块的一个快捷的办法。npm init 有智能的默认选项，比如从根目录名称推断模块名称，通过 ~/.npmrc 读取你的信息，用你的 Git 设置来确定 repository 等等。 5.2 npm installnpm install 是我们最常用的 npm 命令之一，因此我们需要好好了解下这个命令。终端输入 npm install -h 查看使用方式: 小提示: npm i 是 npm install 的简写，建议使用 npm i。 直接使用 npm i 安装的模块是不会写入 package.json 的 dependencies (或 devDependencies)，需要额外加个参数: npm i express --save/npm i express -S (安装 express，同时将 &quot;express&quot;: &quot;^4.14.0&quot; 写入 dependencies ) npm i express --save-dev/npm i express -D (安装 express，同时将 &quot;express&quot;: &quot;^4.14.0&quot; 写入 devDependencies ) npm i express --save --save-exact (安装 express，同时将 &quot;express&quot;: &quot;4.14.0&quot; 写入 dependencies ) 第三种方式将固定版本号写入 dependencies，建议线上的 Node.js 应用都采取这种锁定版本号的方式，因为你不可能保证第三方模块下个小版本是没有验证 bug 的，即使是很流行的模块。 后面会介绍更安全的 npm shrinkwrap 的用法。 运行以下命令： npm config set save-exact true 这样每次 npm i xxx --save 的时候会锁定依赖的版本号，相当于加了 --save-exact 参数。 小提示：npm config set 命令将配置写到了 ~/.npmrc 文件，运行 npm config list 查看。 5.3 npm scriptsnpm 提供了灵活而强大的 scripts 功能，见 官方文档。 npm 的 scripts 有一些内置的缩写命令，如常用的： npm start 等价于 npm run start npm test 等价于 npm run test 5.4 npm shrinkwrap前面说过要锁定依赖的版本，但这并不能完全防止意外情况的发生，因为锁定的只是最外一层的依赖，而里层依赖的模块的 package.json 有可能写的是 &quot;mongoose&quot;: &quot;*&quot;。为了彻底锁定依赖的版本，让你的应用在任何机器上安装的都是同样版本的模块（不管嵌套多少层），通过运行 npm shrinkwrap，会在当前目录下产生一个 npm-shrinkwrap.json，里面包含了通过 node_modules 计算出的模块的依赖树及版本。只要目录下有 npm-shrinkwrap.json 则运行 npm install 的时候会优先使用 npm-shrinkwrap.json 进行安装，没有则使用 package.json 进行安装。 更多阅读： https://docs.npmjs.com/cli/shrinkwrap http://tech.meituan.com/npm-shrinkwrap.html 注意: 如果 node_modules 下存在某个模块（如直接通过 npm install xxx 安装的）而 package.json 中没有，运行 npm shrinkwrap 则会报错。另外，npm shrinkwrap 只会生成 dependencies 的依赖，不会生成 devDependencies 的。 6. 初始化一个 Express 项目首先，我们新建一个目录 myblog，在该目录下运行 npm init -y 生成一个 package.json，如下所示： 然后安装 express 并写入 package.json： npm i express@4.14.0 --save 新建 index.js，添加如下代码： const express = require('express'); const app = express(); app.get('/', function(req, res) { res.send('hello, express'); }); app.listen(3000, function() { console.log('server is starting at port:3000'); }); 以上代码的意思是：生成一个 express 实例 app，挂载了一个根路由控制器，然后监听 3000 端口并启动程序。运行 node index，打开浏览器访问 localhost:3000 时，页面应显示 hello, express。 这是最简单的一个使用 express 的例子，后面会介绍路由及模板的使用。 6.1 supervisor在开发过程中，每次修改代码保存后，我们都需要手动重启程序，才能查看改动的效果。使用 supervisor 可以解决这个繁琐的问题，全局安装 supervisor： npm i -g supervisor 运行 supervisor index 启动程序，supervisor 会监听当前目录下 node 和 js 后缀的文件，当这些文件发生改动时，supervisor 会自动重启程序。 7. 路由前面我们只是挂载了根路径的路由控制器，现在修改 index.js 如下： const express = require('express'); const app = express(); app.get('/', function(req, res) { res.send('hello, express'); }); app.get('/users/:name', function(req, res) { res.send('hello, ' + req.params.name); }); app.listen(3000, function() { console.log('server is starting at port:3000'); }); 以上代码的意思是：当访问根路径时，依然返回 hello, express，当访问如 localhost:3000/users/liusixin 路径时，返回 hello, liusixin。路径中 :name 起了占位符的作用，这个占位符的名字是 name，可以通过 req.params.name 取到实际的值。 小提示：express 使用了 path-to-regexp 模块实现的路由匹配。 不难看出：req 包含了请求来的相关信息，res 则用来返回该请求的响应，更多请查阅 express 官方文档。下面介绍几个常用的 req 的属性： req.query: 解析后的 url 中的 querystring，如 ?name=haha，req.query 的值为 {name: &#39;haha&#39;} req.params: 解析 url 中的占位符，如 /:name，访问 /haha，req.params 的值为 {name: &#39;haha&#39;} req.body: 解析后请求体，需使用相关的模块，如 body-parser，请求体为 {&quot;name&quot;: &quot;haha&quot;}，则 req.body 为 {name: &#39;haha&#39;} 7.1 express.Router上面只是很简单的路由使用的例子（将所有路由控制函数都放到了 index.js），但在实际开发中通常有几十甚至上百的路由，都写在 index.js 既臃肿又不好维护，这时可以使用 express.Router 实现更优雅的路由解决方案。在 myblog 目录下创建空文件夹 routes，在 routes 目录下创建 index.js 和 users.js。最后代码如下： index.js const express = require('express'); const app = express(); const indexRouter = require('./routes/index'); const userRouter = require('./routes/users'); app.use('/', indexRouter); app.use('/users', userRouter); app.listen(3000, function() { console.log('server is starting at port:3000'); }); routes/index.js const express = require('express'); const router = express.Router(); router.get('/', function(req, res) { res.send('hello, express'); }); module.exports = router; routes/users.js const express = require('express'); const router = express.Router(); router.get('/:name', function(req, res) { res.send('hello, ' + req.params.name); }); module.exports = router; 以上代码的意思是：我们将 / 和 /users/:name 的路由分别放到了 routes/index.js 和 routes/users.js 中，每个路由文件通过生成一个 express.Router 实例 router 并导出，通过 app.use 挂载到不同的路径。这两种代码实现了相同的功能，但在实际开发中推荐使用 express.Router 将不同的路由分离到不同的路由文件中。 更多 express.Router 的用法见 express 官方文档。 8. 模板引擎模板引擎（Template Engine）是一个将页面模板和数据结合起来生成 html 的工具。上例中，我们只是返回纯文本给浏览器，现在我们修改代码返回一个 html 页面给浏览器。 8.1 ejs模板引擎有很多，ejs 是其中一种，因为它使用起来十分简单，而且与 express 集成良好，所以我们使用 ejs。安装 ejs： npm i ejs --save 修改 index.js 如下： index.js const path = require('path'); const express = require('express'); const app = express(); const indexRouter = require('./routes/index'); const userRouter = require('./routes/users'); app.set('views', path.join(__dirname, 'views')); // 设置存放模板文件的目录 app.set('view engine', 'ejs'); // 设置模板引擎为 ejs app.use('/', indexRouter); app.use('/users', userRouter); app.listen(3000, function() { console.log('server is starting at port:3000'); }); 通过 app.set 设置模板引擎为 ejs 和存放模板的目录。在 myblog 下新建 views 文件夹，在 views 下新建 users.ejs，添加如下代码： views/users.ejs &lt;!DOCTYPE html> &lt;html> &lt;head> &lt;style type=\"text/css\"> body {padding: 50px;font: 14px \"Lucida Grande\", Helvetica, Arial, sans-serif;} &lt;/style> &lt;/head> &lt;body> &lt;h1>&lt;%= name.toUpperCase() %>&lt;/h1> &lt;p>hello, &lt;%= name %>&lt;/p> &lt;/body> &lt;/html> 修改 routes/users.js 如下： routes/users.js const express = require('express'); const router = express.Router(); router.get('/:name', function(req, res) { res.render('users', { name: req.params.name }); }); module.exports = router; 通过调用 res.render 函数渲染 ejs 模板，res.render 第一个参数是模板的名字，这里是 users 则会匹配 views/users.ejs，第二个参数是传给模板的数据，这里传入 name，则在 ejs 模板中可使用 name。res.render 的作用就是将模板和数据结合生成 html，同时设置响应头中的 Content-Type: text/html，告诉浏览器我返回的是 html，不是纯文本，要按 html 展示。现在我们访问 localhost:3000/users/haha，如下图所示： 上面代码可以看到，我们在模板 &lt;%= name.toUpperCase() %&gt; 中使用了 JavaScript 的语法 .toUpperCase() 将名字转化为大写，那这个 &lt;%= xxx %&gt; 是什么东西呢？ejs 有 3 种常用标签： &lt;% code %&gt;：运行 JavaScript 代码，不输出 &lt;%= code %&gt;：显示转义后的 HTML 内容 &lt;%- code %&gt;：显示原始 HTML 内容 注意：&lt;%= code %&gt; 和 &lt;%- code %&gt; 都可以是 JavaScript 表达式生成的字符串，当变量 code 为普通字符串时，两者没有区别。当 code 比如为 &lt;h1&gt;hello&lt;/h1&gt; 这种字符串时，&lt;%= code %&gt; 会原样输出 &lt;h1&gt;hello&lt;/h1&gt;，而 &lt;%- code %&gt; 则会显示 H1 大的 hello 字符串。 下面的例子解释了 &lt;% code %&gt; 的用法： Data supplies: ['mop', 'broom', 'duster']; Template &lt;li>mop&lt;/li> &lt;li>broom&lt;/li> &lt;li>duster&lt;/li> &lt;/ul> 更多 ejs 的标签请看 官方文档。 8.2 includes我们使用模板引擎通常不是一个页面对应一个模板，这样就失去了模板的优势，而是把模板拆成可复用的模板片段组合使用，如在 views 下新建 header.ejs 和 footer.ejs，并修改 users.ejs： views/header.ejs body {padding: 50px;font: 14px \"Lucida Grande\", Helvetica, Arial, sans-serif;} views/footer.ejs views/users.ejs hello, 我们将原来的 users.ejs 拆成出了 header.ejs 和 footer.ejs，并在 users.ejs 通过 ejs 内置的 include 方法引入，从而实现了跟以前一个模板文件相同的功能。 拆分模板组件通常有两个好处： 模板可复用，减少重复代码 主模板结构清晰 注意：要用 &lt;%- include(&#39;header&#39;) %&gt; 而不是 &lt;%= include(&#39;header&#39;) %&gt; 9. Express 浅析express 的精髓在于中间件机制。 9.1 中间件与 nextexpress 中的中间件（middleware）就是用来处理请求的，当一个中间件处理完，可以通过调用 next() 传递给下一个中间件，如果没有调用 next()，则请求不会往下传递，如内置的 res.render 其实就是渲染完 html 直接返回给客户端，没有调用 next()，从而没有传递给下一个中间件。看个小例子，修改 index.js 如下： index.js const express = require('express'); const app = express(); app.use(function(req, res, next) { console.log('1'); next(); }); app.use(function(req, res, next) { console.log('2'); res.status(200).end(); }); app.listen(3000, function() { console.log('server is starting at port:3000'); }); 此时访问 localhost:3000，终端会输出： 1; 2; 通过 app.use 加载中间件，在中间件中通过 next 将请求传递到下一个中间件，next 可接受一个参数接收错误信息，如果使用了 next(error)，则会返回错误而不会传递到下一个中间件，修改 index.js 如下： index.js const express = require('express'); const app = express(); app.use(function(req, res, next) { console.log('1'); next(new Error('error')); }); app.use(function(req, res, next) { console.log('2'); res.status(200).end(); }); app.listen(3000, function() { console.log('server is starting at port:3000'); }); 此时访问 localhost:3000，终端会输出错误信息。 小提示：app.use 有非常灵活的使用方式，详情见 官方文档。 express 有成百上千的第三方中间件，在开发过程中我们首先应该去 npm 上寻找是否有类似实现的中间件，尽量避免造轮子，节省开发时间。下面给出几个常用的搜索 npm 模块的网站： http://npmjs.com(npm 官网) http://node-modules.com https://npms.io https://nodejsmodules.org express@4 之前的版本基于 connect 这个模块实现的中间件的架构，express@4 及以上的版本则移除了对 connect 的依赖自己实现了，理论上基于 connect 的中间件（通常以 connect- 开头，如 connect-mongo）仍可结合 express 使用。 注意：中间件的加载顺序很重要！比如：通常把日志中间件放到比较靠前的位置，后面将会介绍的 connect-flash 中间件是基于 session 的，所以需要在 express-session 后加载。 9.2 错误处理上面的例子中，应用程序为我们自动返回了错误栈信息（express 内置了一个默认的错误处理器），假如我们想手动控制返回的错误内容，则需要加载一个自定义错误处理的中间件，修改 index.js 如下： index.js const express = require('express'); const app = express(); app.use(function(req, res, next) { console.log('1'); next(new Error('liusixin')); }); app.use(function(req, res, next) { console.log('2'); res.status(200).end(); }); //错误处理 app.use(function(err, req, res, next) { console.error(err.stack); res.status(500).send('Something broke!'); }); app.listen(3000, function() { console.log('server is starting at port:3000'); }); 此时访问 localhost:3000，浏览器会显示 Something broke!。 关于 express 的错误处理，详情见 官方文档。","tags":[{"name":"javascript","slug":"javascript","permalink":"http://coder.liusixin.cn/tags/javascript/"},{"name":"Express","slug":"Express","permalink":"http://coder.liusixin.cn/tags/Express/"},{"name":"Nodejs","slug":"Nodejs","permalink":"http://coder.liusixin.cn/tags/Nodejs/"}]},{"title":"浅谈前端数据推送","date":"2017-06-06T06:13:47.000Z","path":"posts/b0b31bc4/","text":"概述 comet websocket sse 1. comet之前参与项目里，见到过有人用 ajax 长轮询来做实时数据推送。但是这样做有一个弊端就是会建立很多 TCP 连接，这样会给系统带来比较大的 IO 负担。 有没有一种方式，我们只进行一次 TCP 连接，在这一次 TCP 连接中，服务器不断给客户端吐数据。下面我们就来介绍一下 comet 推送方式： 我们用 php 来做服务端 &lt;?php header(\"Content-type:appliacation/json;charset=utf-8\"); header(\"Cache-Control:max-age=0\"); // 让前端接收没有缓冲，因为我们要实时获取数据 // 我们用一种方式，让它连上之后不释放 $i=0; while($i&lt;9){ $i++; $radom = rand(1,999); sleep(1); echo $radom; echo \"&lt;br>\"; ob_flush(); // 把当前资源释放掉 flush(); // 拿到释放掉的资源，吐浏览器 // 一直让它输出，而且是一个流式输出 } ?> js 怎样捕捉一直在发送阶段 &lt;script> var getXmlHttpRequest = function(){ if(window.XMLHttpRequest){ return new XMLHttpRequest(); } else if(window.ActiveXObject){ return new ActiveXObject(\"Microsoft.XMLHTTP\"); } } var xhr = getXmlHttpRequest(); xhr.onreadystatechange = function (){ console.log(xhr.readyState); // 检测readyState为3的时候，我们就能把responseText输出出来 // 而且每次一都能把上次全部内容都打印出来 if(xhr.readyState ===3 &amp;&amp;xhr.status === 200){ console.log(xhr.responseText); } } xhr.open(\"get\",\"data.php\",true); xhr.send(\"\"); &lt;/script> js 用普通 ajax 去请求 &lt;script> function conn(){ $.ajax({ url: 'data.php', dataType: 'json', success: function(data){ console.log(data); conn(); } }) } conn(); &lt;/script> 服务端我们不去断掉连接 &lt;?php header(\"Content-type:appliacation/json;charset=utf-8\"); header(\"Cache-Control:max-age=0\"); sleep(1); $res = array('success'=>'ok','test'=>'我是测试文本'); echo json_encode($res); ?> 或者我们用下面这种方式，用一个 while 循环，我们可以通过前端给来的参数去判断执行过少次。 &lt;?php header(\"Content-type:appliacation/json;charset=utf-8\"); header(\"Cache-Control:max-age=0\"); while(true){ sleep(1); $res = array('success'=>'ok','test'=>'我是测试文本'); echo json_encode($res); exit(); // 切记要退出，不然前端拿不到数据 } ?> 因为只要不断掉，我们再去请求还是连接的上一次请求，只不过这是用前端实现了轮询效果，刚才我们用后端 flush()来实现的这件事 2. websocketwebsocket 它是一种长连接，通过 websocket 我们能实现后端向前端推送数据，前端也可以向后端推送数据。这里我们主要讲前端 H5 websocket 怎样和 nodejs 配合。 为什么要用到 socket.io 呢？ 因为它承载了 socket 大部分功能，而且相对稳定 服务器端 第一步我们建一个 express 项目 $ npm install express --save $ npm install -g express-generator express 第二步我们要在项目文件里安装 socket.io $ npm install socket.io --save 第三步我们在 node_module 里面找到 socket.io.js 这个文件，这是给前端用的 文件在 node_modules/socket.io-client/dist/socket.io.js 接下来我们在 app.js 中引入 socket.io var express = require('express'); var path = require('path'); var app = express(); var http = require('http'); var server = http.createServer(app); var io = require('socket.io').listen(server); app.set('port', 3000); // view engine setup app.set('views', path.join(__dirname, 'views')); app.set('view engine', 'jade'); app.use(express.static(path.join(__dirname, 'public'))); io.on('connection', function(socket) { socket.emit('open'); // 通知客户端已连接 // 对message事件的监听 socket.on('message', function(msg) { console.log('this is msg:', msg); socket.emit('test', 'server ready'); }); // 监听退出事件 socket.on('disconnect', function() {}); }) app.get('/', function(req, res) { res.sendfile('views/index.html'); }); server.listen(app.get('port'), function() { console.log(\"socket server listen\" + app.get('port')); }); 在 views 文件夹里建 index.html &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>Document&lt;/title> &lt;/head> &lt;body> hello &lt;script src=\"javascripts/socket.io.js\">&lt;/script> &lt;script src=\"javascripts/main.js\">&lt;/script> &lt;/body> &lt;/html> 在静态文件 javascripts 文件夹下建 main.js (function() { var i = 0; // 建立websocket连接 var socket = io.connect(\"http://localhost:3000\"); // 收到server的连接确认 socket.on('open', function() { console.log('已连接'); socket.send(\"ok\"); }) socket.on('test', function(json) { console.log('test', json); }) })(); 具体步骤： 在 app.js 文件中用 socket.io 监听 server 端口 在 main.js 文件中建立 websocket 连接 app.js 会在 connect 事件中监听到连接，并触发 open（自己定义的）事件 此时前端监听到 open 事件 同时前端也可以用 socket 连接用 send 方法向后端推送消息 后端会在 message 事件中监听到前端推送过来的消息 参考资料：socket.io 官网 api 3. sse Server-Sent Events(简称 SSE) SSE 是一种能让浏览器通过 http 连接自动收到服务器端更新的技术，SSE EventSource 接口被 W3C 制定为 HTML5 的一部分。 它是能完成服务器端向客户端单向推送消息，但是 IE 不支持 服务器端 php 代码 &lt;?php // 以event-steam的方式输出 header(\"Content-Type:text/event-stream;charset='utf-8'\"); // 指定哪个域来访问 header(\"Access-Control-Allow-Origin:http://127.0.0.1/\"); echo \"data:现在北京时间是\".date('H:i:s').\"\\r\\n\\r\\n\"; ?> html 代码 &lt;script> var source; function init(argument) { source = new EventSource('http://localhost/sse/data.php'); // 建立连接 source.onopen = function() { console.log('连接已建立', this.readyState) } // 后端实时推送的数据 source.onmessage = function(event) { console.log('从服务器实时获取的数据', event.data); } // 出错的监听 source.onerror = function() { } } init(); &lt;/script> 这里主要是 new 一个 EventSource 实例，然后监听 onopen 事件，这个事件是监听连接已建立，然后通过 onmessage 事件来监听后端推送过来的消息。","tags":[{"name":"数据推送","slug":"数据推送","permalink":"http://coder.liusixin.cn/tags/数据推送/"},{"name":"HTML5","slug":"HTML5","permalink":"http://coder.liusixin.cn/tags/HTML5/"}]},{"title":"前端调试技巧--Audits 和 Chrome 性能插件","date":"2017-05-27T15:45:46.000Z","path":"posts/c588c1ac/","text":"Audits 和 Chrome 性能插件Audits Audits 其实就是分析当前网页的性能的，比如说雅虎军规，这个东西能够大致给我们分析出来一些我们做的不好的地方而且能给我们一些解决意见 雅虎军规参考网址：https://github.com/creeperyang/blog/issues/1 Audits 面板 performanceTracer – Chrome 插件 Page Speed – Chrome 插件 performance.timming 这是代码形式的一个 API ，是谷歌提供给我们的在浏览器里面我们可以通过网页去检测的。 上面这个插件光学是没什么用的，得需要先了解浏览器的整个的执行机制，下图就是 整个的一个网页从我们用户输入到输出的时候这之间经过的很多的过程，上面的 performance.timing 很好的捕捉到了这样的一个节点，这个节点里面我们主要观察的是 DNS 这一阶段，就是查找 DNS 之间，然后是 握手的时间，请求的时间，输出的时间，还有就是 onload 的时间，那么中间隔着的 DNS TCP Request Response 这几个时间是需要我们非常非常关注的，如果我们是专注于性能开发的，这几个点做的非常漂亮，那么这样整个一个网页的性能是非常高的，所以做网页性能的时候这几个点一定要卡住。 接着上一篇中的案例进行讲解，在右侧的开发者工具中找到 Audits 面板，之后就可以让他来帮我们分析一下，接下来点击下面的 【RUN】 按钮 如果说想要漂亮一点的就可以下载一个 performanceTracer 这样的一个东西，它可以将 我们上面说到的 timing 的 API 也就是上面的 【浏览器的整个的执行机制图】 里面的东西。 但是如果作为一个专业的性能开发人员来讲的话 performanceTracer 是远远不够我们进行网页加载时的性能监测用的，所以一般会装一个东西叫做 Page Speed，它可以是浏览器加载的更快（Make the web faster） 下载完后点击面板下面显示的 【START ANALYZING】（开始分析） 按钮，它就会自动的去分析你当前的网页，下图是分析之后自动的将结果给呈现了出来 它连怎么优化都帮你做到或者是提示了。 如果是上面的插件还不够用的话，这个时候就需要借助一个东西 performance.timing 这个是浏览器自带的 API 可以在控制台中直接输出，可以看到所有的值都在下面列出来了","tags":[{"name":"性能优化","slug":"性能优化","permalink":"http://coder.liusixin.cn/tags/性能优化/"},{"name":"调试","slug":"调试","permalink":"http://coder.liusixin.cn/tags/调试/"}]},{"title":"前端调试技巧--断点以及捕捉事件绑定","date":"2017-05-27T14:36:46.000Z","path":"posts/eff2d234/","text":"概要 断点以及捕捉事件绑定 Audits 和 Chrome 性能插件 Timeline 掌握帧渲染模式 可以看到整个的 webkit 在渲染整个层或者是每一帧的时候是如何使我们的网页达到 60FPS 这样高性能渲染模式的 Profiles 分析具体问题 包括 NodeJS 的性能泄露等等，NodeJS 的性能问题有内存泄露这样的问题，都可以通过 Profiles 这个来解决掉 1. 断点以及捕捉事件绑定这里用一个 demo 文件来演示上面的所有东西，新建一个 index.html 并编辑如下： &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>Chrome 高级调试技巧&lt;/title> &lt;link href=\"https://cdn.bootcss.com/bootstrap/4.0.0-beta.2/css/bootstrap.css\" rel=\"stylesheet\"> &lt;script src=\"https://cdn.bootcss.com/jquery/3.2.1/jquery.js\">&lt;/script> &lt;script type=\"text/javascript\" src=\"index.js\">&lt;/script> &lt;style type=\"text/css\"> body{ padding: 15px; } #test-div{ width: 100px; height: 20px; background-color: #eee; border: 1px solid #333; top: 30px; left: 200px; text-align: center; cursor: default; } &lt;/style> &lt;/head> &lt;body> &lt;label for=\"exampleInputEmail\">Email address&lt;/label> &lt;input type=\"email\" class=\"form-control\" id=\"exampleInput\" placeholder=\"Email\"> &lt;button type=\"button\" style=\"margin-top: 5px;\" id=\"btn-test\" class=\"btn btn-success\">测试成功&lt;/button> &lt;div id=\"test-div\">一段文字&lt;/div> &lt;/body> &lt;script> $('#btn-test').click(function(){ alert($('#exampleInput').val()); // $('#test-div').hide(); }) &lt;/script> &lt;/html> 这里把文件放入 xampp 中并开启服务，在谷歌浏览器中输入 localhost/debugtest/ 打开页面，在 input 中输入内容并点击 【测试成功】按钮，显示如下证明一切正常 断点在开发者工具中，找到 Sources（资源） -&gt; 在找到 localhost -&gt; debugtest -&gt; index.html，在右侧的文本文件中用鼠标在 33 行的前面点击一下这个就是打上断点了 之后再点击左侧的【测试成功】按钮，代码在运行到上面的 33 行处就会暂停了，点击下面被红色圆圈圈中的就可以一步一步的向下调试，它的右侧是一步一步的向上调试，它的左侧的是可以跳出当前的 function 可以进入到下一个 function 里面进行调试 点击上图中的向下调试按钮，它会进入到 alert 里面的 $(&#39;#exampleInput&#39;).val() 进入到 jquery 中去找这个里面的值这样的执行函数中去了 点击到了最后，没有执行的函数之后，结果就弹出来了 如果说不想调试的这么多，在页面刚开始运行到断点的时候，直接点第二个按钮就跳出整个函数了 寻找事件监听接下来是找到当前元素所绑定的事件 在我在【测试成功】按钮上使用鼠标右键选中【检查】选项的时候，可以在右侧找到 【Event Listeners】选项，在下面可以看到，在元素上绑定了一个 click 事件 后面的地址点击之后就可以直接跳转到事件绑定的源代码了 DOM 元素断点接着将 index.html 中的 34 行 解注释 现在再在浏览器中先将之前的断点去掉，方法跟打断点是一样的，之后刷新浏览器，整个的执行时这样的 先输入内容 -&gt; 点击【测试成功】按钮 之后会发现 下面的 test-div 元素就隐藏了，这是一个相当简单的 jquery 实现的效果 下面我们想要的是当 test-div 元素被改变时可以被监控到给出提示，这里我们在下图选的元素位置 鼠标右键 选择 -&gt; Break on -&gt; 再选择 Node removal ，选中之后它会在这个 dom 元素的前面打一个小蓝点 这个时候再刷新浏览器，执行一遍之前的流程操作，会发现 test-div 元素也隐藏了，效果上来说和之前的没什么变化 如果将 $(&#39;#test-div&#39;).hide() 改成 $(&#39;#test-div&#39;).remove() 之后再次刷新页面进行操作的时候可以看到他是直接定位到了 jquery 中给元素执行 remove 时 function 的节点范围 上面的是 Node removal DOM 元素被删除时会查看，还可以选择 Subtree modifications DOM 元素被修改时或者 Attributes modifications DOM 元素属性的变化","tags":[{"name":"性能优化","slug":"性能优化","permalink":"http://coder.liusixin.cn/tags/性能优化/"},{"name":"调试","slug":"调试","permalink":"http://coder.liusixin.cn/tags/调试/"}]},{"title":"css 居中方式总结","date":"2017-05-22T05:30:33.000Z","path":"posts/92c6d8de/","text":"1 水平居中内联元素水平居中 .center-inline { text-align: center; } 块级元素水平居中 .center-block { margin: 0 auto; } 多块级元素水平居中 .container { text-align: center; } .inline-block { display: inline-block; } 弹性盒子模型 flex .flex-center { display: flex; justify-content: center; } justify-content 用于设置弹性盒子元素在主轴（横轴）方向上的对齐方式 2 垂直居中2.1 单行内联(inline)元素垂直居中span { height: 120px; line-height: 120px; } 2.2 多行元素垂直居中表格布局（table） .center-table { display: table; } .tabel-cell { display: table-cell; vertical-align: middle; } flex 布局（flex） .center-flex { display: flex; flex-direction: column; justify-content: center; } flex-direction: column 定义主轴方向为纵向。 “精灵元素” 即在父容器内放一个 100%高度的伪元素，让文本和伪元素垂直对齐，从而达到垂直居中的目的。 .ghost-center { position: relative; } .ghost-center::before { content: ' '; display: inline-block; height: 100%; width: 1%; vertical-align: middle; } .ghost-center p { display: inline-block; vertical-align: middle; width: 20rem; } 2.3 块级元素垂直居中固定高度的块级元素 .parent { position: relative; } .child { position: absolute; top: 50%; height: 100px; margin-top: -50px; } 未知高度的块级元素 .parent { position: relative; } .child { position: absolute; top: 50%; transform: translateY(-50%); } 3 水平垂直居中固定宽高元素水平垂直居中 .parent { position: relative; } .child { width: 300px; height: 100px; padding: 20px; position: absolute; top: 50%; left: 50%; margin: -70px 0 0 -170px; } 未知宽高元素水平垂直居中 .parent { position: relative; } .child { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); } flex 布局 .parent { display: flex; justify-content: center; align-items: center; } justify-content 用于设置或检索弹性盒子元素在主轴（横轴）方向上的对齐方式；而 align-items 属性定义 flex 子项在 flex 容器的当前行的侧轴（纵轴）方向上的对齐方式。 grid 布局 .parent { height: 140px; display: grid; } .child { margin: auto; }","tags":[{"name":"CSS","slug":"CSS","permalink":"http://coder.liusixin.cn/tags/CSS/"},{"name":"项目实践","slug":"项目实践","permalink":"http://coder.liusixin.cn/tags/项目实践/"}]},{"title":"微信内置浏览器清除缓存","date":"2017-05-20T05:21:04.000Z","path":"posts/36ac550f/","text":"本方法适用于现在版本的 微信。 在微信浏览器中打开该链接： debugx5.qq.com ， 打开后显示如下 将页面滑动至最底部，勾选左侧的选项 这里我把所有选型都勾选了，你们也可以自行选择，再点击右侧的【清除】按钮，弹出成功弹窗便可以了，如下图所示","tags":[{"name":"项目实践","slug":"项目实践","permalink":"http://coder.liusixin.cn/tags/项目实践/"},{"name":"技术杂谈","slug":"技术杂谈","permalink":"http://coder.liusixin.cn/tags/技术杂谈/"},{"name":"微信","slug":"微信","permalink":"http://coder.liusixin.cn/tags/微信/"}]},{"title":"Javascript学习总结——正则篇","date":"2017-05-10T12:23:36.000Z","path":"posts/d3746340/","text":"修饰符: i: 执行对大小写不敏感的匹配。 g: 执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）。 m: 执行多行匹配。 元字符： \\d: 匹配一个数字字符。等价于 [0-9]。 \\D: 匹配一个非数字字符。等价于 [^0-9]。 \\f: 匹配一个换页符。等价于 \\x0c 和 \\cL。 \\n: 匹配一个换行符。等价于 \\x0a 和 \\cJ。 \\r: 匹配一个回车符。等价于 \\x0d 和 \\cM。 \\s: 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \\f\\n\\r\\t\\v]。 \\S: 匹配任何非空白字符。等价于 [^ \\f\\n\\r\\t\\v]。 \\t: 匹配一个制表符。等价于 \\x09 和 \\cI。 \\v: 匹配一个垂直制表符。等价于 \\x0b 和 \\cK。 \\w: 匹配字母、数字、下划线。等价于'[A-Za-z0-9_]'。 \\W: 匹配非字母、数字、下划线。等价于 '[^A-Za-z0-9_]'。 \\xn: 匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长。 // 例: '\\x41' 匹配 \"A\"。'\\x041' 则等价于 '\\x04' &amp; \"1\"。正则表达式中可以使用 ASCII 编码。 \\num: 匹配 num，其中 num 是一个正整数。对所获取的匹配的引用。 // 例: '(.)\\1' 匹配两个连续的相同字符。 \\n: 标识一个八进制转义值或一个向后引用。如果 \\n 之前至少 n 个获取的子表达式，则 n 为向后引用。否则，如果 n 为八进制数字 (0-7)，则 n 为一个八进制转义值。 \\nm: 标识一个八进制转义值或一个向后引用。如果 \\nm 之前至少有 nm 个获得子表达式，则 nm 为向后引用。如果 \\nm 之前至少有 n 个获取，则 n 为一个后跟文字 m 的向后引用。如果前面的条件都不满足，若 n 和 m 均为八进制数字 (0-7)，则 \\nm 将匹配八进制转义值 nm \\nml: 如果 n 为八进制数字 (0-3)，且 m 和 l 均为八进制数字 (0-7)，则匹配八进制转义值 nml \\un: 匹配 n，其中 n 是一个用四个十六进制数字表示的 Unicode 字符。 // 例: \\u00A9 匹配版权符号 (?)。 \\: 将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。 // 例:'n' 匹配字符 \"n\"。'\\n' 匹配一个换行符。序列 '\\\\' 匹配 \"\\\" 而 \"\\(\" 则匹配 \"(\"。 ^: 匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 '\\n' 或 '\\r' 之后的位置。 // 例： (^a) 就是匹配以字母a开头的字符串 ^: 还有另个一个作用就是取反，比如[^xyz] 表示匹配的字符串不包含xyz // 例：[^xyz] 表示匹配的字符串不包含xyz $: 匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 '\\n' 或 '\\r' 之前的位置。 // 例： (b$) 就是匹配以字母b结尾的字符串 *: 匹配前面的子表达式零次或多次。 // 例: zo* 能匹配 \"z\" 以及 \"zoo\"。* 等价于{0,}。 +: 匹配前面的子表达式一次或多次。 // 例: 'zo+' 能匹配 \"zo\" 以及 \"zoo\"，但不能匹配 \"z\"。+ 等价于 {1,}。 ?: 匹配前面的子表达式零次或一次。 // 例: \"do(es)?\" 可以匹配 \"do\" 或 \"does\" 。? 等价于 {0,1}。 ?: 当该字符紧跟在任何一个其他限制符 (*, +, ?, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。 // 例: 对于字符串 \"oooo\"，'o+?' 将匹配单个 \"o\"，而 'o+' 将匹配所有 'o'。 {n}: n 是一个非负整数。匹配确定的 n 次。 // 例: 'o{2}' 不能匹配 \"Bob\" 中的 'o'，但是能匹配 \"food\" 中的两个 o {n,}: n 是一个非负整数。至少匹配n 次。 // 例: 'o{2,}' 不能匹配 \"Bob\" 中的 'o'，但能匹配 \"foooood\" 中的所有 o。'o{1,}' 等价于 'o+'。'o{0,}' 则等价于 'o*'。 {n,m}: m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。 // 例: \"o{1,3}\" 将匹配 \"fooooood\" 中的前三个 o。'o{0,1}' 等价于 'o?'。请注意在逗号和两个数之间不能有空格。 .: 匹配除 \"\\n\" 之外的任何单个字符。要匹配包括 '\\n' 在内的任何字符，请使用像\"(.|\\n)\"的模式。 (pattern): 匹配 pattern 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，在VBScript 中使用 SubMatches 集合，在JScript 中则使用 $0…$9 属性。要匹配圆括号字符，请使用 '\\(' 或 '\\)' // 例：\"(x)\" 将匹配到 \"x\" 并将按顺序从 $1-$99 排序代替 //例： // var url = \"http://www.qidian.com/BookReader/1017141,20361055.aspx\" // var reg = /(http:\\/\\/www\\.qidian\\.com\\/BookReader\\/)(\\d+),(\\d+).aspx/gmi // var rep=url.replace(reg,\"$1ShowBook.aspx?bookId=$2&amp;chapterId=$3\"); // console.log(rep); // -> http://www.qidian.com/BookReader/ShowBook.aspx?bookId=1017141&amp;chapterId=20361055 (?:pattern)：匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 \"或\" 字符 (|) 来组合一个模式的各个部分是很有用。 // 例：'industr(?:y|ies) 就是一个比 'industry|industries' 更简略的表达式。 (?=pattern): 正向肯定预查（look ahead positive assert），在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。 // 例: \"Windows(?=95|98|NT|2000)\"能匹配\"Windows2000\"中的\"Windows\"，但不能匹配\"Windows3.1\"中的\"Windows\"。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 (?!pattern): 正向否定预查(negative assert)，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。 // 例: \"Windows(?!95|98|NT|2000)\"能匹配\"Windows3.1\"中的\"Windows\"，但不能匹配\"Windows2000\"中的\"Windows\"。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 (?&lt;=pattern): 反向(look behind)肯定预查，与正向肯定预查类似，只是方向相反。 // 例: \"(?&lt;=95|98|NT|2000)Windows\"能匹配\"2000Windows\"中的\"Windows\"，但不能匹配\"3.1Windows\"中的\"Windows\"。 (?&lt;!pattern): 反向否定预查，与正向否定预查类似，只是方向相反。 // 例: \"(?&lt;!95|98|NT|2000)Windows\"能匹配\"3.1Windows\"中的\"Windows\"，但不能匹配\"2000Windows\"中的\"Windows\"。 x|y: 匹配 x 或 y。 // 例: 'z|food' 能匹配 \"z\" 或 \"food\"。'(z|f)ood' 则匹配 \"zood\" 或 \"food\"。 [xyz]: 字符集合。匹配所包含的任意一个字符。 // 例: '[abc]' 可以匹配 \"plain\" 中的 'a'。 [^xyz]: 负值字符集合。匹配未包含的任意字符。 // 例: '[^abc]' 可以匹配 \"plain\" 中的'p'、'l'、'i'、'n'。 [a-z]: 字符范围。匹配指定范围内的任意字符。 // 例: '[a-z]' 可以匹配 'a' 到 'z' 范围内的任意小写字母字符。 [^a-z]: 负值字符范围。匹配任何不在指定范围内的任意字符。 // 例: '[^a-z]' 可以匹配任何不在 'a' 到 'z' 范围内的任意字符。 \\b: 匹配一个单词边界，也就是指单词和空格间的位置。 // 例: 'er\\b' 可以匹配\"never\" 中的 'er'，但不能匹配 \"verb\" 中的 'er'。 \\B: 匹配非单词边界。 // 例: 'er\\B' 能匹配 \"verb\" 中的 'er'，但不能匹配 \"never\" 中的 'er'。 \\cx: 匹配由 x 指明的控制字符。 // 例: \\cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 'c' 字符。 方法1. compile(regexp,modifier)在脚本执行过程中编译正则表达式 /* regexp: 正则表达式 modifier: 规定匹配的类型。\"g\" 用于全局匹配，\"i\" 用于区分大小写，\"gi\" 用于全局区分大小写的匹配。 */ var compileStr = 'Every man in the world! Every woman on earth!'; var compilePatt = /man/g; var compilePatt1 = /(wo)?man/g; compilePatt1.compile(compilePatt1); var compileStrEle1 = compileStr.replace(compilePatt, 'person'); var compileStrEle2 = compileStr.replace(compilePatt1, 'person'); console.log(compileStrEle1); // -> Every person in the world! Every woperson on earth! console.log(compileStrEle2); // -> Every person in the world! Every person on earth! 2. exec(string)用于检索字符串中的正则表达式的匹配。如果字符串中有匹配的值返回该匹配值，否则返回 null。 var execStr = 'Hello world!'; var execPatt = /Hello/g; var execStrEle = execPatt.exec(execStr); console.log(execStrEle); // -> Hello 3. test(string)用于检测一个字符串是否匹配某个模式.如果字符串中有匹配的值返回 true ，否则返回 false var testStr = 'Hello world!'; var testPatt = /Hello/g; var testPatt2 = /Helloaaa/g; var testStrEle = testPatt.test(testStr); var testStrEle2 = testPatt2.test(testStr); console.log(testStrEle); // -> true console.log(testStrEle2); // -> false 4. match(regexp)可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配。如果没有找到任何匹配的文本， match() 将返回 null。否则，它将返回一个数组，其中存放了与它找到的匹配文本有关的信息。 var matchStr = 'The rain in SPAIN stays mainly in the plain'; var matchEle = matchStr.match(/ain/gi); console.log(matchEle); // -> [\"ain\", \"AIN\", \"ain\", \"ain\"] 常见正则表达式汇总/^[1-9]\\d*$/ //匹配正整数 /^-[1-9]\\d*$/ //匹配负整数 /^-?[1-9]\\d*$/ //匹配整数 /^[1-9]\\d*|0$/ //匹配非负整数（正整数 + 0） /^-[1-9]\\d*|0$/ //匹配非正整数（负整数 + 0） /^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*$/ //匹配正浮点数 /^-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*)$/ //匹配负浮点数 /^-?([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0)$/ //匹配浮点数 /^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0$/ //匹配非负浮点数（正浮点数 + 0） /^(-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*))|0?\\.0+|0$/ //匹配非正浮点数（负浮点数 + 0） /^[A-Za-z]+$/ // 由26个英文字母组成的字符串 /^[A-Z]+$/ // 由26个英文字母的大写组成的字符串 /^[a-z]+$/ // 由26个英文字母的小写组成的字符串 /^[A-Za-z0-9]+$/ // 由数字和26个英文字母组成的字符串 /^\\w+$/ // 由数字、26个英文字母或者下划线组成的字符串 /^[\\x00-\\xff]+$/ // 匹配所有单字节长度的字符组成的字符串 /^[^\\x00-\\xff]+$/ // 匹配所有双字节长度的字符组成的字符串 /[^\\x00-\\xff]+/ // 字符串是否含有双字节字 /n[s| ]*r/ // 匹配空行的正则 /(^s*)|(s*$)/ // 匹配首尾空格的正则 /^[a-zA-Z0-9_]{1,}$/ // 所有包含一个以上的字母、数字或下划线的字符串 /[^\\\"\\']/ // 除了双引号(\")和单引号(')之外的所有字符 检测函数function checkStr(str, type) { switch (type) { case 'phone': //手机号码 return /^1[3|4|5|7|8][0-9]{9}$/.test(str); case 'tel': //座机 return /^(0\\d{2,3}-\\d{7,8})(-\\d{1,4})?$/.test(str); case 'card': //身份证 return /^\\d{15}|\\d{18}$/.test(str); case 'pwd': //密码以字母开头，长度在6~18之间，只能包含字母、数字和下划线 return /^[a-zA-Z]\\w{5,17}$/.test(str); case 'postal': //邮政编码 return /[1-9]\\d{5}(?!\\d)/.test(str); case 'QQ': //QQ号 return /^[1-9][0-9]{4,9}$/.test(str); case 'email': //邮箱 return /^[\\w-]+(\\.[\\w-]+)*@[\\w-]+(\\.[\\w-]+)+$/.test(str); case 'money': //金额(小数点2位) return /^\\d*(?:\\.\\d{0,2})?$/.test(str); case 'URL': //网址 return /(http|ftp|https):\\/\\/[\\w\\-_]+(\\.[\\w\\-_]+)+([\\w\\-\\.,@?^=%&amp;:/~\\+#]*[\\w\\-\\@?^=%&amp;/~\\+#])?/.test( str ); case 'IP': //IP return /((?:(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d)\\\\.){3}(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d))/.test( str ); case 'date': //日期时间 return ( /^(\\d{4})\\-(\\d{2})\\-(\\d{2}) (\\d{2})(?:\\:\\d{2}|:(\\d{2}):(\\d{2}))$/.test( str ) || /^(\\d{4})\\-(\\d{2})\\-(\\d{2})$/.test(str) ); case 'number': //数字 return /^[0-9]$/.test(str); case 'english': //英文 return /^[a-zA-Z]+$/.test(str); case 'chinese': //中文 return /^[\\u4E00-\\u9FA5]+$/.test(str); case 'lower': //小写 return /^[a-z]+$/.test(str); case 'upper': //大写 return /^[A-Z]+$/.test(str); case 'HTML': //HTML标记 return /&lt;(\"[^\"]*\"|'[^']*'|[^'\">])*>/.test(str); default: return true; } }","tags":[{"name":"javascript","slug":"javascript","permalink":"http://coder.liusixin.cn/tags/javascript/"},{"name":"编程笔记","slug":"编程笔记","permalink":"http://coder.liusixin.cn/tags/编程笔记/"}]},{"title":"Javascript学习总结——数组篇","date":"2017-05-07T12:55:36.000Z","path":"posts/da5041c4/","text":"1. toString()返回以数组中的每个值的字符串形式拼接而成的一个以逗号分割的字符串 var arr = [1, 2, 3, 4, 5, 6]; console.log(arr.toString()); // -> 1,2,3,4,5,6 2. valueOf()返回数组对象的原始值。返回的还是数组 var arr = [1, 2, 3, 4, 5, 6]; console.log(arr.valueOf()); // -> [1, 2, 3, 4, 5, 6] 3. join()通过指定的分隔符进行分隔并返回一个字符串 var arr = [1, 2, 3, 4, 5, 6]; var newArr = arr.join('-'); console.log(newArr); // -> join:1-2-3-4-5-6 4. push()向数组的末尾添加一个或更多元素，并返回新的长度 var arr = [1, 2, 3, 4, 5, 6]; arr.push(7); console.log(arr); // -> [1, 2, 3, 4, 5, 6, 7] 5. pop()删除数组的最后一个元素并返回删除的元素, 如果数组为空就返回 undefined var arr = [1, 2, 3, 4, 5, 6]; var newArr = arr.pop(); console.log(newArr, arr); // -> 6, [1, 2, 3, 4, 5] 6. shift()删除并返回数组的第一个元素, 如果数组为空，则 shift() 方法不进行任何操作，返回 undefined var arr = [1, 2, 3, 4, 5, 6]; var newArr = arr.shift(); console.log(newArr, arr); // -> 1, [2, 3, 4, 5, 6] 7. unshift()向数组的开头添加一个或更多元素，并返回新的长度 var arr = [1, 2, 3, 4, 5, 6]; arr.unshift(0); console.log(arr); // -> [0, 1, 2, 3, 4, 5, 6] 8.reverse()反转数组的元素顺序 var arr = [1, 2, 3, 4, 5, 6]; arr.reverse(); console.log(arr); // -> [6, 5, 4, 3, 2, 1] 9. sort()对数组的元素进行排序 // a: var arr1 = [1, 3, 5, 2, 7, 6]; arr1.sort(); console.log(arr1); // -> [1, 2, 3, 5, 6, 7] // b: 因为sort排序是从左至右比较，只要其中一个比较出了结果，就直接返 var arr2 = [1, 3, 19, 5, 17, 6]; arr2.sort(); console.log(arr2); // -> [1, 17, 19, 3, 5, 6] // c: 封装sort function sort(arr, type) { type = type || 1; return arr.sort((a, b) => { switch (type) { case 1: // 从小到大 return a - b; case 2: // 从大到小 return b - a; case 3: // 随机排序 return Math.random() - 0.5; default: return arr; } }); } var arr3 = [1, 3, 19, 5, 17, 6]; sort(arr3); console.log(arr3); // -> [1, 3, 5, 6, 17, 19] 10. concat()连接两个或更多的数组，并返回结果 var arr1 = [1, 2, 3], var arr2 = [4, 5, 6] var arr3 = arr1.concat(arr2) console.log(arr3) // -> [1, 2, 3, 4, 5, 6] 11. slice(start, end)选取数组的的一部分，并返回一个新数组, start 必须，end 可选 var arr = [1, 2, 3, 4, 5, 6]; var newArr = arr.slice(1, -1); // 截取第二个到倒数第二个 console.log(newArr); // -> [2, 3, 4, 5] 12. splice(index, howmany, item1,.....,itemX)从数组中添加或删除元素 /* * index: 必需。规定从何处添加/删除元素。该参数是开始插入和（或）删除的数组元素的下标，必须是数字 * howmany: 必需。规定应该删除多少元素。必须是数字，但可以是 \"0\"。 如果未规定此参数，则删除从 index 开始到原数组结尾的所有元素。 * item1,.....,itemX: 可选。要添加到数组的新元素 */ var arr1 = [1, 2, 3, 4, 5, 6]; arr1.splice(2, 2, 10, 12); // 从下标为2的地方开始删除 后面的两个元素，并在这个地方插入10,12两个元素 console.log(arr1); // -> [1, 2, 10, 12, 5, 6] var arr2 = [1, 2, 3, 4, 5, 6]; arr2.splice(2, 0, 10, 12); // 当需要删除的元素为0，相当于在这个位置插入元素 console.log(arr2); // -> [1, 2, 10, 12, 3, 4, 5, 6] 13. copyWithin(target, start, end)从数组的指定位置拷贝元素到数组的另一个指定位置中 /* * target: 必需。复制到指定目标索引位置。 * start: 必需。元素复制的起始位置。 * end: 可选。停止复制的索引位置 (默认array.length) */ var arr = [1, 2, 3, 4, 5, 6]; arr.copyWithin(1, 2, 4); console.log(arr); // -> [1, 3, 4, 4, 5, 6] 14. fill(value, start, end)用于将一个固定值替换数组的元素 /* * value: 必需。填充的值。 * start: 可选。开始填充位置。 * end: 可选。停止填充位置 (默认为 array.length) */ var arr = [1, 2, 3, 4, 5, 6]; arr.fill(9, 2, 4); console.log(arr); // -> [1, 2, 9, 9, 5, 6] 15.includes(searchElement, fromIndex)用来判断一个数组是否包含一个指定的值，如果是返回 true，否则 false var arr = [1, 2, 3, 4, 5, 6]; var incArr1 = arr.includes(3); var incArr2 = arr.includes(10); console.log(incArr1, incArr2); // -> true, false 16.indexOf(item,start)可返回某个指定的字符串值在字符串中首次出现的位置 var arr = [1, 2, 3, 4, 3, 6]; var idx = arr.indexOf(3); console.log(idx); // -> 2 17. lastIndexOf(item,start)返回一个指定的字符串值最后出现的位置，在一个字符串中的指定位置从后向前搜索 var arr = [1, 2, 3, 4, 3, 6]; var idx = arr.lastIndexOf(3); console.log(idx); // -> 4 18. find(function(currentValue, index, arr),thisValue)返回传入一个测试条件（函数）符合条件的数组第一个元素 /* * currentValue: 必需。当前元素 * index: 可选。当前元素的索引值 * arr: 可选。当前元素所属的数组对象 * thisValue: 可选。 传递给函数的值一般用 \"this\" 值。 如果这个参数为空， \"undefined\" 会传递给 \"this\" 值 */ var arr = [1, 2, 3, 4, 5, 6]; var ele = arr.find(function(currentValue, index, arr) { return currentValue >= 4; }); console.log(ele); // -> 4 19. findIndex(function(currentValue, index, arr),thisValue)返回符合测试条件的第一个数组元素索引，如果没有符合条件的则返回 -1 /* * currentValue: 必需。当前元素 * index: 可选。当前元素的索引值 * arr: 可选。当前元素所属的数组对象 * thisValue: 可选。 传递给函数的值一般用 \"this\" 值。 如果这个参数为空， \"undefined\" 会传递给 \"this\" 值 */ var arr = [1, 2, 3, 4, 5, 6]; var idx = arr.findIndex(function(currentValue, index, arr) { return currentValue >= 4; }); console.log(idx); 20. forEach(function(currentValue, index, arr), thisValue)用于调用数组的每个元素，并将元素传递给回调函数。没有返回值 /* * currentValue: 必需。当前元素 * index: 可选。当前元素的索引值 * arr: 可选。当前元素所属的数组对象 * thisValue: 可选。 传递给函数的值一般用 \"this\" 值。 如果这个参数为空， \"undefined\" 会传递给 \"this\" 值 */ var arr = [1, 2, 3, 4, 5, 6]; arr.forEach(function(currentValue, index, arr) { console.log(currentValue); }); // -> 依次打印 1 2 3 4 5 6, 没有返回值 21. map(function(currentValue, index, arr), thisValue)返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值 /* * currentValue: 必需。当前元素 * index: 可选。当前元素的索引值 * arr: 可选。当前元素所属的数组对象 * thisValue: 可选。 传递给函数的值一般用 \"this\" 值。 如果这个参数为空， \"undefined\" 会传递给 \"this\" 值 */ var arr = [1, 2, 3, 4, 5, 6]; var newArr = arr.map(function(currentValue, index, arr) { // console.log(currentValue) return currentValue * 2; }); console.log(newArr); // -> [2, 4, 6, 8, 10, 12] 22. reduce(function(total, currentValue, index, arr), thisValue)接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值 /* * currentValue: 必需。当前元素 * index: 可选。当前元素的索引值 * arr: 可选。当前元素所属的数组对象 * total: 必需。初始值, 或者计算结束后的返回值。 * thisValue: 可选。 传递给函数的值一般用 \"this\" 值。 如果这个参数为空， \"undefined\" 会传递给 \"this\" 值 */ var arr = [1, 2, 3, 4, 5, 6]; var newArr = arr.reduce(function(total, currentValue, index, arr) { return total + currentValue; }); console.log(newArr); // -> 21 23. reduceRight(function(total, currentValue, index, arr), thisValue)接收一个函数作为累加器，数组中的每个值（从右到左）开始缩减，最终计算为一个值 /* * currentValue: 必需。当前元素 * index: 可选。当前元素的索引值 * arr: 可选。当前元素所属的数组对象 * total: 必需。初始值, 或者计算结束后的返回值。 * thisValue: 可选。 传递给函数的值一般用 \"this\" 值。 如果这个参数为空， \"undefined\" 会传递给 \"this\" 值 */ var arr = [1, 2, 3, 4, 5, 6]; var newArr = arr.reduceRight(function(total, currentValue, index, arr) { return total - currentValue; }); console.log(newArr); // -> -9 24. some(function(currentValue, index, arr), thisValue)如果有一个元素满足条件，则表达式返回 true , 剩余的元素不会再执行检测。如果没有满足条件的元素，则返回 false /* * currentValue: 必需。当前元素 * index: 可选。当前元素的索引值 * arr: 可选。当前元素所属的数组对象 * thisValue: 可选。 传递给函数的值一般用 \"this\" 值。 如果这个参数为空， \"undefined\" 会传递给 \"this\" 值 */ var arr = [1, 2, 3, 4, 5, 6]; var someEle1 = arr.some(function(currentValue, index, arr) { return currentValue > 4; }); var someEle2 = arr.some(function(currentValue, index, arr) { return currentValue > 6; }); console.log(someEle1, someEle2); // -> true, false 25. every(function(currentValue, index, arr), thisValue)如果数组中检测到有一个元素不满足，则整个表达式返回 false ，且剩余的元素不会再进行检测。如果所有元素都满足条件，则返回 true /* * currentValue: 必需。当前元素 * index: 可选。当前元素的索引值 * arr: 可选。当前元素所属的数组对象 * thisValue: 可选。 传递给函数的值一般用 \"this\" 值。 如果这个参数为空， \"undefined\" 会传递给 \"this\" 值 */ var arr = [1, 2, 3, 4, 5, 6]; var everyEle1 = arr.every(function(currentValue, index, arr) { return currentValue > 0; }); var everyEle2 = arr.every(function(currentValue, index, arr) { return currentValue > 1; }); console.log(everyEle1, everyEle2); // -> true, false 26. filter(function(currentValue, index, arr), thisValue)创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素 /* * currentValue: 必需。当前元素 * index: 可选。当前元素的索引值 * arr: 可选。当前元素所属的数组对象 * thisValue: 可选。 传递给函数的值一般用 \"this\" 值。 如果这个参数为空， \"undefined\" 会传递给 \"this\" 值 */ var arr = [1, 2, 3, 4, 5, 6]; var newArr = arr.filter(function(currentValue, index, arr) { return currentValue > 2; }); console.log(newArr); // -> [3, 4, 5, 6] 27. from()将类数组对象和可遍历对象转化为数组 obj = { 0: 'a', 1: 'b', 2: 'c', length: 3 }; arr = Array.from(obj); console.log(arr); // -> [\"a\", \"b\", \"c\"] 28. of()创建一个具有可变数量参数的新数组实例，而不考虑参数的数量或类型 Array.of(7); // -> [7] Array.of(1, 2, 3); // -> [1, 2, 3] Array(7); // -> [ , , , , , , ] Array(1, 2, 3); // -> [1, 2, 3]","tags":[{"name":"javascript","slug":"javascript","permalink":"http://coder.liusixin.cn/tags/javascript/"},{"name":"编程笔记","slug":"编程笔记","permalink":"http://coder.liusixin.cn/tags/编程笔记/"}]},{"title":"Javascript学习总结——字符串篇","date":"2017-05-06T04:55:36.000Z","path":"posts/e84bf94c/","text":"1. toString() 和 valueOf()返回的都是自己 var str = 'abcdefg'; console.log(str.toString()); // -> 'abcdefg' console.log(str.valueOf()); // -> 'abcdefg' 2. charAt(index)返回在指定位置的字符。 var str = 'abcdefg'; var idx = str.charAt(3); console.log(charAtEle); // -> d 3. charCodeAt(index)返回指定位置的字符的 Unicode 编码。 var str = 'abcdefg'; var idx = str.charCodeAt(3); console.log(idx); // -> 100 (d 的 Unicode编码是 100) 4. fromCharCode(n1, n2, ..., nX)将 Unicode 编码转为一个字符 接受一个或多个 Unicode 值，即要创建的字符串中的字符的 Unicode 编码。 var charCode1 = String.fromCharCode(100); var charCode2 = String.fromCharCode(72, 69, 76, 76, 79); console.log(charCode1); // -> d console.log(charCode2); // -> HELLO 5. indexOf(searchvalue,start)返回某个指定的字符串值在字符串中首次出现的位置。如果没有找到匹配的字符串则返回 -1。 /* * searchvalue: 必需。规定需检索的字符串值 * start: 可选的整数参数。规定在字符串中开始检索的位置。它的合法取值是 0 到 string Object.length - 1。如省略该参数，则将从字符串的首字符开始检索 */ var str = 'abcdbfg'; var idx1 = str.indexOf('b'); var idx2 = str.indexOf('b', 2); console.log(idx1); // -> 1 console.log(idx2); // -> 4 6. lastIndexOf(searchvalue,start)返回一个指定的字符串值最后出现的位置，如果指定第二个参数 start，则在一个字符串中的指定位置从后向前搜索。 /* * searchvalue: 必需。规定需检索的字符串值 * start: 可选的整数参数。规定在字符串中开始检索的位置。它的合法取值是 0 到 stringObject.length - 1。如省略该参数，则将从字符串的最后一个字符处开始检索。 */ var str = 'abcdbfg'; var idx1 = str.lastIndexOf('b'); var idx2 = str.lastIndexOf('b', 2); console.log(idx1); // -> 4 console.log(idx2); // -> 1 7. concat(string1, string2, ..., stringX)concat() 方法用于连接两个或多个字符串。该方法没有改变原有字符串，但是会返回连接两个或多个字符串新字符串。 var str1 = 'abcd'; var str2 = 'efg'; var str3 = str1.concat(str2); console.log(str3); // -> 'abcdefg' 8. match(regexp)在字符串内检索指定的值，或找到一个或多个正则表达式的匹配。 var str = 'abcdbef'; var matchEle = str.match(/b/gi); console.log(matchEle); // -> [\"b\", \"b\"] 9. replace(searchvalue,newvalue)在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串 /* * searchvalue: 必须。规定子字符串或要替换的模式的 RegExp 对象。 请注意，如果该值是一个字符串，则将它作为要检索的直接量文本模式，而不是首先被转换为 RegExp 对象。 * newvalue: 必需。一个字符串值。规定了替换文本或生成替换文本的函数。 */ var str1 = 'abcdafg'; var newStr1 = str1.replace(/a/g, 'z'); console.log(newStr1); // -> zbcdzfg var str2 = 'a1b2c3d4'; var newStr2 = str2.replace(/\\d/g, function(v) { return Math.pow(v, 2); }); console.log(newStr2); // -> a1b4c9d16 10. search(searchvalue)检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串。如果没有找到任何匹配的子串，则返回 -1。 var str = 'Abcdaef'; var idx1 = searchStr.search(/a/); var idx2 = searchStr.search(/a/i); console.log(idx1); // -> 4 console.log(idx2); // -> 0 11. slice(start,end)提取字符串的某个部分，并以新的字符串返回被提取的部分。 /* * start:必须. 要抽取的片断的起始下标。第一个字符位置为 0 * end: 可选。 紧接着要抽取的片段的结尾的下标。若未指定此参数，则要提取的子串包括 start 到原字符串结尾的字符串。如果该参数是负数，那么它规定的是从字符串的尾部开始算起的位置。 */ var str = 'abcdefg'; var newStr = str.slice(1, -1); console.log(newStr); // -> bcdef 12. split(separator,limit)把一个字符串分割成字符串数组。如果把空字符串 (“”) 用作 separator，那么 stringObject 中的每个字符之间都会被分割 /* * separator: 可选。字符串或正则表达式，从该参数指定的地方分割 string Object。 * limit: 可选。该参数可指定返回的数组的最大长度。如果设置了该参数，返回的子串不会多于这个参数指定的数组。如果没有设置该参数，整个字符串都会被分割，不考虑它的长度。 */ var str = 'abcdecg'; var splitStr1 = str.split('c'); var splitStr2 = str.split(''); console.log(splitStr1); // -> [\"ab\", \"de\", \"g\"] console.log(splitStr2); // -> [\"a\", \"b\", \"c\", \"a\", \"e\", \"f\", \"g\"] 13. substr(start,length)在字符串中抽取从 开始 下标开始的指定数目的字符。 /* * start: 必需。要抽取的子串的起始下标。必须是数值。如果是负数，那么该参数声明从字符串的尾部开始算起的位置。也就是说，-1 指字符串中最后一个字符，-2 指倒数第二个字符，以此类推。 * length: 可选。子串中的字符数。必须是数值。如果省略了该参数，那么返回从 stringObject 的开始位置到结尾的字串。 */ var str = 'abcdefg'; var newStr = str.substr(2, 2); console.log(newStr); // -> cd 14. substring(from, to)用于提取字符串中介于两个指定下标之间的字符。返回的子串包括 开始 处的字符，但不包括 结束 处的字符。 /* * from:必需。一个非负的整数，规定要提取的子串的第一个字符在 string Object 中的位置。 * to: 可选。一个非负的整数，比要提取的子串的最后一个字符在 string Object 中的位置多 1。如果省略该参数，那么返回的子串会一直到字符串的结尾。 */ var str = 'abcdefg'; var newStr = str.substring(2, 4); console.log(newStr); // -> cd 15. toLowerCase()把字符串转换为小写。 var str = 'ABCDEFG'; var newStr = str.toLowerCase(); console.log(newStr); // -> abcdefg 16. toUpperCase()把字符串转换为大写 var str = 'abcdefg'; var newStr = str.toUpperCase(); console.log(newStr); // -> ABCDEFG 17. trim(): 去除字符串两边的空白var str = ' abcdefg '; var newStr = str.trim(); console.log(newStr); // ->abcdefg 18. includes(searchvalue, start)用来判断一个字符串是否包含一个指定的值，如果是返回 true，否则 false var str = 'abcdefg'; var includesStr1 = str.includes('a'); var includesStr2 = str.includes('z'); console.log(includesStr1); // -> true console.log(includesStr2); // -> false 19. startsWith(searchvalue, start)表示是否字符(串)位于 string 的头部位置, 如果是返回 true，否则 false var str = 'abcdefg'; var startsStr1 = str.startsWith('a'); var startsStr2 = str.startsWith('b'); console.log(startsStr1); // -> true console.log(startsStr2); // -> false 20. endsWith(searchvalue, start)表示是否字符(串)位于 string 的尾部位置, 如果是返回 true，否则 false var str = 'abcdefg'; var endsStr1 = str.endsWith('f'); var endsStr2 = str.endsWith('g'); console.log(endsStr1); // -> false console.log(endsStr2); // -> true 21. repeat(num)参数 num 为重复字符串的次数 var str = 'abc'; var newStr = str.repeat(2); //重复两次 console.log(newStr); // -> abcabc 22. ${}模板字符串 var str = 'hello'; var tpl = `${str1} world`; console.log(tpl); // -> hello world String HTML 包装方法1. anchor(name)用于创建 HTML 锚。 var str = '我是锚点'; var htmlStr = str.anchor('top'); console.log(htmlStr); // -> &lt;a name=\"top\">我是锚点&lt;/a> 2. big()把字符串显示为大号字体 var str = 'abcdefg'; var htmlStr = str.big(); console.log(htmlStr); // -> &lt;big>abcdefg&lt;/big> 3. blink()显示闪动字符串 var str = 'abcdefg'; var htmlStr = str.blink(); console.log(htmlStr); // -> &lt;blink>abcdefg&lt;/blink> 4. bold()使用粗体显示字符串。 var str = 'abcdefg'; var htmlStr = str.bold(); console.log(htmlStr); // -> &lt;b>abcdefg&lt;/b> 5. fixed()以打字机文本显示字符串。 var str = 'abcdefg'; var htmlStr = str.fixed(); console.log(htmlStr); // -> &lt;tt>abcdefg&lt;/tt> 6. fontcolor(color)使用指定的颜色来显示字符串。 var str = 'abcdefg'; var htmlStr = str.fontcolor('red'); console.log(htmlStr); // -> &lt;font color=\"red\">abcdefg&lt;/font> 7. fontsize(size)使用指定的尺寸来显示字符串, size 参数必须是从 1 至 7 的数字。 var str = 'abcdefg'; var htmlStr = str.fontsize(3); console.log(htmlStr); // -> &lt;font size=\"3\">abcdefg&lt;/font> 8. italics()使用斜体显示字符串。 var str = 'abcdefg'; var htmlStr = str.italics(3); console.log(htmlStr); // -> &lt;i>abcdefg&lt;/i> 9. link(url)将字符串显示为链接 var str = 'abcdefg'; var htmlStr = str.link('http://blog.liusixin.cn'); console.log(htmlStr); // -> &lt;a href=\"http://blog.liusixin.cn\">abcdefg&lt;/a> 10. small(url)使用小字号来显示字符串。 var str = 'abcdefg'; var htmlStr = str.small(); console.log(htmlStr); // -> &lt;small>abcdefg&lt;/small> 11. strike(url)用于显示加删除线的字符串 var str = 'abcdefg'; var htmlStr = str.strike(); console.log(htmlStr); // -> &lt;strike>abcdefg&lt;/strike> 12. sub(url)把字符串显示为下标 var str = 'abcdefg'; var htmlStr = str.sub(); console.log(htmlStr); // -> &lt;sub>abcdefg&lt;/sub> 13. sup(url)把字符串显示为上标 var str = 'abcdefg'; var htmlStr = str.sup(); console.log(htmlStr); // -> &lt;sup>abcdefg&lt;/sup>","tags":[{"name":"javascript","slug":"javascript","permalink":"http://coder.liusixin.cn/tags/javascript/"},{"name":"编程笔记","slug":"编程笔记","permalink":"http://coder.liusixin.cn/tags/编程笔记/"}]},{"title":"前端 css样式初始化","date":"2017-04-27T01:09:40.000Z","path":"posts/22b27e40/","text":"1. pc-reset PC 样式初始化/* normalize.css */ html { line-height: 1.15; /* 1 */ -ms-text-size-adjust: 100%; /* 2 */ -webkit-text-size-adjust: 100%; /* 2 */ } body { margin: 0; } article, aside, footer, header, nav, section { display: block; } h1 { font-size: 2em; margin: 0.67em 0; } figcaption, figure, main { /* 1 */ display: block; } figure { margin: 1em 40px; } hr { box-sizing: content-box; /* 1 */ height: 0; /* 1 */ overflow: visible; /* 2 */ } pre { font-family: monospace, monospace; /* 1 */ font-size: 1em; /* 2 */ } a { background-color: transparent; /* 1 */ -webkit-text-decoration-skip: objects; /* 2 */ } abbr[title] { border-bottom: none; /* 1 */ text-decoration: underline; /* 2 */ text-decoration: underline dotted; /* 2 */ } b, strong { font-weight: inherit; } b, strong { font-weight: bolder; } code, kbd, samp { font-family: monospace, monospace; /* 1 */ font-size: 1em; /* 2 */ } dfn { font-style: italic; } mark { background-color: #ff0; color: #000; } small { font-size: 80%; } sub, sup { font-size: 75%; line-height: 0; position: relative; vertical-align: baseline; } sub { bottom: -0.25em; } sup { top: -0.5em; } audio, video { display: inline-block; } audio:not([controls]) { display: none; height: 0; } img { border-style: none; } svg:not(:root) { overflow: hidden; } button, input, optgroup, select, textarea { font-family: sans-serif; /* 1 */ font-size: 100%; /* 1 */ line-height: 1.15; /* 1 */ margin: 0; /* 2 */ } button, input { /* 1 */ overflow: visible; } button, select { /* 1 */ text-transform: none; } button, html [type=\"button\"], /* 1 */ [type=\"reset\"], [type=\"submit\"] { -webkit-appearance: button; /* 2 */ } button::-moz-focus-inner, [type='button']::-moz-focus-inner, [type='reset']::-moz-focus-inner, [type='submit']::-moz-focus-inner { border-style: none; padding: 0; } button:-moz-focusring, [type='button']:-moz-focusring, [type='reset']:-moz-focusring, [type='submit']:-moz-focusring { outline: 1px dotted ButtonText; } fieldset { padding: 0.35em 0.75em 0.625em; } legend { box-sizing: border-box; /* 1 */ color: inherit; /* 2 */ display: table; /* 1 */ max-width: 100%; /* 1 */ padding: 0; /* 3 */ white-space: normal; /* 1 */ } progress { display: inline-block; /* 1 */ vertical-align: baseline; /* 2 */ } textarea { overflow: auto; } [type='checkbox'], [type='radio'] { box-sizing: border-box; /* 1 */ padding: 0; /* 2 */ } [type='number']::-webkit-inner-spin-button, [type='number']::-webkit-outer-spin-button { height: auto; } [type='search'] { -webkit-appearance: textfield; /* 1 */ outline-offset: -2px; /* 2 */ } [type='search']::-webkit-search-cancel-button, [type='search']::-webkit-search-decoration { -webkit-appearance: none; } ::-webkit-file-upload-button { -webkit-appearance: button; /* 1 */ font: inherit; /* 2 */ } details, /* 1 */ menu { display: block; } summary { display: list-item; } canvas { display: inline-block; } template { display: none; } [hidden] { display: none; } /* reset */ html, body, h1, h2, h3, h4, h5, h6, div, dl, dt, dd, ul, ol, li, p, blockquote, pre, hr, figure, table, caption, th, td, form, fieldset, legend, input, button, textarea, menu { margin: 0; padding: 0; box-sizing: border-box; } 2. Phone-reset/* normalize.css */ html { line-height: 1.15; /* 1 */ -ms-text-size-adjust: 100%; /* 2 */ -webkit-text-size-adjust: 100%; /* 2 */ } body { margin: 0; } article, aside, footer, header, nav, section { display: block; } h1 { font-size: 2em; margin: 0.67em 0; } figcaption, figure, main { /* 1 */ display: block; } figure { margin: 1em 40px; } hr { box-sizing: content-box; /* 1 */ height: 0; /* 1 */ overflow: visible; /* 2 */ } pre { font-family: monospace, monospace; /* 1 */ font-size: 1em; /* 2 */ } a { background-color: transparent; /* 1 */ -webkit-text-decoration-skip: objects; /* 2 */ } abbr[title] { border-bottom: none; /* 1 */ text-decoration: underline; /* 2 */ text-decoration: underline dotted; /* 2 */ } b, strong { font-weight: inherit; } b, strong { font-weight: bolder; } code, kbd, samp { font-family: monospace, monospace; /* 1 */ font-size: 1em; /* 2 */ } dfn { font-style: italic; } mark { background-color: #ff0; color: #000; } small { font-size: 80%; } sub, sup { font-size: 75%; line-height: 0; position: relative; vertical-align: baseline; } sub { bottom: -0.25em; } sup { top: -0.5em; } audio, video { display: inline-block; } audio:not([controls]) { display: none; height: 0; } img { border-style: none; } svg:not(:root) { overflow: hidden; } button, input, optgroup, select, textarea { font-family: sans-serif; /* 1 */ font-size: 100%; /* 1 */ line-height: 1.15; /* 1 */ margin: 0; /* 2 */ } button, input { /* 1 */ overflow: visible; } button, select { /* 1 */ text-transform: none; } button, html [type=\"button\"], /* 1 */ [type=\"reset\"], [type=\"submit\"] { -webkit-appearance: button; /* 2 */ } button::-moz-focus-inner, [type='button']::-moz-focus-inner, [type='reset']::-moz-focus-inner, [type='submit']::-moz-focus-inner { border-style: none; padding: 0; } button:-moz-focusring, [type='button']:-moz-focusring, [type='reset']:-moz-focusring, [type='submit']:-moz-focusring { outline: 1px dotted ButtonText; } fieldset { padding: 0.35em 0.75em 0.625em; } legend { box-sizing: border-box; /* 1 */ color: inherit; /* 2 */ display: table; /* 1 */ max-width: 100%; /* 1 */ padding: 0; /* 3 */ white-space: normal; /* 1 */ } progress { display: inline-block; /* 1 */ vertical-align: baseline; /* 2 */ } textarea { overflow: auto; } [type='checkbox'], [type='radio'] { box-sizing: border-box; /* 1 */ padding: 0; /* 2 */ } [type='number']::-webkit-inner-spin-button, [type='number']::-webkit-outer-spin-button { height: auto; } [type='search'] { -webkit-appearance: textfield; /* 1 */ outline-offset: -2px; /* 2 */ } [type='search']::-webkit-search-cancel-button, [type='search']::-webkit-search-decoration { -webkit-appearance: none; } ::-webkit-file-upload-button { -webkit-appearance: button; /* 1 */ font: inherit; /* 2 */ } details, /* 1 */ menu { display: block; } summary { display: list-item; } canvas { display: inline-block; } template { display: none; } [hidden] { display: none; } /* reset */ html, body, h1, h2, h3, h4, h5, h6, div, dl, dt, dd, ul, ol, li, p, blockquote, pre, hr, figure, table, caption, th, td, form, fieldset, legend, input, button, textarea, menu { margin: 0; padding: 0; box-sizing: border-box; } html, body { /* 禁止选中文本 */ -webkit-user-select: none; user-select: none; font: Oswald, 'Open Sans', Helvetica, Arial, sans-serif; } /* 禁止长按链接与图片弹出菜单 */ a, img { -webkit-touch-callout: none; } /*ios android去除自带阴影的样式*/ a, input { -webkit-tap-highlight-color: rgba(0, 0, 0, 0); } input[type='text'] { -webkit-appearance: none; } 3. 公共样式提取/* 禁止选中文本 */ .usn { -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; -o-user-select: none; user-select: none; } /* 浮动 */ .fl { float: left; } .fr { float: right; } .cf { zoom: 1; } .cf:after { content: '.'; display: block; clear: both; visibility: hidden; height: 0; overflow: hidden; } /* 元素类型 */ .db { display: block; } .dn { display: none; } .di { display: inline; } .dib { display: inline-block; } .transparent { opacity: 0; } /*文字排版、颜色*/ .f12 { font-size: 12px; } .f14 { font-size: 14px; } .f16 { font-size: 16px; } .f18 { font-size: 18px; } .f20 { font-size: 20px; } .fb { font-weight: bold; } .fn { font-weight: normal; } .t2 { text-indent: 2em; } .red, a.red { color: #cc0031; } .darkblue, a.darkblue { color: #039; } .gray, a.gray { color: #878787; } .lh150 { line-height: 150%; } .lh180 { line-height: 180%; } .lh200 { line-height: 200%; } .unl { text-decoration: underline; } .no_unl { text-decoration: none; } .tl { text-align: left; } .tc { text-align: center; } .tr { text-align: right; } .tj { text-align: justify; text-justify: inter-ideograph; } .wn { /* 强制不换行 */ word-wrap: normal; white-space: nowrap; } .wb { /* 强制换行 */ white-space: normal; word-wrap: break-word; word-break: break-all; } .wp { /* 保持空白序列*/ overflow: hidden; text-align: left; white-space: pre-wrap; word-wrap: break-word; word-break: break-all; } .wes { /* 多出部分用省略号表示 , 用于一行 */ overflow: hidden; word-wrap: normal; white-space: nowrap; text-overflow: ellipsis; } .wes-2 { /* 适用于webkit内核和移动端 */ display: -webkit-box; -webkit-box-orient: vertical; -webkit-line-clamp: 2; overflow: hidden; } .wes-3 { display: -webkit-box; -webkit-box-orient: vertical; -webkit-line-clamp: 3; overflow: hidden; } .wes-4 { display: -webkit-box; -webkit-box-orient: vertical; -webkit-line-clamp: 4; overflow: hidden; } /* 溢出样式 */ .ofh { overflow: hidden; } .ofs { overflow: scroll; } .ofa { overflow: auto; } .ofv { overflow: visible; } /* 定位方式 */ .ps { position: static; } .pr { position: relative; zoom: 1; } .pa { position: absolute; } .pf { position: fixed; } /* 垂直对齐方式 */ .vt { vertical-align: top; } .vm { vertical-align: middle; } .vb { vertical-align: bottom; } /* 鼠标样式 */ .csd { cursor: default; } .csp { cursor: pointer; } .csh { cursor: help; } .csm { cursor: move; } /* flex布局 */ .df-sb { display: flex; align-items: center; justify-content: space-between; } .df-sa { display: flex; align-items: center; justify-content: space-around; } /* 垂直居中 */ .df-c { display: flex; align-items: center; justify-content: center; } .tb-c { text-align: center; display: table-cell; vertical-align: middle; } .ts-c { position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); } .ts-mc { position: absolute; left: 0; right: 0; bottom: 0; top: 0; margin: auto; } /* 辅助 */ .mask-fixed-wrapper { width: 100%; height: 100%; position: fixed; left: 0; top: 0; background: rgba(0, 0, 0, 0.65); z-index: 999; } .bg-cover { background-size: cover; background-repeat: no-repeat; background-position: center center; } .bg-cover-all { background-size: 100% 100%; background-repeat: no-repeat; background-position: center center; }","tags":[{"name":"CSS","slug":"CSS","permalink":"http://coder.liusixin.cn/tags/CSS/"},{"name":"样式重置","slug":"样式重置","permalink":"http://coder.liusixin.cn/tags/样式重置/"}]},{"title":"JavaScript高程笔记 （21-25章）","date":"2017-04-23T09:43:24.000Z","path":"posts/41794580/","text":"第 21 章 - Ajax 与 Comet 参考：也可以查看阮一峰 AJAX 学习 Asynchronous Javascript and XML(Ajax),这一技术能够能够向服务器请求额外的数据而不用刷新页面，能够带来更好的用户体验，熟练地使用 XHR 对象是 Web 开发人员必须掌握的一项技能。 学习目标 使用XMLHttpRequest 使用XMLHttpRequest相应的事件 跨域 Ajax 通信的限制 21.1 XMLHttpRequest 对象 XMLHttpRequest对象是使用 Ajax 技术最重要的一个点，最早支持该 api 的浏览器是 IE5，在该浏览器中通过 MSXML 中的一个ActiveX对象实现的，所以在 IE 中也可能会遇到三个不同版本的 XHR 对象，分别是 MSXML2.XMLHttp、MSXML2.XMLHttp.3.0、MSXML2.XMLHttp.6.0。需要兼容的话可以使用下面这个函数。 // 适用于ie7之前的版本 function createXHR() { if (typeof arguments.callee.activeXString != 'string') { var versions = [ 'MSXML2.XMLHttp', 'MSXML2.XMLhttp.3.0', 'MSXML2.XMLhttp.6.0' ]; for (var i = 0, len = versions.length; i &lt; len; i++) { try { new ActiveXObject(versions[i]); arguments.callee.activeXString = versions[i]; break; } catch (e) { // 跳过 } } } return new ActiveXObject(arguments.callee.activeXString); } 当然如果我们只想支持 ie7 以及更高版本的浏览器只需要像下面这样使用构造函数 var xhr = new XMLHttpRequest(); 如果必须支持 ie7 以下的版本，稍微改造下前面的 createXHR 函数即可 function createXHR() { if (typeof XMLHttpRequest != 'undefined') { return new XMLHttpRequest(); } else if (typeof arguments.callee.activeXString != 'string') { console.log('进了arguments.callee.activeXString'); var versions = [ 'MSXML2.XMLHttp', 'MSXML2.XMLhttp.3.0', 'MSXML2.XMLhttp.6.0' ]; for (var i = 0, len = versions.length; i &lt; len; i++) { try { // 为什么这里不将实例返回也可以得到XHR对象 console.log(versions[i]); new ActiveXObject(versions[i]); arguments.callee.activeXString = versions[i]; break; } catch (e) { // 跳过 } } console.log('ActiveXObject'); return new ActiveXObject(arguments.callee.activeXString); } else { throw new Error('No XHR object available'); } } 21.1.1 XHR 的用法 上面了解了如何用兼容的方式获取一个 xhr 对象，现在开始学习如何使用，一般大致上可以分为以下三步。 通过onreadystatechange监听请求状态 xhr.open(method, url, true or false) xhr.send() xhr.open(method, url, true or false)的三个参数分别是请求的类型(get、post 等)，请求的 url，以及请求是否设置为异步。 示例 xhr.open('get', 'example.php', false); 特别说明 url 可以是相对路径也可以是绝对路径 调用 open 方法后并不会立即发送一个请求到服务器，只是启动一个请求以备发送。 真正发送请求是从xhr.send()开始 xhr.open('get', 'example.php', false); xhr.send(null); send 方法接收一个参数，即作为请求主体发送的数据，如果不需要发送数据必须传入null,此时请求才真正地被分派至服务器。 当发送的请求接收到响应的时候会自动填充 xhr 对象的相关属性，现在对相关属性介绍如下。 responseText(作为响应主体被返回的文本) status (响应的 http 状态) statusText(http 状态说明) 接收到响应的时候先判断status属性，以判断响应是否完成，一般将 http 状态为 200(304 表示请求的资源没有更改，可以走浏览器缓存)时作为成功的标志。 所以可以如下写法检查请求的状态 xhr.open('get', 'example.php', false); xhr.send(null); if ((xhr.status >= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status === 304) { // 成功 alert(xhr.responseText); } else { alert('request was unsuccessful' + xhr.status); } 像上面那样发送的是同步请求，大多数情况下我们发送的还是异步请求以不阻塞 js 继续执行，这个时候可以监测 xhr 对象的readyState属性,该属性表示请求/响应过程属于哪一个阶段。总共有以下几个阶段 0 : 未初始化，还没有调用 open()方法 1 : 启动，已经吊用 open()方法但是还没有调用 send()方法 2 : 发送，已经调用 send()方法，但是尚未接收到响应 3 : 接收，已经接收到部分数据 4 : 完成，已经接收到全部数据，而且已经可以在客户端使用了。 通常readyState由一个值切换到另一个值都会触发onreadystatechange事件，通常我们只对为 4 的情况感兴趣，因为只有这个时候响应的数据是完整的。 let xhr = createXHR(); xhr.onreadystatechange = function() { if (xhr.readyState === 4) { if ((xhr.status >= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status === 304) { // 成功 alert(xhr.responseText); } else { // 失败 } } }; xhr.open('get', 'example.php', true); xhr.send(null); 另外既然可以发送请求，我们也可以终止请求，调用xhr.abort() 法方法，xhr 对象将会停止触发事件，此时也应该对 xhr 对象解除引用操作 21.1.2 http 头部信息 每个 http 的请求和响应都会带有响应的头部信息，xhr 对象提供了操作这两种头部(请求头部和响应头部)信息的方法。 Accept : 浏览器能够处理的内容类型 Accept-charset : 浏览器能够显示的字符集 Accept-Encoding : 浏览器能够处理的压缩编码 Accept-Language : 浏览器当前设置的语言 Connection : 浏览器与服务器之间的连接类型 Cookie : 当前页面设置的任何 cookie Host : 发出的请求所在的域 Referer : 发出请求的页面 URI (特别注意：这个单词正确拼写应该是 referrer,但是 HTTP 规范把单词拼错了，也只能将错就错了) 可以使用xhr.setRequestHeader来设置自定义的请求头部信息 该方法接收两个参数，即头部字段的名称和头部字段的值。 如果要成功的发送请求头部信息，必须在调用 open 方法之后并且调用 send 方法之前调用setRequesHeader方法，比如 var xhr = createXHR(); xhr.onreadystatechange = function() { if (xhr.readyState === 4) { if ((xhr.status >= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status === 304) { console.log(xhr.responseText); } } }; xhr.open('get', 'example', true); xhr.setRequestHeader('name', 'liusixin'); xhr.send(null); 服务端在接收到这种自定义的头部信息之后，可以执行响应的后续操作，建议不要修改浏览器默认的头部相关字段。 我们也可以调用xhr.getResponseHeader()，并传入一个头部字段的名称即可获取响应的头部信息，而调用xhr.getAllResponseHeaders()则可以获取包含所有头部信息的长字符串。 var myHeader = xhr.getResponseHeader('myHeader'); var allHeaders = xhr.getAllResponseHeaders(); 当然了客户端在发起请求的时候可以自定义请求头部信息，服务端同样可以返回客户端一些自定义的头部信息。 21.1.3 GET 请求 GET 是最常见的请求类型，最常用于向服务器查询某些信息，将查询字符串跟在 url 的后面，以便将信息发送给服务器。，对于 XHR 而言传入 open 方法的 url 后的查询字符串，必须经过正确的编码（即名和值都必须使用encodeURIComponent()进行处理）才行。 function addURLParam(url, name, value) { url += url.indexOf('?') === -1 ? '?' : '&amp;'; url += encodeURIComponent(name) + '=' + encodeURIComponent(value); return url; } 21.1.4 POST 请求 使用频率仅次于 get 的是 post 请求，通常用于向服务器发送应该被保存的数据，post 请求应该将数据作为请求的主体提交而 get 请求传统上不是如此，post 请求可以包含非常多的数据而且格式不限。 默认情况下，服务器对 post 请求和提交的 web 表单请求并不会一视同仁，因此服务器必须有程序来读取发送过来的原始数据，并且解析出有用的部分，不过我们可以用 xhr 来模仿表单提交 模仿表单提交一般有以下两点 将请求头的Content-type设置为application/x-www-form-urlencoded,也就是表单提交的类型 其次以合适的格式创建一个字符串，post 格式与查询字符串的格式相同 function submitData() { var xhr = createXHR(); xhr.onreadystatechange = function() { if (xhr.readyState === 4) { if ((xhr.status >= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status === 304) { alert(xhr.responseText); } else { alert('err'); } } }; xhr.open('post', 'example.php', true); xhr.setRequestHeader('Content-type', 'application/x-www-form-urlencoded'); // 着重点 var form = document.getElementById('user-info'); xhr.send(serialize(form)); // 着重点 } 与 GET 请求相比 POST 请求消耗的资源会更多一些，从性能角度看，发送相同的数据，GET 请求的速度可以达到 POST 请求的 2 倍 21.2 XMLHttpRequest 2 级21.2.1 FormData 现代 Web 应用中频繁使用的一项功能就是表单序列化，XMLHttpRequest 2为此定义了FormData类型，FormData为序列化表单和创建与表单格式相同的数据(用于通过 XHR 传输)提供了便利。 var data = new FormData(); data.append('name', 'liusixin'); 其接收两个参数，数据的健和值，当然也可以直接像 FormData 传入表单 var xhr = createXHR(); xhr.onreadystatechange = function() { if (xhr.readyState === 4) { if ((xhr.status >= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status === 304) { alert(xhr.responseText); } else { alert('err'); } } }; xhr.open('post', 'example.php', true); var form = document.getElementById('user-info'); xhr.send(new FormData(form)); // 着重点 对比上面一个例子我们可以发现，使用 FormData 来传输数据的时候，可以省去设置头部 Content-type，也不必自己序列化表单，可谓方便多了 21.2.2 超时设置overrideMimeType()方法 该方法用于重写 XHR 响应的 MIME 类型，因为返回响应的类型决定了 XHR 对象如何处理它，所以提供一种能够重写服务端返回的 MIME 类型是很有用的。MIME MDN 举个例子：服务器返回的 MIME 类型是text/plain,但是数据中实际包含的是 XML，那么 XHR 根据 MIME 的类型，即使数据是 XML。responseXML属性中仍然是 null，通过调用overrideMimeType方法，可以保证把响应当作 XML 而非穿文本来处理。 var xhr = createXHR(); xhr.open('get', 'text.php', true); xhr.overrideMimeType('text/xml'); xhr.send(null); 注意该方法必须要在 send 方法之前调用，才能保证重写响应的 MIME 类型 21.3 进度事件 Progress Events 定义了客户端与服务器通信有关的事件。 loadStart ： 在接收到响应数据的第一个自己触发 progress ：在接收响应期间持续不断的触发 error ： 在请求发生错误时触发 abort ： 在因为调用 abort()方法而终止连接时触发 load ： 在接收到完整的数据时触发 loadend ： 在通信完成或者触发 error、abort 或 load 事件后触发 着重看load和progress事件 21.3.1 load 事件 load 事件的初衷在于简化异步交互的模型，用以替代readystatechange事件，响应接收完毕将会触发 load 事件，因此也就没有必要检查readyState属性。并且 load 事件处理程序会受到一个 event 对象，target 属性就是指向 xhr 对象的实例，也就可以访问到其所有的属性和方法。 遗憾的是并不是所有的浏览器都实现了适当的事件对象，所以兼容写法还是如下 var xhr = createXHR(); xhr.onload = function() { if ((xhr.status >= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status === 304) { alert(xhr.responseText); } else { alert('Request was unsuccessful'); } }; 21.3.2 progress 事件 该事件会在浏览器接收数据期间周期性的触发。而onprogress的事件处理程序会接收到一个 event 对象，其 target 属性是 XHR 对象，但是包含三个而外的属性 lengthComputable (表示进度信息是否可用) position (表示已经接收的字节数) totalSize (表示根据Content-Length响应头部确定的预期的字节数) 这些属性兼容性问题比较大，谨慎使用 21.4 跨域资源共享21.4.1 IE 对 CORS 的实现21.4.2 其他浏览器对 CORS 的实现21.4.3 Preflighted Request21.4.4 带凭据的请求21.4.5 跨浏览器的 CORS 上面内容可以参考 阮一峰的跨域资源共享 CORS 详解 21.5 其他跨域技术 在 CORS 技术出现之前，解决跨域问题，一般是利用 DOM 中能够执行跨域请求的功能，在不依赖 XHR 对象的情况下也能发送某种请求。 21.5.1 图像 ping 网页中无论从哪个网页中加载图片都不用担心跨域的问题，通过动态的创建图像，使用它们的onload和onerror事件处理程序来确定是否接收到了响应。 图像 ping 是与服务器进行简单、单向的跨域通信的一种方式，请求的数据通过查询字符串形式发送给服务器，而响应可以是任意内容，但通常是像素图或 204 响应，通过图像 ping 浏览器得到不任何数据，但可以通过 onload 和 onerror 事件知晓请求是何时接收到的。 var img = new Image(); img.onload = img.onerror = function() { alert('DONE'); }; img.src = 'www.baidu.com'; 21.5.2 JSONP JSONP(JSON with padding),由两部分组成：回调函数和数据，回调函数是当响应到来的时应该在页面中调用的函数，回调函数的名字一般是在请求中指定的。而数据就是传入回调函数中的 json 数据。 通过动态地创建&lt;script&gt;标签，将其 src 属性指向一个跨域的 url，其实这里的 script 标签和 img 标签类似，都有能力不受限制的跨域加载资源，因为 JSONP 是有效的 JavaScript 代码，所以在请求完成之后，即在 JSONP 响应加载到页面以后，就会立即执行。 function handleResponse(response) { console.log(response); } var script = document.createElement('script'); script.src = 'http://example.php?callback=handleReponse'; document.body.appendChild(script); 第 22 章 - 高级技巧学习目标 使用高级函数 防篡改对象 Yielding Timers 22.1 高级函数22.1.1 安全的类型检测 JavaScript 内置的类型检测并不是完全可靠，发生错误的情况不再少数， 例如typeof操作符噢，由于它有一些无法预知的行为，经常会导致检测数据类型时得不到靠谱的结果。Safari 在对正则表达式应用 typeof 操作符时会返回 function,因此很难判断一个值是否是函数 instanceof 操作符存在全局作用域的情况下，也是问题多多。 let isArray = value instanceof Array; 以上代码要 true,value 必须是一个数组，而且还必须与 Array 构造函数在同一个全局的作用域中（比如 value 是一个页面中的 iframe 定义的，就会返回 false） 解决以上问题的方案是调用Object的toString方法，都会返回一个[object NativeConstructorName]格式的字符串，每个类在内部都有一个[[class]]属性，这个属性中就指定了上述字符串中构造函数的名。 let isArray = value => { return Object.prototype.toString.call(value) === '[object Array]'; }; let isFunction = value => { return Object.prototype.toString.call(value) === '[object Function]'; }; let isRegExp = value => { return Object.prototype.toString.call(value) === '[object RegExp]'; }; 22.1.2 作用域安全的构造函数 构造函数其实就是一个用 new 操作符调用的函数，当使用 new 调用的时候，构造函数内用到的 this 会指向新创建的对象实例。 function Person(name, age, job) { this.name = name; this.age = age; this.job = job; } let p = new Person('liusixin', 26, 'fe'); 当使用 new 操作符调用时会创建一个新的 Person 对象，但是问题就是出现在没有使用 new 的时候，由于 this 是在运行时绑定的，所以直接调用 Person 会映射到全局的 window 对象 作用域安全的构造函数在进行任何更改之前，首先确认 this 对象是正确类型的实例，如果不是，那么会创建新的实例并返回。 function Person(name) { if (!(this instanceof Person)) { return new Person(name); } this.name = name; } let p1 = new Person('liusixin'); let p2 = new Person('hahaha'); 以上代码实现了不管是否使用 new 操作符去调用 Person 函数都会生成一个新的 Person 实例 但是以上模式也有缺陷，比如在使用构造函数的窃取模式来实现继承并且不用原型链，那么这个继承可能会遭到破坏。 function A(name) { if (!(this instanceof A)) { return new A(name); } this.name = name; this.showName = function() { console.log(this.name); }; } function B(name, age) { A.call(this, name); this.age = age; } let b1 = new B('liusixin', 26); b1.name; // undefined 在这段代码中 A 函数的构造函数是安全的，然而 B 函数却不是，新创建一个 B 函数的实例后，应该通过 A.call 来继承 A 的 name 属性，但是由于 A 函数的作用域是安全的，this 并不是 A 函数的实例，所以会创建一个新的 A 对象，B 中的 this 并没有得到增长，同时 A.call(name)返回的值也没有用到，所以 b1 中就不会有 name 属性。 但是构造函数窃取模式使用原型链或者寄生组合模式就可以解决这个问题。举个例子。 function A(name) { if (!(this instanceof A)) { return new A(name); } this.name = name; this.showInfo = function() { console.log(this.name); }; } function B(name, age) { A.call(this, name); this.age = age; this.showAge = function() { console.log(this.age); }; } B.prototype = new A(); let b2 = new B('liusixin', 1); b2.name; // liusixin 22.1.3 惰性载入函数22.1.4 函数绑定22.1.5 函数柯里化22.2 防止篡改对象第 23 章 - 离线应用与客户端存储学习目标 进行离线检测 使用离线缓存 在浏览器中保存数据 23.3 数据存储 随着 Web 应用程序的出现，也产生了对于能够直接在客户端上存储用户信息能力的要求。属于某个特定用户的信息应该存在该用户的机器上，无论是登录信息还是偏好设置或者其他数据。 解决该问题的第一个方案是以 cookie 的形式出现的，cookie 只是在客户端存储数据的其中一种选项。 Cookie HTTP Cookie 通常叫做 cookie，最初是在客户端用于存储会话信息的。该标准要求服务器对任意的 http 请求发送 Set-Cookie HTTP 头作为响应的一部分，其中包含会话信息，例如这种服务器响应的头可能如下。 cookie 以名值对存在，并且名称和值都必须是 URL 编码的，浏览器会存储这样的会话信息，并在这之后，通过为每个请求添加 Cookie HTTP 头将信息发送回服务器。 第 25 章 - 新兴的 API学习目标 创建平滑的动画 操作文件 使用 Web Workers 在后台执行 JavaScript 25.4 File API 不能直接访问用户计算机中的文件，一直都是 web 应用开发中的一大障碍，2000 年以前，处理文件唯一的方式就是在表单中加入字段，仅此而已，File API 的宗旨是为 Web 开发人员开提供一种安全的的方式，以便在客户端访问用户计算机中的文件，并更好地对这些文件进行操作。 File API 在表单的文件字段的基础上又添加了一些直接访问文件信息的接口，HTML5 中在 DOM 中为文件输入元素添加了一个 files 集合，在通过文件输入字段选择了一或多个文件时，files 集合中将包含一组 File 对象，每个 File 对象对应一个文件，每个 File 对象下面都有下列的只读属性。 name: 本地文件系统中的文件名 size: 文件的字节大小 type: 字符串，文件的 MIME 类型 lastModifiedDate: 字符串，文件上一次被修改的时间（只有 Chrome 实现了这个属性） 文件信息获取示例 &lt;input type=\"file\" class=\"files\" multiple> let $files = document.querySelector('.files'); $files.addEventListener( 'change', e => { let target, files; e = e || event; target = e.target || e.srcElement; files = target.files; Array.from(files).forEach((file, i) => { console.table(file); }); }, false ); 25.4.1 FileReader 类型 FileReader 类型实现的是一种异步文件读取机制，可以把 FileReader 想象成 XMLHttpRequest，区别只是它读取的是文件系统，而不是远程服务器。问了读取文件中的数据，FileReader 提供了以下几个方法。 readAsText(file, encoding)： 以纯文本形式读取文件，将读取到的文本保存在 result 属性中 readAsDataURL(file): 读取文件并将文件以数据 URI 的形式保存在 result 属性中。 readAsBinaryString(file): 读取文件并将一个字符串保存在 result 属性中，字符串中的每个字符表示一个字节。 readArrayBuffer(file): 读取文件并将一个包含文件内容的 ArrayBuffer 保存在 result 属性中。 由于读取文件的过程是异步的，因为 FileReader 也提供了几个事件，其中最有用的三个事件是progress，error，load，分别表示是否又读取了数据，是否发生错误以及是否已经读完了整个文件 每隔 50ms 左右，就会触发一次progress事件，通过事件对象可以获得与 XHR 的 progress 事件相同的信息。lengthComputed,loaded,total,另外尽管可能没有包含全部数据但是每次 progress 事件中都可以通过 FileReader 的 result 属性读取到文件内容。 由于种种原因无法读取文件，就会触发 error 事件，触发 error 事件时，相关的信息将会保存到 FileReader 的 error 属性中，这个属性中将保存一个对象，该对象只有一个属性 code，即错误码，这个错误码是 1：表示未找到文件 2：表示安全性错误 3：表示读取中断 4：表示文件不可读 5：表示编码错误 件成功加载后会触发 load 事件，如果发生了 error 事件就不会触发 load 事件。 25.4.2 读取部分内容 有时候，我们只想读取文件的一部分内容而不是全部内容，为此，File 对象还支持一个 slice 方法，这个方法在 Firefox 中叫 mozSlice，在 chrome 中叫做 webkitSlice，其接受两个参数，起始字节，以及要读取的字节数。这个方法返回一个 Blob 的实例，Blob 是 File 类型的父类型。下面是一个兼容的方法 function blobSlice(blob, startByte, length) { if (blob.slice) { return blob.slice(startByte, length); } else if (blob.webkitSlice) { return blob.webkitSlice(startByte, length); } else if (blob.mozSlice) { return blob.mozSlice(startByte, length); } else { return null; } } 25.4.3 对象 URL25.4.4 读取拖放的文件 围绕文件信息，结合使用的 HTML5 API 和文件 API，可以做出很赞的东西来。与拖放一张图片或者一个链接类似，从桌面上把文件拖放到浏览器中也会触发 drop 事件，而且可以在 event.dataTransfer.files 中读取到被放置的文件，当然此时他是一个 File 对象，与通过文件输入字段取得的 File 对象一样 25.6 Web Workers 随着 Web 应用复杂性的与日俱增，越来越复杂的计算在所难免，长时间运行的 JavaScript 进行会导致浏览器冻结用户界面，让人感觉屏幕“冻结”了，Web Workers 规范通过让 JavaScript 在后台运行解决了这个问题，浏览器实现 Web Worker 的方式有很多种，可以使用线程，后台进程或者运行在其他处理器上的进程，等等。怎么实现细节其实没有那么重要，重要的是开发人员现在可以放心地运行 JavaScript 而不必担心影响用户体验了。","tags":[{"name":"javascript","slug":"javascript","permalink":"http://coder.liusixin.cn/tags/javascript/"},{"name":"编程笔记","slug":"编程笔记","permalink":"http://coder.liusixin.cn/tags/编程笔记/"},{"name":"javascript高级程序设计","slug":"javascript高级程序设计","permalink":"http://coder.liusixin.cn/tags/javascript高级程序设计/"}]},{"title":"JavaScript高程笔记 （15 - 20章）","date":"2017-04-21T13:42:00.000Z","path":"posts/afdba259/","text":"第 15 章 - 使用 canvas 绘图学习目标 理解元素 绘制简单的 2d 图形 使用 WebGL 绘制 3D 图形 15.1 基本用法 使用 canvas 元素，需要先设置其 width 和 height，指定可以绘图的大小，出现在开始和结束标签中的内容是后备信息，如果浏览器不支持 canvas 元素就会显示这些信息。 &lt;canvas id=\"drawing\" width=\"200\" height=\"200\">&lt;/canvas> 与其他元素一样，canvas 对象的 DOM 元素也有 width 和 height 属性，可以随意修改，而且也可以通过 css 为该元素添加样式(与直接在 html 指定 width 和 height 有什么不同呢)，如果不添加任何样式或者不绘制图形，在页面中是看不到该元素的。 要在这块画布上绘图，需要取得绘图上下文。并通过getContext()方法传入上下文的名字 2d。 let drawing = document.getElementById('drawing'); // 如果确定支持canvas元素 if (drawing.getContext) { let ctx = drawing.getContext(); } 如上代码，在使用canvas元素之前需要先检测getContext方法是否存在，在有些浏览器中会 HTML 规范之外的元素创建默认的 HTML 元素对象，在这种情况中，虽然保存着一个有效的元素引用，也检测不到getContext方法。 使用toDataURL方法，可以导出在 canvas 元素上绘制的图像，这个方法接收一个参数，即图像的MIME类型格式，而且适合用于创建图像的任何上下文，比如，要取得画布中的一幅PNG格式的图像，可以使用以下代码。 let drawing = document.getElementById('drawing'); if (drawing.getContext) { let imgURL = drawing.toDataURL('image/png'); let image = document.createElement('img'); image.src = imgURL; document.body.appendChild(image); } 注意： 如果绘制到画布上的图像源自不同的域，toDataURL 方法会抛出错误 15.2 2d 上下文 使用 2D 绘图上下文提供的方法，可以绘制简单的 2D 图形，比如矩形，弧线和路径。2D 上下文的坐标开始于 canvas 元素的左上角，原点是(0, 0)，所有的坐标值都基于这个原点计算，x 值越大表示跃靠右，y 值越大表示越靠下，默认情况下，width 和 height 表示水平和垂直方向上可用的像素数目。 15.2.1 填充和描边 2D 上下文的两种基本绘图操作是填充和描边，填充即使用指定的样式（颜色，渐变，或图像）填充图形，描边就是只在图形的边缘画线。大多数 2D 上下文操作都会细分为填充和描边两个操作，而操作的结果取决于两个属性，fillStyle 和 strokeStyle 需要注意的是这两个属性的值都可以是字符串，渐变对象或模式对象，而且默认的值都是“#000000”，如果为他们指定表示颜色的字符串，可以使用 css 中指定颜色值的任何格式，包括颜色名，十六进制码，rgb，rgba，hsl 和 hsla 下面是一个简单的例子 let $drawing = document.getElementById('drawing'); let ctx = $drawing.getContext &amp;&amp; $drawing.getContext(); if (ctx) { ctx.strokeStyle = 'red'; ctx.fillStyle = '#0000ff'; } 所有涉及描边和填充的操作都将使用这两个样式，直至重新设置这两个值，这两个属性的值也可以是渐变对象和模式对象。 15.2.2 绘制矩形 矩形是唯一一种可以直接到 2D 的上下文中绘制的形状，与矩形有关的方法包括fillRect,strokeRect,clearRect这三个方法都可以接受 4 个参数，矩形的 x 坐标，矩形的 y 坐标，矩形的宽度和句型的高度。这些参数的单位都是像素。 fillRect方法在画布上绘制的矩形会填充指定的颜色，填充的颜色通过fillStyle属性指定。比如： let $drawing = document.getElementById('drawing'); let ctx = $drawing.getContext &amp;&amp; $drawing.getContext(); if (ctx) { // 绘制红色的矩形 ctx.fillStyle = '#ff0000'; ctx.fillRect(10, 10, 50, 50); // 绘制半透明的矩形 ctx.fillStyle = 'rgba(0, 0, 255, 0.5)'; ctx.fillRect(30, 30, 50, 50); } 以上代码先将 fillStyle 设置为红色，然后从（10， 10）处开始绘制矩形，矩形的宽度和高度均为 50 像素，然后通过 rgba 格式将 fillStyle 设置为半透明的颜色，在第一个矩形上面绘制的第二矩形，结果就是可以透过蓝色的矩形看到红色的矩形。 strokeRect strokeRect 方法在画布上绘制的矩形会使用指定的颜色描边，描边的颜色通过 strokeStyle 指定。 let $drawing = document.getElementById('drawing'); let ctx = $drawing.getContext &amp;&amp; $drawing.getContext(); if (ctx) { // 绘制红色的矩形 ctx.fillStyle = '#ff0000'; ctx.strokeRect(10, 10, 50, 50); // 绘制半透明的矩形 ctx.fillStyle = 'rgba(0, 0, 255, 0.5)'; ctx.strokeRect(30, 30, 50, 50); } 以上代码绘制了两个重叠的矩形，不过这两个矩形都只有框线，内部没有填充颜色。 15.2.3 绘制路径 2D 绘制上下文支持很多在画布上绘制路径的方法，通过路径可以创造出复杂的形状和线条。要绘制路径，首先必须调用beginPath()方法，表示要开始绘制新的路径，然后再通过调用以下方法来实际地绘制路径。 arc(x, y, radius, startAngle, endAngle, counterclockwise)： 以(x, y)为圆心绘制一条弧线，弧线的半径为 radius，起始角度和结束角度（用弧度表示）分别为startAngle和endAngle，最后一个参数表示是否按照逆时针方向计算，值为 false 表示按顺时针计算。 arcTo(x1, y1, x2, y2, radius)：从上一点开始绘制一条弧线，到(x2, y2)并且以给定的半径 radius 穿过(x1, y1) bezierCurveTo(c1x, c1y, c2x, c2y, x, y)： 从上一点开始绘制一条曲线，到(x, y)位置，并且以（c1x, c1y）和（c2x, c2y）为控制点。 lineTo(x, y): 从上一点开始绘制一条直线，直到(x, y)为止。 moveTo(x, y): 将绘图游标移动到(x, y)，不画线。 quadraticCurveTo(cx, cy, x, y): 从上一点开始绘制一条二次曲线，到(x, y)为止。并且以(cx, cy)为控制点。 rect(c, y, width, height), 从点(x, y)开始绘制一个矩形，宽度和高度由 width 和 height 指定，这个方法绘制的是矩形路径，而不是strokeRect和fillRect所绘制的独立矩形形状。 创立了路径后，接下来有几种可能的选择，如果要绘制一条连接到起点的线条，可以调用closePath(),如果路径已经完成，你想用fillStyle填充他，可以调用fill(),另外，还可以调用stroke()方法对路径描边，描边使用的是strokeStyle，最后还可以调用clip，这个方法可以在路径上创建一个剪切区域。 接下来我们要绘制一个不带数字的时钟表盘。 let $drawing = document.getElementById('drawing'); let ctx = $drawing.getContext &amp;&amp; $drawing.getContext('2d'); if (ctx) { ctx.beginPath(); ctx.arc(100, 100, 100, 0, 2 * Math.PI, false); ctx.moveTo(190, 100); // 防止画出多余的线 ctx.arc(100, 100, 90, 0, 2 * Math.PI, false); ctx.moveTo(100, 100); ctx.lineTo(100, 20); ctx.moveTo(100, 100); ctx.lineTo(40, 100); ctx.stroke(); } 15.2.4 绘制文本 2d 绘图上下文也提供了绘制文本的方法，绘制文本主要有两个方法：fillText()和strokeText()。这两个方法都可以接受 4 个参数，要绘制的文本字符串，x 坐标，y 坐标和可选的最大像素宽度。而且这两个方法都以下列 3 个属性为基础。 font: 表示文本样式，大小，以及字体，用 css 中指定的字体格式来指定例如： &quot;10px Arial&quot; textAlign: 表示文本对齐方式，可能的值有“start”， “end”，“left”，“right”， “center”，建议使用“start”， “end”，不适用“left”，“right”，因为前者的意思更稳妥，能同时适合从左到右，和从右到左的语言。 textBaseline： 表示文本的基线，可能的值有“top”， “hanging”， “middle”， “alphabetic”， “ideographic”，“bottom” 这几个属性都有默认值，因此没有必要每次使用它们都重新设置一遍值，fillText()方法使用fillStyle属性绘制文本，strokeText使用strokeStyle属性为文本描边，相对来说，还是使用fillText的时候更多，因为该方法模仿了在网页中正常显示文本。 接下来我们接着上面的例子绘制数字。 ctx.font = 'bold 14px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText('12', 100, 20); ctx.textAlign = 'start'; ctx.fillText('12', 100, 40); ctx.textAlign = 'end'; ctx.fillText('12', 100, 60); 注意：将textAlign设置为“center”，把textBaseline设置为“middle”，所以坐标为(100, 20)表示的是文本水平和垂直重点的坐标，如果将textAlign设置为“start”，则 x 坐标表示的是文本左端的位置（从左到右的语言），设置为“end”，则 x 坐标表示的是文本右端的位置. measureText 当需要将文本控制在某一区域中的时候，2D 上下文提供了辅助确定文本大小的方法measureText(),这个方法接收一个参数，即要回执的文本，返回一个textMetrics对象，返回的对象只有一个width属性，并且该方法是利用font，textAlign和textBaseline的当前值计算指定的文本的大小。比如，假设你想在一个 140 像素宽的矩形区域中绘制文本，Hello world！下面的代码从 100 像素的字体大小开始递减，最终会找到合适的字体大小。 let fontSize = 100; let fontStr = 'Hello world'; if (ctx) { ctx.textAlign = 'start'; ctx.textBaseline = 'middle'; ctx.font = `${fontSize}px Arial`; while (ctx.measureText(fontStr).width > 60) { fontSize--; ctx.font = `${fontSize}px Arial`; } ctx.fillText(fontStr, 10, 10); ctx.fillText(`Font size is ${fontSize}px`, 10, 50); } 15.2.5 变换 省略… 第 16 章 - HTML5 脚本编程学习目标 使用跨文档消息传递 拖放 API 音频与视频 16.1 跨文档消息传递 跨文档消息传送（cross-document-messaging），有时候简称为 XDM，指的是在来自不同域的页面间传递消息。例如www.wrox.com域中的页面与位于一个内嵌框架中的p2p.wrox.com域中的页面通信。 XDM 的核心是postMessage方法，在 HTML5 中除了 XDM 部分之外的其他部分也会提到这个方法名，但都是为了同一个目的：向另一个地方传递数据，对于 XDM 而言，“另一个地方”指的是包含在当前页面中的&lt;iframe&gt;或者由当前页面弹出的窗口 postMessage方法接收两个参数，一条消息和一个表示消息接收方来自哪个域的字符串。第二个参数对保障安全通信非常重要，可以防止浏览器把消息发送到不安全的地方。来看下面的例子 let iframeWindow = document.getElementById('myframe').contentWindow; iframeWindow.postMessage('A secret', 'http://www.wrox.com'); 如果postMessage的第二个参数是&#39;*&#39;，则可以把消息发送给来自任何域的文档，但是我们不推荐这样做。 接收到 XDM 消息的时候会触发 window 对象的message事件，这个事件是以异步形式触发的，因此从发送消息到接收消息（触发窗口的message事件）可能要经过一段时间的延迟。触发message事件之后，传递给onmessage处理程序的事件包含以下三方面的信息。 data：作为 postMessage 第一个参数传入的字符串参数 origin：发送消息的文档所在的域，例如&quot;http://www.wrox.com&quot; source: 发送消息的文档的 window 对象的代理，这个代理对象主要用于发送一条消息的窗口中调用 postMessage 方法，如果发送消息的窗口来自同一个域，那么这个对象就是 window。 特别注意 event.source大多数情况下只是 window 对象的代理，并非是实际的 window 对象，换句话说，不能通过这个代理对象拿到 window 对象的其他任何信息，记住，只通过这个代理调用postMessage就好，这个方法永远存在。 XDM 还有一些怪异之处，首先就是postMessage的第一个参数最早是作为“永远都是字符串”来实现的，但是后来这个参数定义改了，改成允许传入任何数据结构，可是并非所有的浏览器都实现了这一变化，为了保险起见，使用postMessage时，最好还是只传字符串，如果要传结构化后的数据，最佳选择是现在要传入的数据上调用JSON.stringfy,通过postMessage传入得到的字符串，然后再在onmessage事件处理程序中调用JSON.parse 16.2 原生拖放 HTML5 以 IE 的实例为基础制定了拖放规范。Firefox 3.5、Safari 3+和 Chrome 也根据 HTML5 规范实现了原生拖放功能。 16.2.1 拖放事件 通过拖放事件，可以控制拖放相关的各个方面。其中最关键的地方在于确定哪里发生了拖放事件，有些事件是在被拖动的元素上触发的，而有些事件是在放置目标上触发的。拖动某元素时，将依次触发下列事件： dragstart drag dragend 按下鼠标键并开始移动鼠标时，会在被拖放的元素上触发dragstart事件。拖动开始时，可以通过ondragstart事件处理程序来运行 JavaScript 代码。 触发dragstart事件后，随即会触发drag事件，而且在元素被拖动期间会持续触发该事件。这个事件与mousemove事件相似。当拖动停止时（无论是把元素放到了有效的放置目标，还是放到了无效的放置目标上），会触发dragend事件。 当某个元素被拖动到一个有效的放置目标上时，下列事件会依次发生： dragenter dragover dragleave 或 drop 元素被拖动到放置目标上，会触发dragenter事件（类似于mouseover事件）。其后是dragover事件，如果元素被拖出了放置目标，dragover事件不再发生，但会触发dragleave事件（类似于mouseout事件）。如果元素被放到了放置目标中，则会触发drop事件而不是dragleave事件。上述三个事件的目标都是作为放置目标的元素。 16.2.2 自定义放置目标如果拖动元素经过不允许放置的元素，无论用户如何操作，都不会发生 drop 事件。不过，你可以把任何元素变成有效的放置目标，方法是重写dragenter和dragover事件的默认行为。例如，假设有一个 ID 为”droptarget”的元素，可以用如下代码将它变成一个放置目标。 var droptarget = document.getElementById('droptarget'); EventUtil.addHandler(droptarget, 'dragover', function(event) { EventUtil.preventDefault(event); }); EventUtil.addHandler(droptarget, 'dragenter', function(event) { EventUtil.preventDefault(event); }); 以上代码执行后，你就会发现当拖动着元素移动到放置目标上时，光标变成了允许放置的符号。当然，释放鼠标也会触发 drop 事件。 16.2.3 dataTransfer 对象 它是事件对象的一个属性，用于从被拖动元素向放置目标传递字符串格式的数据。在事件处理程序中，可以使用这个对象的属性和方法来完善拖放功能。 dataTransfer 对象有两个主要方法： getData() - 取得由 setData()保存的值 setData() - 方法的第一个参数，也是getData()方法唯一的一个参数，是一个字符串，表示保存的数据类型，取值为”text”或”URL” //设置和接收文本数据 event.dataTransfer.setData('text', 'some text'); var text = event.dataTransfer.getData('text'); //设置和接收URL event.dataTransfer.setData('URL', 'http://www.wrox.com/'); var url = event.dataTransfer.getData('URL'); HTML5 支持&quot;text&quot;和&quot;URL&quot;，但这两种类型会被映射为&quot;text/plain&quot;和&quot;text/uri-list&quot;。 16.2.4 dropEffect 与 effectAllowed 利用 dataTransfer 对象，通过它来确定被拖动的元素以及作为放置目标的元素能够接收什么操作。为此，需要访问dataTransfer对象的两个属性：dropEffect和effectAllowed。 dropEffect &quot;none&quot;：不能把拖动的元素放在这里。这是除文本框之外所有元素的默认值。 &quot;move&quot;：应该把拖动的元素移动到放置目标。 &quot;copy&quot;：应该把拖动的元素复制到放置目标。 &quot;link&quot;：表示放置目标会打开拖动的元素（但拖动的元素必须是一个链接，有 URL）。 要使用 dropEffect 属性，必须在ondragenter事件处理程序中针对放置目标来设置它。 16.3 媒体元素 HTML5 新增了两个与媒体相关的标签，让开发人员不必依赖任何插件就能在网页中嵌入跨浏览器的音频和视频内容。这两个标签就是&lt;audio&gt;和&lt;video&gt;。 &lt;!-- 嵌入视频 --> &lt;video src=\"conference.mpg\" id=\"myVideo\">Video player not available.&lt;/video> &lt;!-- 嵌入音频 --> &lt;audio src=\"song.mp3\" id=\"myAudio\">Audio player not available.&lt;/audio> 使用这两个元素时，至少要在标签中包含src属性，指向要加载的媒体文件。还可以设置 width 和 height 属性以指定视频播放器的大小，而为poster属性指定图像的 URI 可以在加载视频内容期间显示一幅图像。另外，如果标签中有controls属性，则意味着浏览器应该显示 UI 控件，以便用户直接操作媒体。位于开始和结束标签之间的任何内容都将作为后备内容，在浏览器不支持这两个媒体元素的情况下显示。 因为并非所有浏览器都支持所有媒体格式，所以可以指定多个不同的媒体来源。为此，不用在标签中指定 src 属性，而是要像下面这样使用一或多个&lt;source&gt;元素。 &lt;!-- 嵌入视频 --> &lt;video id=\"myVideo\"> &lt;source src=\"conference.webm\" type=\"video/webm; codecs='vp8, vorbis'\"> &lt;source src=\"conference.ogv\" type=\"video/ogg; codecs='theora, vorbis'\"> &lt;source src=\"conference.mpg\"> Video player not available. &lt;/video> &lt;!-- 嵌入音频 --> &lt;audio id=\"myAudio\"> &lt;source src=\"song.ogg\" type=\"audio/ogg\"> &lt;source src=\"song.mp3\" type=\"audio/mpeg\"> Audio player not available. &lt;/audio> 16.3.1 属性 属 性 数据类型 说 明 autoplay 布尔值 取得或设置 autoplay 标志 buffered 时间范围 表示已下载的缓冲的时间范围的对象 bufferedBytes 字节范围 表示已下载的缓冲的字节范围的对象 bufferingRate 整数 下载过程中每秒钟平均接收到的位数 bufferingThrottled 布尔值 表示浏览器是否对缓冲进行了节流 controls 布尔值 取得或设置 controls 属性，用于显示或隐藏浏览器内置的控件 currentLoop 整数 媒体文件已经循环的次数 currentSrc 字符串 当前播放的媒体文件的 URL currentTime 浮点数 已经播放的秒数 defaultPlaybackRate 浮点数 取得或设置默认的播放速度。默认值为 1.0 秒 duration 浮点数 媒体的总播放时间（秒数） ended 布尔值 表示媒体文件是否播放完成 loop 布尔值 取得或设置媒体文件在播放完成后是否再从头开始播放 muted 布尔值 取得或设置媒体文件是否静音 networkState 整数 表示当前媒体的网络连接状态：0 表示空，1 表示正在加载，2 表示正在加载元数据，3 表示已经加载了第一帧，4 表示加载完成 paused 布尔值 表示播放器是否暂停 playbackRate 浮点数 取得或设置当前的播放速度。用户可以改变这个值，让媒体播放速度变快或变慢，这与 defaultPlaybackRate 只能由开发人员修改的 defaultPlaybackRate 不同 played 时间范围 到目前为止已经播放的时间范围 readyState 整数 表示媒体是否已经就绪（可以播放了）。0 表示数据不可用，1 表示可以显示当前帧，2 表示可以开始播放，3 表示媒体可以从头到尾播放 seekable 时间范围 可以搜索的时间范围 seeking 布尔值 表示播放器是否正移动到媒体文件中的新位置 src 字符串 媒体文件的来源。任何时候都可以重写这个属性 start 浮点数 取得或设置媒体文件中开始播放的位置，以秒表示 totalBytes 整数 当前资源所需的总字节数 videoHeight 整数 返回视频（不一定是元素）的高度。只适用于&lt;video&gt; videoWidth 整数 返回视频（不一定是元素）的宽度。只适用于&lt;video&gt; volume 浮点数 取得或设置当前音量，值为 0.0 到 1.0 16.3.2 事件 事 件 触发时机 abort 下载中断 canplay 可以播放时；readyState 值为 2 canplaythrough 播放可继续，而且应该不会中断；readyState 值为 3 canshowcurrentframe 当前帧已经下载完成；readyState 值为 1 dataunavailable 因为没有数据而不能播放；readyState 值为 0 durationchange duration 属性的值改变 emptied 网络连接关闭 empty 发生错误阻止了媒体下载 ended 媒体已播放到末尾，播放停止 error 下载期间发生网络错误 load 所有媒体已加载完成。这个事件可能会被废弃，建议使用 canplaythrough loadeddata 媒体的第一帧已加载完成 loadedmetadata 媒体的元数据已加载完成 loadstart 下载已开始 pause 播放已暂停 play 媒体已接收到指令开始播放 playing 媒体已实际开始播放 progress 正在下载 ratechange 播放媒体的速度改变 seeked 搜索结束 seeking 正移动到新位置 stalled 浏览器尝试下载，但未接收到数据 timeupdate currentTime 被以不合理或意外的方式更新 volumechange volume 属性值或 muted 属性值已改变 waiting 播放暂停，等待下载更多数据 16.3.3 自定义媒体播放器 使用&lt;audio&gt;和&lt;video&gt;元素的play()和pause()方法，可以手工控制媒体文件的播放。组合使用属性、事件和这两个方法，很容易创建一个自定义的媒体播放器，如下面的例子所示。 &lt;div class=\"mediaplayer\"> &lt;div class=\"video\"> &lt;video id=\"player\" src=\"movie.mov\" poster=\"mymovie.jpg\" width=\"300\" height=\"200\"> Video player not available. &lt;/video> &lt;/div> &lt;div class=\"controls\"> &lt;input type=\"button\" value=\"Play\" id=\"video-btn\"> &lt;span id=\"curtime\">0&lt;/span>/&lt;span id=\"duration\">0&lt;/span> &lt;/div> &lt;/div> //取得元素的引用 var player = document.getElementById('player'), btn = document.getElementById('video-btn'), curtime = document.getElementById('curtime'), duration = document.getElementById('duration'); //更新播放时间 duration.innerHTML = player.duration; //为按钮添加事件处理程序 EventUtil.addHandler(btn, 'click', function(event) { if (player.paused) { player.play(); btn.value = 'Pause'; } else { player.pause(); btn.value = 'Play'; } }); //定时更新当前时间 setInterval(function() { curtime.innerHTML = player.currentTime; }, 250); 16.4 历史状态管理 HTML5 通过更新 history 对象为管理历史状态提供了方便。 hashchange 通过hashchange事件，可以知道 URL 的参数什么时候发生了变化，即什么时候该有所反应。而通过状态管理 API，能够在不加载新页面的情况下改变浏览器的 URL。为此，需要使用history.pushState()方法，该方法可以接收三个参数：状态对象、新状态的标题和可选的相对URL。 history.pushState({ name: 'Nicholas' }, \"Nicholas' page\", 'nicholas.html'); 按下“后退”按钮，会触发 window 对象的 popstate 事件 1。popstate 事件的事件对象有一个 state 属性，这个属性就包含着当初以第一个参数传递给pushState()的状态对象。 EventUtil.addHandler(window, 'popstate', function(event) { var state = event.state; if (state) { //第一个页面加载时state为空 processState(state); } }); 要更新当前状态，可以调用replaceState()，传入的参数与pushState()的前两个参数相同。调用这个方法不会在历史状态栈中创建新状态，只会重写当前状态。 history.replaceState({ name: 'Greg' }, \"Greg's page\"); 第 17 章 - 错误处理与调试学习目标 理解浏览器报告的错误 处理错误 调试 JavaScript 代码 17.2 错误处理17.2.1 try-catch 语句try { window.someNonexistentFunction(); } catch (error) { alert(error.message); } finally 子句 finally 子句一经使用，其代码无论如何都会执行。换句话说，try 语句块中的代码全部正常执行，finally 子句会执行；如果因为出错而执行了 catch 语句块，finally 子句照样还会执行。只要代码中包含 finally 子句，则无论 try 或 catch 语句块中包含什么代码——甚至 return 语句，都不会阻止 finally 子句的执行。 function testFinally() { try { return 2; } catch (error) { return 1; } finally { return 0; } } 这个函数在 try-catch 语句的每一部分都放了一条 return 语句。表面上看，调用这个函数会返回 2，因为返回 2 的 return 语句位于 try 语句块中，而执行该语句又不会出错。可是，由于最后还有一个 finally 子句，结果就会导致该 return 语句被忽略；也就是说，调用这个函数只能返回 0。如果把 finally 子句拿掉，这个函数将返回 2。 第 20 章 - Json学习目标 理解 JSON 语法 解析 JSON 序列化 JSON 为了解决 XML 过于繁琐、冗长、这个问题，涌现了许多解决方案，JSON 就是其中一种，JSON 是 JavaScript 的一个严格的子集，通过一些模式来表示结构化的数据，需要理解的是它是一种数据格式，而不是一种编程语言。虽然具有相同的语法格式，但是 JSON 并不从属于 JavaScript。很多编程语言都有针对 JSON 的解析器和序列化器。 20.2 解析与序列化 stringify() parse() var book = { title: 'Professional JavaScript', authors: ['Nicholas C. Zakas'], edition: 3, year: 2011 }; var jsonText = JSON.stringify(book); 20.2.2 序列化选项过滤结果 如果过滤器参数是数组，那么 JSON.stringify()的结果中将只包含数组中列出的属性。来看下面的例子。 var book = { title: 'Professional JavaScript', authors: ['Nicholas C. Zakas'], edition: 3, year: 2011 }; var jsonText = JSON.stringify(book, ['title', 'edition']); console.log(jsonText); // \"{\"title\":\"Professional JavaScript\",\"edition\":3}\" 如果第二个参数是函数，行为会稍有不同。传入的函数接收两个参数，属性（键）名和属性值。根据属性（键）名可以知道应该如何处理要序列化的对象中的属性。属性名只能是字符串，而在值并非键值对儿结构的值时，键名可以是空字符串。 var book = { title: 'Professional JavaScript', authors: ['Nicholas C. Zakas'], edition: 3, year: 2011 }; var jsonText = JSON.stringify(book, function(key, value) { switch (key) { case 'authors': return value.join(','); case 'year': return 5000; case 'edition': return undefined; default: return value; } }); // \"{\"title\":\"Professional JavaScript\",\"authors\":\"Nicholas C. Zakas\",\"year\":5000}\"","tags":[{"name":"javascript","slug":"javascript","permalink":"http://coder.liusixin.cn/tags/javascript/"},{"name":"编程笔记","slug":"编程笔记","permalink":"http://coder.liusixin.cn/tags/编程笔记/"},{"name":"javascript高级程序设计","slug":"javascript高级程序设计","permalink":"http://coder.liusixin.cn/tags/javascript高级程序设计/"}]},{"title":"JavaScript高程笔记 （13 - 14章）","date":"2017-04-20T12:32:59.000Z","path":"posts/3a262449/","text":"第 13 章 - 事件学习目标 理解事件流 使用事件处理程序 不同的事件类型 JavaScript 与 HTML 之间的交互通过事件实现，事件就是文档或者浏览器窗口中发生的一些特定的交互瞬间。可以使用侦听器（或处理程序）来预订事件，以便事件发生时执行相应的代码，这种在传统软件工程中称为观察员模式，支持页面的行为与页面的外观之间的松散耦合 13.1 事件流 事件流描述的从页面接收事件的顺序，IE 的事件是冒泡流，Netscape 的事件流是事件捕获流。 13.1.1 事件冒泡 IE 的事件流叫做事件冒泡，也就是事件由最具体的元素（文档中嵌套最深的那个节点）接收，然后逐级向上传播到较为不具体的节点。 举例 Document 所有的现代浏览器都支持事件冒泡，但是具体实现上还有一些差别，IE5.5 更在版本中的事件冒泡会跳过 html 元素。IE9，chrome 和 safari 则将事件一直冒泡到 window 对象. 13.1.2 事件捕获Netscape Communicator 团队提出的另一种事件流叫做事件捕获，事件捕获的思想是不太具体的节点应该更早接收到事件，事件捕获的用于在事件到达预定目标之前捕获他。 虽然事件捕获是 Netscape Communicator 唯一支持的事件流模型，但是 IE9、safari 等浏览器都支持这种事件模型，规范要求事件应该从document对象开始传播，但是这些浏览器都是从window开始传播。 13.1.3 DOM 事件流 “DOM2 级事件” 规定的事件流包括三个阶段：事件捕获阶段、处于目标阶段和冒泡阶段。首先发生的是事件捕获，为截获事件提供了机会，然后是实际的目标接收到事件，最后一个阶段是冒泡阶段，可以在这个阶段对事件做出响应。 13.2 事件处理程序 事件就是用户或浏览器自身执行的某种动作，诸如click、load和mouseover，都是事件的名称，响应某个事件的函数叫做事件处理程序（或事件监听器） 为事件指定事件处理程序的方式有很多种，如下 HTML 事件处理程序 元素所支持的每种事件，都可以使用一个与事件同名的HTML特性来指定，该特性的值是能够执行的JavaScript代码，例如 当然也可以调用在页面中其他地方定义的脚本,事件处理程序中的代码在执行时，有权访问全局作用域中的任何代码。 let showMsg = () => { console.log('hello world') } 可以通过 event 变量，直接访问事件对象，不用自己定义，也不用从函数的参数列表读取 在这个函数中 this 等于事件的目标元素 let showMsg = function (val, e) { console.log(val) console.log(e) } hello world HTML 事件处理程序缺点 存在”时差问题”，当用户触发相应的事件时，如果事件处理程序尚不具备执行条件，就会引发错误。（比如上面的script标签中放到页尾） 扩展事件处理程序中的作用域在不同的浏览器中会导致不同的结果。 HTML与JavaScript代码紧密耦合，如果要更换事件处理程序，就要改动两个地方，这也是大家都转向JavaScript指定事件处理程序的原因所在。 13.2.2 DOM0 级事件处理程序 通过 JavaScript 指定事件处理程序的传统方式，就是将一个函数赋值给一个事件处理程序属性。这种方式有以下几个特点。 简单 跨浏览器 每个元素（包括 window 和 document）都有自己的事件处理程序，这些属性通常全部小写，例如 onclick。 &lt;button class=\"btn\">按钮&lt;/button> let btn = document.querySelector('.btn'); btn.onclick = function() { console.log(this.className); }; 需要注意的是，在这些代码运行之前不会指定事件处理程序，因此这些代码在页面中位于按钮后面，就有可能在一段时间内怎么单击都没有反应。 使用 DOM0 级方法指定的事件处理程序被认为是元素的方法，因此这时候的事件处理程序是在元素的作用域中运行，换句话说，程序中的 this 引用当前元素。 1. 以这种方式添加的事件处理程序会在事件流的冒泡阶段被处理 2. 也可以删除通过 DOM0 级方法指定的事件程序，如下 btn.onclick = null; 使用 DOM0 级方法指定的事件处理程序 13.2.3 DOM2 级事件处理程序 “DOM2 级事件”定义了两个方法，分别用于指定和删除事件处理程序：addEventListener、removeEventListener,所有的 DOM 节点都包括这两个方法，并且接受 3 个参数，要处理的事件名，作为事件处理程序的函数和一个布尔值。如果这个布尔值为 true，表示在捕获阶段调用事件处理程序，如果是 false，表示在冒泡阶段调用事件处理程序 let btn = document.querySelector('.btn'); btn.addEventListener( 'click', function() { console.log(this.className); }, false ); 与 DOM0 级方法一样，这里添加的事件处理程序也是在其依附的元素的作用域中运行,但其可以添加多个事件处理函数。并且是按照添加的顺序触发 let btn = document.querySelector('.btn'); btn.addEventListener( 'click', function() { console.log('hello world 1'); }, false ); btn.addEventListener( 'click', function() { console.log('hello world 2'); }, false ); // 打印出 hello world 1, hello world 2 移除事件处理程序 通过 addEventListener 添加的事件处理程序只能使用 removeEventListener 来移除，移除时传入的参数和添加处理程序时使用的参数相同，这也意味着通过其添加的匿名函数将无法移除。 const handleClick = () => { console.log('hello world 3'); }; btn.addEventListener('click', handleClick, false); btn.removeEventListener('click', handleClick, false); // 移除的时候需要和添加的时候参数保持一致,匿名函数无法移除 如果不是特别需要，不建议在捕获阶段注册事件处理程序 13.2.4 IE 事件处理程序 IE 实现了与 DOM 中类似的两个方法，attachEvent, detachEvent。接受相同的参数，事件名称和事件处理程序函数。 attachEvent() - 添加事件 detachEvent() - 移除事件 let $btn = document.querySelector('button'); const handle = function() { console.log('1'); }; const handle2 = function() { console.log('2'); }; // 添加事件 $btn.attachEvent('onclick', handle); $btn.attachEvent('onclick', handle2); // 移除事件 $btn.detachEvent('onclick', handle); 通过attachEvent添加的事件处理程序以添加时的相反顺序触发，移除事件的时候，事件名称和事件处理函数必须与添加的时候相同，匿名函数无法移除 13.2.5 跨浏览器的事件处理程序 恰当的使用能力检测，可以编写跨浏览器的事件处理。要保证处理事件在大多数浏览器下一致运行，只需要关注冒泡阶段。 我们要创建的一个方法是addHandler(),它的职责是分别使用 DOM0 级方法，DOM2 级方法或 IE 方法来添加事件。 addHandler const addHandler = (element, type, handler) => { if (element.addEventListener) { element.addEventListener(type, handler, false); } else if (element.attachEvent) { element.attachEvent(`on${type}`, handler); } else { element[`on${type}`] = handler; } }; removeHandler const removeHandler = (element, type, handler) => { if (element.removeEventListener) { element.removeEventListener(type, handler, false); } else if (element.detachEvent) { element.detachEvent(`on${type}`, handler); } else { element[`on${type}`] = null; } }; 实例 const $btn = document.querySelector('.btn'); const logClassName = function() { console.log(this.className); }; addHandler($btn, 'click', logClassName); addHandler($btn, 'click', function() { console.log('hello world'); }); removeHandler($btn, 'click', logClassName); 13.3 事件对象 在触发 DOM 上的某个事件时，会产生一个事件对象 event，这个对象中包含着所有与事件有关的信息。 例如包含包括事件的元素，事件的类型以及其他特定事件相关的信息。例如鼠标操作导致得事件对象中，会包含鼠标的位置信息，而键盘操作的事件对象中，会包含与按下的键有关的信息，所有的浏览器都支持 event 对象，但支持的方式不同 13.3.1 DOM 中的事件对象 兼容 DOM 的浏览器会将一个 event 对象传入到事件处理程序中，无论指定事件处理程序使用什么方式（DOM0 和 DOM2 级），都会传入 event 对象，如下例子 let $btn = document.querySelector('.box'); const logEventType = event => { console.log(event.type); }; $btn.onclick = logEventType; $btn.addEventListener('click', logEventType, false); 另外以下面这种方式提供 event 对象，可以让 HTML 特性事件处理程序函数执行相同的操作。 &lt;div class=\"box\" onclick=\"console.log(this.innerHTML, event)\">hello world&lt;/div> event 对象包含创建它的特定的事件相关的属性和方法，触发的事件类型不一样，可用的属性和方法也不一样。不过所有的事件都会有下表列出的成员 属性/方法 类型 读/写 说明 bubbles Boolean 只读 表明事件是否冒泡 cancelable Boolean 只读 表明是否可以取消事件的默认行为 currentTarget Element 只读 其事件处理程序当前正在处理事件的那个元素 defaultPrevented Boolean 只读 为 true 表示已经调用了 preventDefault() detail Integer 只读 与事件相关的细节信息 eventPhase Integer 只读 调用事件处理程序的截断：1 表示捕获阶段，2 表示“处于目标”，3 表示冒泡阶段 preventDefault() Function 只读 取消事件的默认行为，如果是 cancelable 是 true，则可以使用这个方法。 stopImmediatePropagation() Function 只读 取消事件的进一步捕获或者冒泡，同事阻止任何事件处理程序被调用。 stopPropagation() Function 只读 取消事件的进一步捕获或者冒泡，如果 bubbles 为 true 则可以使用这个方法 target Element 只读 事件的目标 trusted Boolean 只读 为 true 表示事件是由浏览器生成的，为 false 则表示事件是由开发人员通过 JavaScript 创建的 type String 只读 被触发的事件类型 view AbstractView 只读 与事件关联的抽象视图，等同于发生事件的 window 对象 13.3.2 IE 中的事件对象 与访问 DOM 中的 event 对象不同，要访问 IE 中的 event 对象有几种不同的方式，取决于指定事件处理程序的方法。在使用 DOM0 级方法添加事件处理程序时，event 对象作为 window 对象的一个属性存在。 let $btn = document.querySelector('button'); $btn.onclick = () => { let event = window.event; console.log(event.type); }; 13.3.3 跨浏览器的事件对象13.4 事件类型 web 浏览器中可能发生的事件有很多类型。如前所述，不同的事件类型具有不同的信 ，而 DOM3 级事件，规定了以下几类事件 13.4.1 UI 事件13.4.2 焦点事件13.4.3 鼠标与滚轮事件第 14 章 - 表单脚本学习目标： 理解表单 文本框验证和交互 使用其他表单控制 14.1 表单基础知识 在 HTML 中，表单是由元素来表示的，而在 JavaScript 中，表单对应的元素类型是HTMLFormElement类型，HTMLFormElement继承了HTMLElement，所以除了与其他 html 元素具有的相同属性之外还拥有以下属性。 acceptCharset: 服务器能够处理的字符集，等价于 HTML 中的 accept-charset。 action: 接受请求的 URL，等价于 html 中的 action 特性 enctype： 请求的编码类型，等价于 html 中的 enctype length：表单中控件的数量 method： 要发送的 http 请求的类型，通常是 get 或者 post，等价于 html 中的 method 特性 name：表单的名称，等价于 html 中的 name 属性 reset(): 将表单域重置为默认值 submit(): 提交表单 target: 用于发送请求和接收响应的窗口的名称，等价于 html 中的 target 属性。 获取表单引用的一些方式 通过getElementById方法找到 通过document.forms可以获取到页面中所有的表单，并通过索引或者 name 取得特定的表单。 let forms = document.forms; let firstForm = forms[0]; let myForm = form['form2']; 14.1.1 提交表单 用户点击提交按钮或者图像按钮就会提交表单。使用或者都可以定义提交按钮，只要将其 type 类型的值设置为‘submit’即可。图像按钮则是将的 type 设置为‘image’。 只要表单中存在上面列出的任何一种按钮，那么在相应的表单控件拥有焦点的情况下，按下回车键就可以提交表单(需要注意的是 textarea 是个例外，会换行)，相反没有以上的提交按钮，则不会提交表单 以上三种按钮提交表单的时候，浏览器在将请求发送给服务器前触发 submit 事件，这样我们就有机会可以验证表单数据，并决定是不是允许表单提交 &lt;form action=\"https://github.com/\"> &lt;input type=\"text\" value=\"用户名\" name=\"username\"> &lt;input type=\"password\" value=\"pwd\" name=\"password\"> &lt;input type=\"submit\" value=\"提交表单\"> &lt;/form> let $form = document.forms[0]; let fields = [].slice.call($form.elements); let checkForm = () => { return fields .filter(ele => { return ['text', 'password'].includes(ele.type); }) .every(ele => { return ele.value.length > 6; }); }; $form.addEventListener( 'submit', function(event) { if (checkForm()) { // xxx 通过表单验证 } else { // xxx 没通过 event.preventDefault(); } }, false ); 14.1.2 重置表单 和表单提交有类似，可以通过&lt;input&gt;或者button标签并且type属性为reset来创建重置按钮。它的功能就是将所有的表单字段都恢复到页面刚加载完毕的时候的初始值。同样用户点击充值表单的时候会触发reset事件，我们可以必要的时候取消重置操作 &lt;form action=\"https://github.com/\"> &lt;input type=\"text\" value=\"用户名\" name=\"username\"> &lt;input type=\"password\" value=\"pwd\" name=\"password\"> &lt;!-- 以下两种方式都可以定义重置按钮 --> &lt;input type=\"reset\" value=\"重置表单\"> &lt;!-- &lt;button>重置表单&lt;/button> --> &lt;/form> 稍微修改一下上面的脚本 let $form = document.forms[0]; let fields = [].slice.call($form.elements); let checkForm = () => { return fields .filter(ele => { return ['text', 'password'].includes(ele.type); }) .every(ele => { return ele.value.length > 6; }); }; ['submit', 'reset'].forEach(v => { $form.addEventListener( v, function(event) { if (checkForm()) { // xxx 通过表单验证 } else { // xxx 没通过 event.preventDefault(); } }, false ); }); 当然最后我们也可以通过form.reset()在 js 中手动触发重置操作。 14.1.3 表单字段 表单元素与其他的原生元素一样，可以使用 getElementById 等方式去访问。此外每个表单都有一个 elements 属性，表示表单中所有元素的集合。如果有多个表单控件都在使用一个 name（比如单选按钮），name 就会返回以该 name 命名的一个 NodeList &lt;form action=\"\"> &lt;input type=\"text\" name=\"username\"> &lt;input type=\"text\" name=\"username\"> &lt;input type=\"text\" name=\"pwd\"> &lt;input type=\"radio\" name=\"sex\" value=\"boy\"> &lt;input type=\"radio\" name=\"sex\" value=\"girl\"> &lt;input type=\"submit\"> &lt;/form> let $form = document.forms[0]; let elements = $form.elements; 以下是 elements 变量的取值，可以看到可以通过索引 0,1,2 等形式去访问表单控件，也可以通过 pwd,sex 等命名形式去访问。 共有的表单字段属性 除了元素之外，所有的表单字段都拥有相同的一组属性。比如如下。 disabled:布尔值，表示当前字段是否被禁用。 form：指向当前字段所属表单的指针，只读。 name：当前字段的名称 readOnly：布尔值，表示当前字段是否只读。 tabIndex：表示当前字段的切换号 type：当前字段的类型，如“checkbox”，“radio”等等 value：当前字段被提交给服务器的值，对文件字段来说，这个属性是只读的，包含着文件在计算机中的路径。 除了 form 属性之外，可以通过 js 动态修改其值 共有的表单字段方法 focus(),获取焦点 blur()，失去焦点 需要注意的是，只有表单字段才可以获取焦点，对于其他元素来说，如果先将其 tabIndex 属性设置为-1，然后在调用 focus()方法，也可以让这些元素获得焦点。当前 opera 目前不支持这种技术 共有的表单事件 除了支持鼠标，键盘，更改和 HTML 事件之外，所有表单字段都支持下面三个事件。 blur：当前子弹失去焦点时触发 change：对于 input 和 textarea 元素来说，在他们是去焦点并且值改变时触发，对于 select 元素，在其选项改变时触发， focus：当前字段获得焦点时触发 14.2 文本框脚本 在 HTML 中，&lt;input&gt; 元素和&lt;textarea&gt;元素都表示文本框。这两个空间非常类似，而且大多数的时候行为也差不多，不过还是有一些差别。 对于 input 元素来说可以通过 size 特性来设置能够显示的字符数，通过 value 特性，可以设置初始值。，而 maxlength 则可以指定能够接受的最大字符数。如果要创建一个文本框，让他能够显示 25 个字符，单输入不能超过 50 个字符。可以用如下代码。 &lt;input type=\"text\" size=\"25\" maxlength=\"50\" value=\"initial value\"> 但是对于&lt;textarea&gt;而言，元素始终会呈现为一个多行文本，要指定文本框的大小可以通过 rows 和 cols,rows 表示行数，cols 表示列数。与元素的区别在于其初始值需要放在&lt;textarea&gt;initial value&lt;textarea&gt;之间。并且不能指定最大字符数。 14.2.1 选择文本 上述两种文本框都支持select()方法，这个方法用于选择文本框中的所有文本，在调用select()方法时，大多数浏览器都会讲焦点设置到文本框中。 在文本框获取焦点时选择所有文本，可以让用户不必一个一个删除文本。 1. select 事件 与select()方法对应的是 select 事件，在选择了文本框的文本时就会触发 select 事件。但是什么时候触发会因浏览器而异。在 ie9+，Opera,FireFox，Chrome 和 Safari 中，只有用户选择了文本而且释放了鼠标才会触发 select 事件。但是在 ie8 及更早的版本中只要用户选择了一个字母，不必释放鼠标，就会触发。当然在调用select()方法的时候也会触发该事件。 2. 获取选择的文本 通过selectionStart和selectionEnd表示所选择的文本的范文（即文本选区的开头和结尾的偏移量），就可以知道用户到底选择了啥。 $area.addEventListener( 'select', e => { console.log( $area.value.substring($area.selectionStart, $area.selectionEnd) ); }, false ); 当然该方式是有兼容问题的 3. 选择部分文本 HTML5 中为选择文本框中的部分文本提供了解决方法，即setSelectionRange方法，接收两个参数，要选择地第一个和最后一个字符之后的字符的索引。 14.2.2 过滤输入 我们经常会要求用户在文本框中输入特定格式的数据，比如必须匹配某种模式，我们可以综合运用事件和 DOM 手段，来将普通的文本框转化成能够理解用户输入数据的功能控件。 1. 屏蔽字符 有时候我们需要用户输入的文本中不包含某些字符，这个时候可以给 keypress 事件，阻止这个事件的默认行为来屏蔽此类字符。甚至在某些极端的情况下可以屏蔽掉所有操作。 $keyPress.addEventListener(&#39;keypress&#39;, (e) =&gt; { e.preventDefault() }, false) 2. 操作剪切板 IE 是第一个支持与剪切板相关事件，以及通过 js 访问剪切板数据的浏览器。后来 html5 也把剪切板事件纳入了规范，下面是 6 个剪切板事件。 beforecopy: 在发生复制操作前触发 copy：在发生复制操作时触发 beforecut：在发生剪切操作前触发 cut：在发生剪切操作时触发 beforepaste：在发生粘贴操作前触发 paste：在发生粘贴操作时触发 &lt;div class=\"box\"> &lt;input type=\"text\" class=\"paste-input\"> &lt;/div> let $pasteInput = document.querySelector('.paste-input'); let getClipboardData = e => { let clipboardData = (e || event).clipboardData; return clipboardData.getData('text'); }; let setClipboardData = (e, val) => { let params = e.clipboardData ? 'text/plain' : 'text'; let clipboardData = (e || event).clipboardData; clipboardData.setData(params, val); }; $pasteInput.addEventListener( 'paste', e => { let data = getClipboardData(e); console.log('paste===', data); }, false ); 拿到的兼容事件对象上有一个 clipboardData 属性，这个对象有三个方法，分别是 getData，setData 和 clearData。用于从剪切板中取得数据，他接收一个参数，即要取得的数据的格式，在 ie 中，有两种数据格式：‘text’和‘url’，在 firefox 和 safari 中的 setData 方法不能识别‘text’类型，这两个浏览器在成功将文本放到剪切板中后，都会返回 true，否则返回 false 14.2.3 自动切换焦点 使用 js 可以从多个方面增强表单的易用性，其中，最常见的一种方式就是在用户填写完当前字段的时候，自动将焦点切换到下一个字段。通常在自动切换焦点之前，必须知道用户已经输入了既定的长度的数据（比如电话号码）。 &lt;form action=\"\" name=\"form1\"> &lt;input type=\"text\" name=\"tel1\" maxlength=\"3\"> &lt;input type=\"text\" name=\"tel2\" maxlength=\"4\"> &lt;input type=\"text\" name=\"tel3\" maxlength=\"5\"> &lt;/form> let $form = document.forms['form1']; let getNextInput = e => { let target = (e || event).target; let maxLength = target.maxLength; let val = target.value; let name = target.name; let len = name.length; let nextInputIndex = Number(name[name.length - 1]) + 1; let prefix; if (val.length === maxLength) { prefix = name.slice(0, len - 1); name = `${prefix}${nextInputIndex}`; return $form.elements[name]; } }; $form.addEventListener( 'keyup', e => { let $nextInput = getNextInput(e); if ($nextInput) { $nextInput.focus(); } }, false ); 14.4 表单序列化在浏览器中提交表单之前，浏览器是怎样将数据发送给服务器的,如下说明。 对表单字段的名称和值进行 URL(encodeURIComponent())编码,并使用(&amp;)进行分割 不发送禁用的表单字段 只发送勾选的复选框和单选按钮 不发送 type 为 reset 和 button 的按钮 多选框中每个选中的值单独一个条目 在单击提交按钮提交表单的情况下，也会发送提交按钮；否则不会发送，也包括 type 为 image 的 input 元素 &lt;select&gt;元素的值就是选中的 &lt;option&gt;元素的 value 值，如果&lt;option&gt;元素没有 value 特性则是&lt;option&gt;的文本值 放一张常见的表单提交的 GET 方式各个字段的截图 (1).png 放一张常见的表单提交的 POST 方式各个字段的截图","tags":[{"name":"javascript","slug":"javascript","permalink":"http://coder.liusixin.cn/tags/javascript/"},{"name":"编程笔记","slug":"编程笔记","permalink":"http://coder.liusixin.cn/tags/编程笔记/"},{"name":"javascript高级程序设计","slug":"javascript高级程序设计","permalink":"http://coder.liusixin.cn/tags/javascript高级程序设计/"}]},{"title":"JavaScript高程笔记 （7 - 10章）","date":"2017-04-19T10:32:59.000Z","path":"posts/34aafa83/","text":"第 7 章 - 函数表达式学习目标 函数表达式的特征 使用函数实现递归 使用闭包定义私有变量 定义函数的方式 函数声明（存在函数声明提升，所以可以在函数声明之前调用函数） function fn() { return 'liusixin'; } 函数表达式（声明必须在调用之前） let fn = () => {}; 部分浏览器实现了一个非标准的属性 name，表示函数名字 不要用下面的方式去定义一个函数 不同的浏览器对此解析不同，有的两个都声明了，有的只声明了 a 函数 if (true) { function a() { return 'a'; } } else { function b() { return 'b'; } } 如果想根据不同的条件声明函数可以用函数表达式 var fn = null; if (true) { fn = function() { return 'a'; }; } else { fn = function() { return 'b'; }; } 7.1 递归 递归函数是一个函数通过名字调用自身的情况下构成的。 function recursion(num) { if (num === 1) { return 1; } else { return num * recursion(num - 1); } } 以上定义了一个递归求阶乘的函数，如果我们用下面这种使用方式会怎么样呢？ var fn = recursion; recursion = null; fn(2); // 这个时候就报错了，因为recursion函数内部，调用了recursion本身，但是recurtion已经被赋值为了null。 使用 arguments.callee 他是一个当前正在执行的函数的引用 function recursion(num) { if (num === 1) { return 1; } else { return num * arguments.callee(num - 1); } } var fn = recursion; recursion = null; fn(3); // 6 严格模式下不允许这样用 还有别的方式 var recursion = function f(num) { if (num === 1) { return 1; } else { return num * f(num - 1); } }; var fn = recursion; recursion = null; fn(3); // 2 函数表达式依旧可以给函数取名字 7.2 闭包 一个能够访问另一个函数作用域中变量的函数。 var property = function(key) { return function(obj) { return obj[key]; }; }; var length = property('length'); 以上就是一个经典的闭包，需要注意的是闭包会产生比普通函数更多的内存，所以需要慎用。 7.2.1 闭包与变量 闭包只能取得包含函数中任何变量的最后一个值 var fn = function() { var arrFn = []; var i = 0; for (; i &lt; 10; i++) { arrFn[i] = function() { return i; }; } return arrFn; }; var fns = fn(); 我们以为创建出来的函数数组 fns 会输出 0， 1， 2….，但是实际上只会得到 10，因为闭包只能拿到包含函数中所有变量的最后值。 i 在循环结束的时候已经变成了 10，故所有的函数执行都只能得到 10 如果想得到对应的输出，我们可以用其他的闭包方式,例如 var fn = function() { var arrFn = []; var i = 0; for (; i &lt; 10; i++) { arrFn[i] = (function(num) { return function() { return num; }; })(i); } return arrFn; }; var fns = fn(); 这个时候每个立即执行函数的都有自己的执行环境，而 fns 数组中函数的所形成的闭包自然也可以得到自己的唯一的 num 值了 7.2.2 关于 this 对象 关于闭包能够访问另一个函数的变量，有两个比较特殊 this, arguments var name = 'the window'; var obj = { name: 'the obj', showName: function() { return function() { return this.name; // 注意这里 }; } }; obj.showName()(); // the window 这里打印的是 &#39;the window&#39;，记住 this 和 arguments 两个值比较特殊就可以，如果没有手动将另一个函数的 this 和 arguments 赋值，其得到的还是动态运行的结果，我们看下面的例子就可以明白 var name = 'the window'; var obj = { name: 'the obj', showName: function() { var thatArguments = arguments; var that = this; return function() { console.log(thatArguments); console.log(that.name); console.log(this.name); }; } }; obj.showName()(); WX20180716-190424-2x.png 7.2.3 内存泄漏 javascript 中常见的有两种垃圾回收机制，其中引用计数就是造成内存泄漏的罪魁祸首。 标记清除 引用计数 通过以下例子简单的回顾一下两种垃圾回收机制 function problem() { var a = {}; var b = {}; a.otherObj = b; b.otherObj = a; } 标记清除 当变量进入环境（比如在函数中声明一个变量）的时候就讲这个变量标记为进入环境，当变量离开环境的时候，则将其标记为离开环境 上面那个例子中，当函数结束的时候，两个对象都离开了作用域，因此这种相互引用不是个问题 引用计数 首先引用清除的含义是记录每个值被引用的次数 当声明了一个变量并将一个引用类型的值赋值给该变量时这个值的引用次数就是 1 如果同一个值又被赋给了另外一个变量则该值的引用次数加 1 相反如果包含这个值引用的变量又取得了另外一个值,则这个值的引用次数减 1 当这个值的引用次数为 0 的时候，则释放其所占空间 上面那个例子中，a 和 b 通过各自的属性相互引用，从而造成两个空对象的引用计数都为 2.当函数结束之后，a 和 b 将继续存在，因为两个空对象的引用次数不可能为 0，当这种情况出现的多了，将有大量的空间被占用得不到释放。 接下里看一下闭包的使用中可能因为引用计数机制造成内存泄漏问题 function assignHandler() { var ele = document.getElementById('id'); ele.onclick = function() { console.log(ele.id); }; } 这个函数创建了一个作为 ele 元素事件处理程序的闭包，这个闭包中又创建了一个循环引用，只要事件处理程序(匿名函数)一直存在，则 ele 的引用计数至少为 1 因此 ele 所占用的内存空间永远得不到释放，可以通过以下的例子解决该问题 function assignHandler() { var ele = document.getElementById('id'); var id = ele.id; ele.onclick = function() { console.log(id); // 消除循环引用 }; ele = null; // 减少引用次数 } 7.3 模仿块级作用域 js 中没有块级作用域的概念，只有函数和全局作用域，那么这意味着，在块语句中定义的变量实际上是在包含函数中而非语句中创建的。举个例子 注意： js 中使用 var 如果对同一个变量进行声明，其实会对后续的声明视而不见，但是会执行后续声明中的初始工作 function outputNum(num) { for (var i = 0; i &lt; num; i++) { console.log(i); } console.log(i); // 在java、c++类的语言中，这里是会报错的，因为i只在上面的for循环中起效 } 所以说变量的声明是在包含函数中，也就是上面的 outputNum 函数体中，而不是在语句中,比如上面的 for 循环中，那么如果用函数表达式来模拟块级作用域呢？很简单，用一个立即执行函数包裹起来就可以 function outputNum(num) { (function() { for (var i = 0; i &lt; num; i++) { console.log(i); } })(); console.log(i); // Uncaught ReferenceError: i is not defined } 为什么(function () {})()可以模仿块级作用域呢？ 匿名函数中定义的任何变量都会在其执行结束时销毁，这也是为什么 i 只能在循环中使用的原因。 这种技术也经常被用在限制向全局作用域中添加过多的变量和函数，从而避免全局污染 7.4 私有变量 js 中没有私有成员的概念，所有对象的属性都是公有的，不过倒是有一个私有变量的概念，任何在函数中定义的变量都是私有变量。私有变量包括函数的参数、局部变量、函数内部定义的其它函数。 function add(num1, num2) { var sum = num1 + num2; return sum; } 函数的外部没有任何方法能够访问 add 函数的内部私有变量 sum1、sum2 和 sum。利用闭包的性质，我们可以创建能够访问私有变量的公有方法(也叫做特权方法)。 有两种在对象上创建特权方法的方法。 在构造函数中定义特权方法。 function MyObject() { // 私有私有变量和函数 var privateVariable = 10; function privateFunction() { return false; } this.publicMethod = function() { privateVariable++; return privateFunction(); }; } 利用私有和特权成员可以隐藏那些不应该被直接修改的数据。 使用构造函数模式来创建特权方法的缺点是必须要用构造函数模式来达到这个目的，而且每个实例都会创建相同的一组方法，而使用静态私有变量来实现特权方法可以避免这个问题。 7.4.1 静态私有变量7.4.2 模块模式7.4.3 增强的模块模式第 8 章 - BOM学习目标 理解 window 对象–BOM 的核心 控制窗口、框架和弹出窗口 利用 location 对象的页面信息 使用 navigator 对象了解浏览器 8.1 window 对象 BOM 的核心对象是 window，它表示浏览器的一个实例，在浏览器中，window 对象有双重角色，它既是通过 JavaScript 访问浏览器窗口的一个接口，也是 ECMAScript 规范的 Global 对象，这意味着在网页中定义任何一个对象，变量或者函数，都以 window 作为 Global 对象，因此有权访问 parseInt 等方法 8.1.1 全局作用域 所有在全局作用域中声明的变量、函数都会变成 window 对象的属性和方法。 var age = 29; function sayAge() { alert(this.age); } alert(window.age); sayAge(); window.sayAge(); age 和 sayAge 都被自动归在了 window 对象名下，所以可以通过 window.age 和 window.sayAge 访问 非常重要 定义全局变量与在 window 对象上直接定义属性的差别是：全局变量不能通过 delete 操作符删除，而直接在 window 对象上的定义的属性可以。 第 9 章 - 客户端检测学习目标 使用能力检测 用户代理检测的历史 选择检测的方式 前言 各大浏览器在实现公共接口方面投入了很多精力，但是结果仍然是每一种浏览器都有各自存在不一致性的问题，面对普遍不一致的问题，开发人员要么采取迁就各方的“最小公分母”策略，要么就得利用各种客户端的检测方法，来突破或者规避种种局限。 9.1 能力检测 最常用也是最为人们广泛接受的客户端检测形式是能力检测，能力检测的目标不是识别特定的浏览器，而是识别浏览器的能力，采用这种形式不必顾忌特定的浏览器是如何如何，只要确定浏览器支持的特定的能力，就可以给出解决方案，举个例子。 在 IE5 之前的版本不支持 document.getElementById()这个 DOM 方法，尽管可以使用非标准的 document.all 属性实现相同的功能，但是 IE 早期的版本中，确实不存在前面那个方法，于是就有了下面的能力检测代码。 function getElement(id) { if (document.getElementById) { return document.getElementById(id); } else if (document.all) { return document.all[id]; } else { throw new Error('No way to retrieve element!'); } } 这里的 getElement 函数的用途是返回具有给定 ID 的元素，因为 document.getElementById 是实现这一目的的标准，所以一开始就检测了这个方法，如果该函数不存在就继续监测 document.all 是否存在，如果是就使用，如果两个特性都不满足，则创建一个错误并抛出。表示这个函数没有办法使用 主要要理解能力检测，首先必须要理解两个重要的概念。 先检测达成目的的最常用的特性，可以保证代码最优化。因为在多数情况下，都可以避免测试多个条件。 必须检测实际要用到的特性，一个特性存在并不意味着另外一个特性也存在。 function getWindowWith() { if (document.all) { return document.documentElement.clientWidth; // 错误的使用例子 } else { return window.innerWidth; } } 上面是一个错误使用能力检测的例子，检测document.all是否存在，并不意味着document.documentElement.clientWith也存在。 9.1.1 更可靠的能力检测 能力检测对于想知道某个特性是否会按照适当的方式行事（而不仅仅是某个特性存在）非常有用。 function isSortable(object) { return !!object.sort; } 这个函数通过检测对象是否存在 sort 方法，来确定是否支持排序，问题是包含 sort 属性的对象也会返回 true let result = isSortable({ sort: true }); // true 检测某个属性是否存在并不能确定对象是够支持排序，更好的方式是检测 sort 是不是一个函数。 function isSortable(object) { return typeof object.sort === 'function'; } 在可能的情况下，要尽量用 typeof 进行能力检测，特别是，宿主对象没有义务让 typeof 返回合理的值，最令人发指的是事就发生在 ie 中，大多数浏览器在检测到document.createElement()存在时多会返回 true function hasCreateElement() { return typeof document.createElement === 'function'; } 但是在 ie8 及其之前的版本中，这个函数返回 false，因为typeof document.createElement返回的是 object 而不是 function,本质原因是 DOM 对象是宿主对象，IE 及其更早的版本中的宿主对象是 COM 对象，所以 typeof 才会返回 object，IE9 纠正了这个问题，对所有的 DOM 方法都返回 function. 再举个例子了解一下 typeof 的的行为不准确性。 ActiveX 对象（只有 IE 支持）与其他对象的行为差异很大。 let xhr = new ActiveXObject('Microsoft.XMLHttp'); if (xhr.open) { // xxx } 直接把函数当做属性访问会导致 js 错误，所以使用 typeof 操作符会更加安全一些。但是有一个问题是typeof xhr.open会返回 unknow 9.1.2 能力检测，不是浏览器检测 检测某个或者某几个特性并不能确定浏览器，下面的代码就是错误地依赖能力检测的典型示例。 let isFirefox = !!(navigator.vendor &amp;&amp; navigator.vendorSub); let isIE = !!(document.all &amp;&amp; document.uniqueID); 这两行代码代表了对能力检测的典型勿用，以前确实可以通过检测 navigatorv.vendor 和 navigator.vendorSub 来确定 firefox 浏览器，但是别的浏览器也会实现相同的功能，所以检测自然会出现问题。 9.2 怪癖检测 与能力检测类似，怪癖检测的目标是识别浏览器的特殊行为，但与能力检测确认浏览器支持什么能力不同，怪癖检测是想要知道浏览器存在什么缺陷，这通常需要运行一段代码，以确定某一特性不能正常工作。 IE8 之前有一个 bug，即如果某个实例属性与标记为[[DontEnum]] 的某个原型属性同名，name 该实例属性将不会出现在 for in 循环当中。使用以下代码来检测。 let hasDontEnumQuick = (() => { let o = { toString() {} }; for (let prop in o) { if (prop === 'toString') { return false; } } return true; })(); Safari3 以前的浏览器版本会枚举被隐藏的属性，可以用下面的代码检测该怪癖 let hasEnumShadowQuick = (() => { let o = { toString() {} }; let count = 0; for (let prop in o) { if (prop === 'toString') { count++; } } return count > 1; })(); 如果浏览器存在这个 bug，那么 for in 循环枚举带有自定义的 toString 方法的对象，就会返回两个 toString 的实例。 一般来说“怪癖”检测是个别浏览器所独有的，而且通常被归为 bug，建议仅检测那些对你有直接影响的怪癖，而且最好是在脚本一开始就执行此类检测，以便尽早解决问题 9.3 用户代理 第三种方式，也是争议最大的一种客户端检测方式叫做用户代理检测。用户代理检测通过检测用户代理字符串来确定实际使用的浏览器。 因为存在浏览器通过再自己的用户代理字符串中添加一些错误或者误导的信息来达到欺骗的目的。其优先级排在能力检测和怪癖检测之后。 第 10 章 - DOM DOM（文档对象模型），是针对 HTML 和 XML 文档的一个 API，DOM 描述了一个层次化的节点树，允许开发人员添加，移除,修改页面的某一部分。 学习目标 理解包含不同层次节点的 DOM 使用不同的节点类型(一般是元素节点，文本节点，文档碎片，文档节点等) 克服浏览器的兼容性问题及各种陷阱 节点的类型 接下来会简要的总结常见的几种节点类型以及其相关的知识点 Node 类型 DOM1 定义了一个 Node 借口，所有的元素都有nodeType属性，nodeType可取得值有 12 中，常见和经常用的有以下几种 1 (元素节点) 3 (文本节点) 9 (文档节点) 11 (文档碎片 DocumentFragment) childNodes 每个节点都有childNodes属性，其保存着一种类数组对象，用于保存一组有序的节点，可以用下标方式去访问，也可以用item方法去访问,当然也要注意，childNodes属性有浏览器的兼容问题，ie 下只包含其子节点中为元素节点的子元素，其他浏览器则还包括元素节点 var eles = someNode.childNodes var len = eles.length var firstChild = ele[0] or eles.item(0) var lastChild = eles[len - 1] or eles.item(len - 1) 节点之间的关系 节点之间的关系是多样的，两个节点之间可以父子节点，祖孙节点，兄弟节点等等 previousSibling nextSibling firstChild lastChild 当一个列表中只存在一个节点，那么previousSibling和nextSibling都为 null firstChild和lastChild也分别指向第一个和最后一个子节点 操作节点 我们可以用appendChild、insertBefore、replaceChild来进行常见的节点之间的操作 appendChild() parentNode.appendChild(childNode) 将 childNode 节点添加到 parentNode 节点末尾 如果 childNode 节点已经在文档中存在，则从原来的位置移动到 parentNode 的末尾。 insertBefore() parentNode.insertBefore(要插入的节点, 作为参照的节点) 如果作为参照的节点不为 null，则要插入的节点最终会插入到作为参照的节点前面。 如果作为参照的节点为 null，则其作用与 appendChild 类似 该方法执行之后返回要插入的节点 replaceChild() parentNode.replaceChild(要插入的节点, 要替换的节点) 要插入的节点如果是原来已经存在，则从原来的位置移动到要替换的节点位置前面 removeChild() parentNode.removeChild(childNode)","tags":[{"name":"javascript","slug":"javascript","permalink":"http://coder.liusixin.cn/tags/javascript/"},{"name":"编程笔记","slug":"编程笔记","permalink":"http://coder.liusixin.cn/tags/编程笔记/"},{"name":"javascript高级程序设计","slug":"javascript高级程序设计","permalink":"http://coder.liusixin.cn/tags/javascript高级程序设计/"}]},{"title":"JavaScript高程笔记 （4 - 6章）","date":"2017-04-18T06:01:01.000Z","path":"posts/6ed649de/","text":"红宝书读过之后很多知识点都忘了，写此博文来重新复习下之前比较模糊的知识点。 第 4 章 - 变量、作用域和内存问题学习目标 理解基本类型和引用类型的值 理解执行环境 理解垃圾收集 JavaScript 松散类型的本质，决定了它只是在特定时间用于保存特定的值的一个名字而已。由于不存在定义某个变量必须保存何种数据类型值的规则，变量的值，及其数据类型可以在脚本的声明周期内改变。 4.1 基本类型和引用类型的值js 中包括两种不同数据类型的值 基本类型值 (undefined null string number boolean) 引用类型值 (对象) 4.1.1 动态属性这节说了一个问题，只能给引用类型的值动态地添加属性，不能给基本类型的值添加。 4.1.2 复制变量值两种数据类型，除了保存方式不一样之外，在从一个变量向另一个变量复制基本类型值和引用类型值时，也存在不同。 1.如果从一个变量向另一个变量复制基本类型的值，会在变量对象上创建一个新值，然后把该值复制到为新变量分配的位置上。 var num1 = 5; var num2 = num1; 当用一个变量向另一个变量复制引用类型的值的时候，同样也会将存储在变量对象中的值复制一份放到新变量分配的空间中，不同的是，这个值的副本实际上是一个指针，而这个指针指向存储在堆中的一个对象，复制操作结束之后，两个变量实际上将引用同一个对象。所以只要改变其中一个变量就会影响到另一个变量。 var obj1 = new object(); var obj2 = obj1; obj1.name = 'liusixin'; alert(obj.name); // liusixin 基本原理看下图 4.1.3 传递参数 ECMAScript 中所有函数的参数都是按值传递的，也就是说，把函数外部的值复制给函数内部的参数，就和把值从一个变量复制到另一个变量一样。 理解上面这句话，大概就可以理解 js 中的传参机制了，还有可以可以把函数的参数想象成局部变量。 4.1.4 检测类型 要检测一个变量是不是基本数据类型的？typeof 是得力的工具，更具体一些旧事 typeof 可以确定一个变量是 string、number、boolean、还是 undefined，但是 null 会返回 object。 4.2 执行环境及作用域4.2.1 延长作用域 try catch with 没有块级作用域 在类似 C 语言中，由花括号封闭的代码块都有自己的作用域，因而支持根据条件来定义变量。 if (true) { var color = 'blue'; } alert(color); // blue 如果在类似 c 语言中，if 执行之后变量 color 会被销毁，但是在 js 中会被添加到当前的执行环境中。 声明函数 使用 var 声明的变量会自动添加到最接近的环境中，在函数内部，最接近的环境就是函数局部环境，在 with 语句中，最接近的环境是函数环境，如果初始化的时候没有制定 var 声明，该变量就会被添加到全局环境中。 查询标志符 说白了就是 js 在查找变量的过程是逐级向上的。 var color = 'blue'; function getColor() { return color; } alert(getColor()); // blue 4.3 垃圾收集 JavaScript 有自动的垃圾回收机制，执行环境会自动管理代码执行过程中使用的内容。 找出那些不再继续使用的变量，然后释放其占用的内存。为此，垃圾收集器会按照固定的时间间隔周期性地执行这一操作 垃圾回收机制一般有两种，标记清除 引用计数 4.3.1 标记清除基本原理 当变量进入环境(例如： 声明一个变量)，就将这个变量标记为”进入环境”，当变量离开环境时将其标志为”离开环境” 4.3.2 引用计数基本原理 引用计数的含义是跟踪记录每个值被引用的次数。 当声明了一个变量并将一个引用类型的值赋给该变量时，则这个值的引用次数就是 1，如果同一个值又被赋给另一个变量，则该引用次数又加一. 相反如果包含这个值引用的变量又取得了另外一个值，则这个值的引用次数减一。 当这个值的引用次数变成 0 的时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。 引用计数带来的问题 function problem() { var objectA = new object(); var objectB = new object(); objectA.somOtherObject = objectB; objectB.somOtherObject = objectA; } 这个例子中两个对象通过各自的属性相互引用，导致这两个对象的引用次数都是 2，且永远不可能为 0。在用标记清除的策略中，函数执行完成之后，两个对象都离开的作用域，所以循环引用不是问题。 ie 中的麻烦 ie 中的 BOM 和 DOM 对象不是 JavaScript 对象，而是使用 c++以 COM(Component Object Model 组件对象模型)对象形成的。但是 COM 对象的垃圾收集机制是引用计数，所以即使 ie 的 JavaScript 引擎是使用标记清楚策略来实现的，但是因为存在上面的问题，依然会有循环引用带来的问题。 var element = document.getElementById('some_element'); var myObject = new Object(); myObject.element = element; element.someObject = myObject; 为了避免以上问题，应该手动断原声 js 对象与 DOM 元素之间的连接 myObject.element = null; element.someObject = null; 性能问题 主要说垃圾回收机制周期处理时间 管理内存 将不用的变量手动设置为 null，解除引用关系。 第 5 章 - 引用类型学习目标 使用对象 创建并操作数组 理解基本的 JavaScript 类型 使用基本类型和基本包装类型 5.1 Object 类型 大多数引用类型的值都是 Object 类型的实例，而且 Object 也是 ECMAScript 中使用最多的一个类型。 创建对象的方式 使用 new 操作符后跟 Object 构造函数 var person = new Object(); person.name = 'liusixin'; person.sex = 'boy'; 对象字面量表示法(定义对象的一种简写形式) var person = { name: 'liusixin', sex: 'boy' }; 注意对象的最后一个属性后面不是说不能加逗号，是在部分浏览器例 IE7 及更早版本下会报错，所以最好不要写 访问对象的方式 一般有两种 点表示法(obj.name) 方括号表示法(obj[&#39;name&#39;]) 两种方式都可以但是如果属性名中包含会导致语法错误的字符，或者属性使用的是关键字或保留字，也可以使用方括号表示法(这个时候使用点表示法就报错了) 当然了除非必须使用方括号表示法不然建议使用点表示法 5.2 Array 类型创建数组的方式有两种 使用 Array 的构造函数 var colors = new Array(); 如果事先知道数组的长度可以传一个数字，并且该数字会变成该数组 length 属性的值。 var colors = new Array(20); 当然也可以向数组传入应该包含的项 var colors = new Array('red', 'green'); 所以当你向构造函数传递一个值的时候，如果这个值是数值，那么会创建给定项数的数组。如果传递的是其他类型参数，则会创建包含那个值的只有一项的数组。 另外创建数组也可以省去 new 操作符。 创建数组的第二种基本方式是数组字面量表示法 var colors = ['red', 'green']; var names = []; var values = [1, 2]; // 不要这样，这样会创建包含2或3项的数组 var options = [, , , , ,]; // 不要这样，这样会创建包含5或6项的数组 注意不要像第二行以及第三行那样创建数组，在 ie 中 values 是包含 3 个项且值分别为 1， 2， undefined 的数组 在读取或者设置数组的值时，要使用方括号并提供索引基于 0 的数字索引. var colors = ['red', 'blue', 'green']; alert(colors[0]); colors[2] = 'black'; // 修改第三项 colors[3] = 'brown'; // 新增第四项 当设置的索引大于数组现有的项数的时，数组就会自动增加到该索引加一的长度(其实不然应该是索引值需小于 4294967295) 数组的 length 可读可写，通过设置 length 属性可以从数组的末尾移除项或者向数组中添加项。 var colors = ['red', 'green', 'blue']; colors.length = 2; alert(colors[2]); // undefined 利用 length 属性也可以很方便的添加新项 var colors = ['red', 'blue']; colors[colors.length] = 'black'; colors[colors.length] = 'pink'; colors[100] = 'grey'; // 4 ~ 99 都是undefined 特别注意数组最多可以包含 4294967294 个项，如果添加的项数超过这个数，可能会导致错误 5.2.1 检测数组 对于一个网页或者一个全局作用域而言，使用 instanceof 即可 if (value instanceof Array) { // } 当然这样判断是有缺陷的，如果使用 iframe 形式嵌入网页，那么至少存在两个以上的全局执行环境，从而存在两个以上不同版本的 Array 构造函数。这样第一个框架与第二个框架分别具有不同的构造函数，(具体验证可以看 examples/第五章-引用类型/iframe 父窗口.html) 也可以利用 Object.prototype.toString 来判断 var isArray = function(obj) { return obj == null ? false : Object.prototype.toString.call(obj) === '[object Array]'; }; 还可以借助 es5 中的新 apiArray.isArray() if (Array.isArray(obj)) { // xxx } 5.2.2 转换方法以下是数组的三个转换方法 valueOf(返回的是数组本身,即是相同的引用) toString(返回数组中每个值的字符串形式拼接形成的一个以逗号分隔的字符串) toLocaleString(与 toString 类似，不过是调用数组的每一项的 toString 方法) var person = { name: 'liusixin', toString() { return this.name; }, toLocaleString() { return `${this.name}-boy`; } }; var people = [person]; alert(people); // liusixin alert(people.toString()); // liusixin alert(people.toLocaleString()); // liusixin-boy 有一个疑问，如下，既然是调用数组的每一项的 toString、toLocaleString 方法拼接成的字符串,为什么下面不报错呢？内部做了兼容？(null 没有 toString 和 toLocaleString 方法) var arr = ['liusixin', null]; arr.toString(); // liusixin, arr.toLocaleString(); // liusixin, 5.2.3 栈方法 数组提供的 push 和 pop 方法可以让其像其他数据结构一样，完成(LIFO)后进先出的表现。 push - 可以接收任意的参数，把它们逐个添加到数组的末尾，并返回修改后数组的长度 pop - 删除数组最后一项，并返回移除的项 var colors = new Array(); var count = colors.push('red', 'green'); // 2 count = colors.push('black'); // 3 var item = colors.pop(); // 'black' 当然我们也可以向这样使用 push var arr = ['a', 'b']; arr.push.apply(arr, ['c', 'd']); console.log(arr); // [\"a\", \"b\", \"c\", \"d\"] 甚至可以像数组一样，在对象上使用 push 方法 let push = Array.prototype.push; let obj = { length: 0, addItem() { push.apply(this, arguments); // 使用apply可以支持一次性传入多个选项 } }; obj.addItem('hello'); obj.addItem('world'); obj.addItem({ age: 25 }); obj.addItem('liusixin', 'sex'); 5.2.4 队列方法 利用 shift 和 push 可以模仿队列(FIFO)的数据结构形态。 shift - 删除数组的第一个项并返回该项 var colors = new Array(); var count = colors.push('red', 'green'); // 2 var item = colors.shift(); // red 当然可以使用 unshift 和 pop 实现相反方向的队列结构 unshift - 在数组的前端添加任意个项并返回新数组的长度 var colors = new Array(); var count = colors.unshift('red', 'green'); // 2 var item = colors.pop(); // green 当然我们也可以向这样使用 unshift var arr = ['c', 'd']; arr.unshift.apply(arr, ['a', 'b']); console.log(arr); // [\"a\", \"b\", \"c\", \"d\"] 5.2.5 重排序方法数组排序主要关注两个原生支持的方法 reverse - 反转数组，会影响原数组,并且返回值为原数组的引用 var values = [1, 2, 3, 4, 5]; var tempArr = values.reverse(); // [5, 4, 3, 2, 1] values === tempArr; // true sort - sort 方法会调用每个数组项的 toString 方法，然后比较得到的字符串,即使是数字比较的也是字符串，以确定如何排序, 会改变原数组 var values = [0, 1, 5, 10, 15]; values.sort(); // [0, 1, 10, 15, 5] 有人会对结果有疑问，我们看一张图 所以为了得到真正的排序后的结果，从小到大或者从大到小我们可以像下面这样做 var values = [1, -3, 0, 5, 10, 1, 34, 2]; // 从小到大 values.sort((a, b) => a - b); // 从大到小 values.sort((a, b) => b - a); 5.2.6 操作方法 concat() - 基于当前的数组中的所有项创建一个新的数组，具体来说就是先创建当前数组的一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组。 如果没有传参数，只是简单地对当前数组的拷贝 如果传递的是一个或者多个数组，则该方法会将这些数组中的所有项都添加到该数组中 如果传递的不是数组，这些值就会简单地添加到数组的末尾 var colors = ['red']; var colors2 = colors.concat('yellow', ['green']); // [\"red\", \"yellow\", \"green\"] concat 方法并不修改调用它的对象(this 指向的对象) 和参数中的各个数组本身的值,而是将他们的每个元素拷贝一份放在组合成的新数组中.原数组中的元素有两种被拷贝的方式: 对象引用(非对象直接量):concat 方法会复制对象引用放到组合的新数组里,原数组和新数组中的对象引用都指向同一个实际的对象,所以,当实际的对象被修改时,两个数组也同时会被修改. 字符串和数字(是原始值,而不是包装原始值的 String 和 Number 对象): concat 方法会复制字符串和数字的值放到新数组里. var arr = [1, { name: 'liusixin' }]; var arr2 = arr.concat([{ sex: 'boy' }]); arr2[0] = 'a'; // 没有修改arr[0]的值 arr2[1].name = 'Karl'; // 此时也修改了arr[1]的值 slice() - 方法返回一个从开始到结束（不包括结束）选择的数组的一部分浅拷贝到一个新数组对象。原始数组不会被修改 如果没有传参数则表示对当前数组的一个浅拷贝 如果传递了一个参数则返回从该参数指定的位置开始到当前数组末尾所有的项。 如果传递了两个参数则返回起始位置到结束位置的所有的项(不包含结束位置) 特别提示：如果有一个值为负值，则利用数组长度加上该值来确定相应的位置,比如下面的例子得到的结果是相同的 var arr = [1, 2, 3, 4, 5]; var arr2 = arr.slice(-2, -1); var arr3 = arr.slice(3, 4); splice() - 该方法可谓强大，可以实现 删除、插入、替换 等功能，且直接改变原数组的内容,通过以下例子来说明其用法 array.splice(start) array.splice(start, deleteCount) array.splice(start, deleteCount, item1, item2, ...) splice 使用举例 var colors = ['red', 'green', 'blue']; // 1. 删除第一项(删除) var removed = colors.splice(0, 1); // removed是一个数组，包含删除的项 [\"red\"] // 2. 从第一个位置开始插入两项(插入) removed = colors.splice(1, 0, 'yellow', 'orange'); // 如果没有删除，返回的是一个空数组[] // 3. 替换 removed = colors.splice(1, 1, 'red'); 5.2.7 位置方法es5 中添加了两个位置方法： indexOf lastIndexOf 这两个方法都接收两个参数，要查找的项和(可选的)表示查找起点位置的索引，执行后的返回值都是表示要查找的项在数组中的位置，在找到则返回-1.并且比较使用的是严格比较（即值和类型都要相等）。 关于第二个参数特别注意下面这段话 开始查找的位置。如果该索引值大于或等于数组长度，意味着不会在数组里查找，返回-1。如果参数中提供的索引值是一个负值，则将其作为数组末尾的一个抵消，即-1 表示从最后一个元素开始查找，-2 表示从倒数第二个元素开始查找 ，以此类推。 注意：如果参数中提供的索引值是一个负值，仍然从前向后查询数组。如果抵消后的索引值仍小于 0，则整个数组都将会被查询。其默认值为 0. 5.2.8 迭代方法es5 中添加了 5 个迭代方法，每个方法都接收两个参数，要在每一项上运行的函数和运行该函数的执行上下文(影响内部的 this 值)，而传入的函数会接收三个值(数组的项，该项的索引，以及数组本身) every() - 对数组中的每一个项运行给定的函数，如果该数组的每一项都返回 true，那么结果也返回 true) some() - 对数组中的每一项运行给定的函数，如果该项对任一项返回 true，就返回 true forEach() - 对数组中的每一项运行给定的函数，该函数没有返回值 map() - 对数组中的每一项运行给定的函数，返回每次调用函数的结果组成的数组 filter() - 对数组的每一项运行给定的函数，返回该函数返回 true 的项组成的数组 特别注意 注意： 没有办法中止或者跳出 forEach 循环，除了抛出一个异常。如果你需要这样，使用 forEach()方法是错误的，你可以用一个简单的循环作为替代。如果您正在测试一个数组里的元素是否符合某条件，且需要返回一个布尔值，那么可使用 Array.every 或 Array.some。如果可用，新方法 find() 或者 findIndex() 也可被用于真值测试的提早终止。 使用举例 var arr = [1, 2, 3, 4, 5, 4]; // forEach arr.forEach( function(v, i, array) { console.log(v, i, array, this); }, { name: 'liusixin' } ); // every arr.every(v => { return v &lt; 0; }); // some arr.some(v => { return v > 1; }); // map arr.map(v => { return `${v}-hello`; }); // filter arr.filter(v => { return v > 3; }); 5.3 Date 类型5.4 RegExp 类型5.5 Function 类型函数实际上是对象，每个函数都是 Function 的实例，而且都与其它引用类型一样具有属性和方法。由于函数是对象，所以函数名也是指向函数对象的指针，不会与某个函数绑定。 定义函数的方式 函数声明 function sum(num1, num2) { return num1 + num2; } 函数表达式 var sum = function(num1, num2) { return num1 + num2; }; 使用 Function 构造函数(这种方式平时用到比较少) Function 构造函数可以接收任意数量的参数，但最后一个参数指的是函数体，前面的参数则是新函数的参数。 var sum = new Function('num1', 'num2', 'return num1 + num2'); 函数名其实仅仅是指向函数的指针，因此函数名与包含对象指针的其它变量没有什么不同，也就是说函数可能会有多个名字 5.5.1 没有重载(深入理解) 将函数想象为指针，有助于理解为什么函数没有重载的概念。 var addSum = function() { return 1; }; var addSum = function() { return 2; }; 5.5.2 函数声明与函数表达式 解析器在向执行环境中加载数据时，对函数声明和函数表达式并不是一视同仁，解析器会率先读取函数声明（存在函数声明提升），并使其在执行任何代码之前可用，而函数表达式，则是必须等到解析器执行到它所在的代码行，才会真正地被执行。 alert(sum(10, 10)); // 20 function sum(num1, num2) { return num1 + num2; } alert(fn()); // 报错 var fn = function() { return 1; }; 第 6 章 - 面向对象的程序设计学习目标 理解对象属性 理解并创建对象（重要） 理解继承(重要) 概述 面向对象(OO)的语言都有类的概念，而通过类可以创建任意多个具有相同属性和方法的对象，js 中的对象是”无序属性的集合，其属性可以包含基本值，对象或者函数” 6.1 理解对象创建自定义对象的 2 种常见方式 创建一个 Object 的实例 var person = new Object(); person.name = 'liusixin'; person.sayName = function() { alert(this.name); }; 对象字面量创建 var person = { name: 'liusixin', sayName: function() { alert(this.name); } }; 6.1.1 属性类型 数据属性 访问器属性 数据属性 数据属性包含一个数据值的位置，在这个位置可以读取和写入值，数据属性有 4 个描述其行为的特性。 [[Configurable]] : 表示 1. 能否通过delete删除属性重而重新定义属性。 2. 能否修改属性的特性，3. 能否把属性修改为访问器属性，使用 new Object 或对象字面量，默认值为 true [[Enumerable]] : 表述能否通过 for in 循环返回属性，使用 new Object 或对象字面量，默认值为 true [[Writable]] : 表述能否修改属性的值，使用 new Object 或对象字面量，默认值为 true [[Value]] : 包含这个属性的数据值，读取属性值的时候，从这个位置读，写入属性值的时候，把新值保存到这个位置。这个特性的默认值为 undefined。 经过测试，通过 Object.defineProperty 定义对象的属性 Configurable、Enumerable、Writable 默认值都是 false，而 Value 没有设置则是 undefined 可以多次调用 Object.defineProperty() 方法修改同一属性，但在把 configurable 特性设置为 false 之后就会有限制了。 访问器属性 访问器属性不包括数据值，包含一堆 getter 和 setter 函数（这两个函数不是必须的）。在读取属性的时，会调用 getter 函数，这个函数负责返回有效值，在写入访问器属性时，会调用 getter 函数并传入新值，这个函数负责决定如何处理数据。分别有以下属性 [[Configurable]] : 表示 1 能否通过delete删除属性重而重新定义属性，2. 能否修改属性的特性，3. 能否把属性修改为访问器属性,使用 new Object 或对象字面量，默认值为 true [[Enumerable]] : 表述能否通过 for in 循环返回属性，使用 new Object 或对象字面量，默认值为 true [[Get]] : 在读取属性时调用的函数，默认值为 undefined [[Set]] : 在写入属性时调用的函数，默认值为 undefined 访问器属性不能直接定义，必须使用 Object.defineProperty 定义。 var book = { _year: 2004, edition: 1 }; Object.defineProperty(book, 'year', { get: function() { return this._year; }, set: function(newValue) { if (newValue > 2004) { this._year = newValue; this.edition += newValue - 2004; } } }); book.year = 2005; alert(book.edition); 不一定 get 和 set 函数都要指定，只指定 get，意味着只能读不能写，只指定 set，意为着只能写不能读 同样我们可以使用 __defineGetter__ 和 __defineSetter__ 来做一些 get、set 的事情 var book = { _year: 2004, edition: 1 }; book.__defineGetter__('year', function() { return this._year; }); book.__defineSetter__('year', function(newValue) { if (newValue > 2004) { this._year = newValue; this.edition += newValue - 2004; } }); 6.1.2 定义多个属性 Object.defineProperties()一次描述多个属性。 var book = {}; Object.defineProperties(book, { _year: { value: 2004, writable: true // 不指定将不可写 }, edition: { value: 1, writable: true }, year: { get: function() { return this._year; }, set: function(newValue) { if (newValue > 2004) { this._year = newValue; this.edition += newValue - 2004; } } } }); 6.2 创建对象 使用 Object 构造函数和对象字面量的形式来创建对象有一个明显的缺点，使用同一个接口创建很多对象，会产生很多垃圾代码。 创建对象的各种模式 创建对象的模式有很多种，比如工厂模式、构造函数模式、原型模式、混合构造函数和原型模式等等，这里做主要的代码示例和介绍。 6.2.1 工厂模式 工厂模式是软件工程领域一种广为人知的设计模式，这种模式抽象了创建具体对象的过程，用函数来封装以特定接口来创建对象的细节。 function createPerson(name, sex, age) { let o = new Object(); o.name = name; o.sex = sex; o.age = age; o.sayName = function() { console.log(this.name); }; return o; } let p1 = createPerson('liusixin', 'boy', 100); let p2 = createPerson('hahaha', 'girl', 1000); createPerson 函数能够根据传入的参数来构建包含三个所有必要信息的 Person 对象,可以无数次的调用这个函数，而它每次都会返回包含三个属性的一个方法的对象。工厂模式虽然解决了创建多个相似对象的代码冗余问题，但是却没有解决对象识别的问题。 6.2.2 构造函数模式 构造函数可以用来创建特定类型的对象，有些类似 Array 和 Object 在运行时就自动出现在执行环境中，此外，也可以自定义构造函数。从而自定义对象类型的属性和方法。 function Person(name, sex, age) { this.name = name; this.sex = sex; this.age = age; this.sayName = function() { console.log(this.name); }; } let p1 = new Person('liusixin', 'boy', 100); let p2 = new Person('hahaha', 'girl', 1000); 跟工厂模式相比可以发现，有以下区别 没有显示地创建对象 直接将属性和方法赋给了 this 对象 没有 return 语句 构造函数名字使用首字母大写 创建 Person 实例大概经历了以下几步 创建一个新的对象 将构造函数的作用域赋值给新对象（因此 this 就指向了这个新对象） 执行构造函数中的代码（为这个新对象添加属性） 返回新的对象 创建自定义的构造函数意味着可以将它的实例标记为一种特定的类型，这也是其胜过工厂模式的地方","tags":[{"name":"javascript","slug":"javascript","permalink":"http://coder.liusixin.cn/tags/javascript/"},{"name":"编程笔记","slug":"编程笔记","permalink":"http://coder.liusixin.cn/tags/编程笔记/"},{"name":"javascript高级程序设计","slug":"javascript高级程序设计","permalink":"http://coder.liusixin.cn/tags/javascript高级程序设计/"}]}]
<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
    
<!-- Google Analytics -->
<script>
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
ga('create', 'UA-122482867-1', 'auto');
ga('send', 'pageview');
</script>
<script async src="https://www.google-analytics.com/analytics.js"></script>
<!-- End Google Analytics -->


    

    
<!-- Baidu Tongji -->
<script>var _hmt = _hmt || []</script>
<script async src="//hm.baidu.com/hm.js?88b44a330a5d21f560b4f94e1d71f0fe"></script>
<!-- End Baidu Tongji -->




    <meta charset="utf-8">
    
    
    <link rel="canonical" href="http://coder.liusixin.cn/posts/3d2ababd/">
    
    <link rel="canonical" href="http://coder.liusixin.cn/posts/3d2ababd/">
    
    
    <title>Javascript面向对象总结 | Sixin的小站 | 刘思鑫的个人博客</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="javascript,编程笔记">
    <meta name="description" content="本文内容是复习红宝书中面向对象章节以及各类博客的总结篇  前言对象(Object)应该算是 js 中最为重要的部分，也是 js 中非常难懂晦涩的一部分。更是面试以及框架设计中出没。 对象属性属性类型简单的说，对象拥有四个属性:  [[Configurable]]:是否可以通过 delete 删除，能否修改属性的特性。直白点：是否可配置，默认为 true [[Enumerable]]:枚举性，表示">
<meta name="keywords" content="javascript,编程笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="Javascript面向对象总结">
<meta property="og:url" content="http://coder.liusixin.cn/posts/3d2ababd/index.html">
<meta property="og:site_name" content="Sixin的小站">
<meta property="og:description" content="本文内容是复习红宝书中面向对象章节以及各类博客的总结篇  前言对象(Object)应该算是 js 中最为重要的部分，也是 js 中非常难懂晦涩的一部分。更是面试以及框架设计中出没。 对象属性属性类型简单的说，对象拥有四个属性:  [[Configurable]]:是否可以通过 delete 删除，能否修改属性的特性。直白点：是否可配置，默认为 true [[Enumerable]]:枚举性，表示">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2017-10-15T05:32:32.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Javascript面向对象总结">
<meta name="twitter:description" content="本文内容是复习红宝书中面向对象章节以及各类博客的总结篇  前言对象(Object)应该算是 js 中最为重要的部分，也是 js 中非常难懂晦涩的一部分。更是面试以及框架设计中出没。 对象属性属性类型简单的说，对象拥有四个属性:  [[Configurable]]:是否可以通过 delete 删除，能否修改属性的特性。直白点：是否可配置，默认为 true [[Enumerable]]:枚举性，表示">
    
        <link rel="alternate" type="application/atom+xml" title="Sixin的小站" href="/atom.xml">
    
    <link rel="shortcut icon" href="/favicon.ico">
    <link rel="stylesheet" href="//unpkg.com/hexo-theme-material-indigo@latest/css/style.css">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide">
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(http://cdn-blog.liusixin.cn/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="http://cdn-blog.liusixin.cn/coder-1.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">刘思鑫</h5>
          <a href="mailto:fordreamxkhl@gmail.com" title="fordreamxkhl@gmail.com" class="mail" rel="external nofollow noopener noreferrer" target="_blank">fordreamxkhl@gmail.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/">
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives">
                <i class="icon icon-lg icon-archives"></i>
                归档
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags">
                <i class="icon icon-lg icon-tags"></i>
                标签
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories">
                <i class="icon icon-lg icon-th-list"></i>
                分类
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/chain">
                <i class="icon icon-lg icon-users"></i>
                友情链接
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/about">
                <i class="icon icon-lg icon-user-o"></i>
                关于我
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/lsxlsxxslxsl" target="_blank" rel="external nofollow noopener noreferrer">
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://juejin.im/user/599d4bfc51882511264e7865" rel="external nofollow noopener noreferrer" target="_blank">
                <i class="icon icon-lg icon-angle-double-down"></i>
                掘金
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">Javascript面向对象总结</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">Javascript面向对象总结</h1>
        <h5 class="subtitle">
            
                <time datetime="2017-10-15T05:32:32.000Z" itemprop="datePublished" class="page-time">
  2017-10-15
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/前端/">前端</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#前言"><span class="post-toc-number">1.</span> <span class="post-toc-text">前言</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#对象属性"><span class="post-toc-number">2.</span> <span class="post-toc-text">对象属性</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#属性类型"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">属性类型</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#访问器属性"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">访问器属性</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#创建对象"><span class="post-toc-number">3.</span> <span class="post-toc-text">创建对象</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#工厂模式"><span class="post-toc-number">3.1.</span> <span class="post-toc-text">工厂模式</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#构造函数模式"><span class="post-toc-number">3.2.</span> <span class="post-toc-text">构造函数模式</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#原型模式"><span class="post-toc-number">3.3.</span> <span class="post-toc-text">原型模式</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#组合使用构造函数和原型模式"><span class="post-toc-number">3.4.</span> <span class="post-toc-text">组合使用构造函数和原型模式</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#继承"><span class="post-toc-number">4.</span> <span class="post-toc-text">继承</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#基于类的面向对象和基于原型的面向对象方式比较"><span class="post-toc-number">4.1.</span> <span class="post-toc-text">基于类的面向对象和基于原型的面向对象方式比较</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#原型链"><span class="post-toc-number">4.2.</span> <span class="post-toc-text">原型链</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#借用构造函数"><span class="post-toc-number">4.3.</span> <span class="post-toc-text">借用构造函数</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#组合继承"><span class="post-toc-number">4.4.</span> <span class="post-toc-text">组合继承</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#别的继承模式"><span class="post-toc-number">4.5.</span> <span class="post-toc-text">别的继承模式</span></a></li></ol></li></ol>
        </nav>
    </aside>


<article id="post-前端/javascript/Javascript面向对象总结" class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">Javascript面向对象总结</h1>
        <div class="post-meta">
            <time class="post-time" title="2017-10-15 13:32:32" datetime="2017-10-15T05:32:32.000Z" itemprop="datePublished">2017-10-15</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/前端/">前端</a></li></ul>



            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style="display:none">
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <blockquote>
<p>本文内容是复习红宝书中面向对象章节以及各类博客的总结篇</p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>对象(Object)应该算是 js 中最为重要的部分，也是 js 中非常难懂晦涩的一部分。更是面试以及框架设计中出没。</p>
<h2 id="对象属性"><a href="#对象属性" class="headerlink" title="对象属性"></a>对象属性</h2><h3 id="属性类型"><a href="#属性类型" class="headerlink" title="属性类型"></a>属性类型</h3><p>简单的说，对象拥有四个属性:</p>
<ul>
<li><code>[[Configurable]]</code>:是否可以通过 delete 删除，能否修改属性的特性。直白点：是否可配置，默认为 true</li>
<li><code>[[Enumerable]]</code>:枚举性，表示是否可以通过 for-in 循环返回，默认为 true</li>
<li><code>[[Writable]]</code>:可写性：是否可以修改属性的值，默认为 true</li>
<li><code>[[Value]]</code>:包含属性的值，也就是对应的可读性。 默认为 undefined</li>
</ul>
<blockquote>
<p>如果要修改属性默认的特性，必须通过<code>Object.defineProperty()</code>方法。大致如下：</p>
</blockquote>
<pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> animal <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>animal<span class="token punctuation">,</span><span class="token string">"name"</span><span class="token punctuation">,</span><span class="token punctuation">{</span>
  writable<span class="token punctuation">:</span><span class="token boolean">false</span><span class="token punctuation">,</span>
  value<span class="token punctuation">:</span> <span class="token string">'dog'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>animal<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//dog</span>
animal<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'cat'</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>animal<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//dog</span>
</code></pre>
<p>从上面的实例大家也能看出，在调用<code>Object.defineProperty()</code>方法后，如果不指定 <code>configurable</code>、<code>enumerable</code>、<code>writable</code> 特性的值时，默认为 FALSE。</p>
<h3 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h3><blockquote>
<p>访问器属性不包含数据值，但是包含 getter 和 setter 函数。在读取访问器属性时，会调用 getter 函数，这个函数负责返回有效值。在写入访问器属性时，回到用 setter 函数并传入新值。</p>
</blockquote>
<ul>
<li><code>[[Configurable]]</code>:表示是否可以通过 delete 删除。默认为 TRUE</li>
<li><code>[[Enumerable]]</code>:同上面介绍的 Enumerable 一样，默认为 true</li>
<li><code>[[Get]]</code>:读取数据时候调用的方法。默认为 undefined</li>
<li><code>[[Set]]</code>:在写入属性值得时候默认调用的方法。默认为 undefined</li>
</ul>
<p>看个例子（来自于红宝石）:</p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> book <span class="token operator">=</span> <span class="token punctuation">{</span>
  _year<span class="token punctuation">:</span> <span class="token number">2012</span><span class="token punctuation">,</span>
  edition<span class="token punctuation">:</span> <span class="token number">1</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>book<span class="token punctuation">,</span> <span class="token string">'year'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_year<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token keyword">set</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token operator">></span> <span class="token number">2012</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>_year <span class="token operator">=</span> value<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>edition<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

book<span class="token punctuation">.</span>year <span class="token operator">=</span> <span class="token number">2013</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>book<span class="token punctuation">.</span>edition<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 2</span>
</code></pre>
<p>其实对于多个属性的定义，我们可以使用<code>Object.defineProperties</code>方法。然后对于读取属性的特性我们可以使用<code>Object.getOwnPropertyDescriptor()</code>方法。详细内容可以自行查看</p>
<h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><p>创建对象，我们不是直接可以通过 Object 的构造函数或者对象字面量的方法来实现对象的创建嘛？当然是可以的，但是有一个明显的缺点：使用同一个接口创建很多对象，产生大量重复的代码，我们引用设计模式。</p>
<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>一种很基础的设计模式，简而言之就是用函数来封装以特定接口创建对象的细节。</p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">createAnimal</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> type<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> o <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  o<span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
  o<span class="token punctuation">.</span>type <span class="token operator">=</span> type<span class="token punctuation">;</span>
  o<span class="token punctuation">.</span>sayName <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> o<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> cat <span class="token operator">=</span> <span class="token function">createAnimal</span><span class="token punctuation">(</span><span class="token string">'小猫'</span><span class="token punctuation">,</span> <span class="token string">'cat'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> dog <span class="token operator">=</span> <span class="token function">createAnimal</span><span class="token punctuation">(</span><span class="token string">'小狗'</span><span class="token punctuation">,</span> <span class="token string">'dog'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<blockquote>
<p>优点：可以无数次的调用这个函数，来创建相似对象。 缺点：不能解决对象识别的问题。实际项目中可以参考弹出层的设计。</p>
</blockquote>
<h3 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h3><p>ECMAScript 中的构造函数可以用来创建特定类型的对象。在运行时会自动出现在执行环境中。</p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Animal</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> type<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>type <span class="token operator">=</span> type<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>sayName <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> cat <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Animal</span><span class="token punctuation">(</span><span class="token string">'小猫'</span><span class="token punctuation">,</span> <span class="token string">'cat'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> dog <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Animal</span><span class="token punctuation">(</span><span class="token string">'小狗'</span><span class="token punctuation">,</span> <span class="token string">'dog'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>注意上面我们没有显示的 return 过一个对象出来，为什么？因为 this。</p>
<p>关于构造函数惯例首字母大写不用多说。强调构造函数一定要使用关键字 new 来调用。new 的过程：</p>
<ul>
<li>创建一个新的对象</li>
<li>将构造函数的作用域赋值给新对象（this 执行新的对象）</li>
<li>执行构造函数的代码</li>
<li>返回新的对象</li>
</ul>
<p>在实例对象中，都有一个 constructor 属性。</p>
<pre class=" language-js"><code class="language-js">cat<span class="token punctuation">.</span>constructor <span class="token operator">==</span> Animal<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//true</span>
dog<span class="token punctuation">.</span>constructor <span class="token operator">==</span> Animal<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//true</span>
cat <span class="token keyword">instanceof</span> <span class="token class-name">Animal</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//true</span>
dog <span class="token keyword">instanceof</span> <span class="token class-name">Animal</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//true</span>
</code></pre>
<p>构造函数模式的优点如上所说，但是缺点还是有的，比如说</p>
<pre class=" language-js"><code class="language-js">cat<span class="token punctuation">.</span>sayName <span class="token operator">==</span> dog<span class="token punctuation">.</span>sayName<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//false</span>
</code></pre>
<p>也就是说，他创建了两个功能一样的函数，这样是很没有必要的，当然，我们可以把 say 放到构造函数外面，然后通过<code>this.sayName = sayName</code>来操作，但是这样的话，又会导致全局变量的污染。怎么办？</p>
<h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p>我们在创建每一个函数的时候都有一个 prototype(原型)属性，这个属性是一个指针，指向一个对象。而这个对象的用途就是包含由特定类型的所有实例共享的属性和方法。</p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Animal</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
Animal<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'毛毛'</span><span class="token punctuation">;</span>
Animal<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>type <span class="token operator">=</span> <span class="token string">'dog'</span><span class="token punctuation">;</span>
Animal<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>sayName <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> cat <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Animal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> dog <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Animal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">alert</span><span class="token punctuation">(</span>cat<span class="token punctuation">.</span>sayName <span class="token operator">==</span> dog<span class="token punctuation">.</span>sayName<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true</span>
</code></pre>
<p>原型模式的好处就是可以让所有的对象实例共享他的属性和方法。不必在构造函数中定义对象实例的信息。</p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
Person<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'Liusixin'</span><span class="token punctuation">;</span>
Person<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">26</span><span class="token punctuation">;</span>
Person<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>sayName <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> man <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>man<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 'Liusixin' -> 来自原型</span>
man<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'Liu'</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>man<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Liu -> 来自实例</span>

<span class="token keyword">delete</span> man<span class="token punctuation">.</span>name<span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>man<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 'Liusixin' -> 来自原型</span>
</code></pre>
<p>上面的例子说明两点</p>
<ul>
<li>原型中的对象属性可以被实例所覆盖重写</li>
<li>通过 delete 可以删除实例中的属性，但是删除不了原型对象上的</li>
</ul>
<blockquote>
<p>我们可以通过<code>hasOwnProperty()</code>方法来确定一个属性是在原型上还是在实例上。<code>man.hasOwnProperty(&#39;name&#39;)</code>,如果 name 为实例属性，则返回 true。 我们也可以通过 <code>&#39;name&#39; in man</code> 来确定，man 上是否有 name 这个属性。</p>
</blockquote>
<p>上面大家可能已将发现，这种原型模式的写法非常的繁琐，有了大量的 XXX.prototype. 这里有一种简写的形式。 参照具体说明参照阮神的博客 <a href="http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance.html" rel="external nofollow noopener noreferrer" target="_blank">Javascript 面向对象编程（二）：构造函数的继承</a></p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
Person<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token punctuation">{</span>
  constructor<span class="token punctuation">:</span> Person<span class="token punctuation">,</span>
  name<span class="token punctuation">:</span> <span class="token string">'Liusixin'</span><span class="token punctuation">,</span>
  age<span class="token punctuation">:</span> <span class="token number">26</span><span class="token punctuation">,</span>
  job<span class="token punctuation">:</span> <span class="token string">'web Engineer'</span><span class="token punctuation">,</span>
  <span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
<blockquote>
<p>上面代码特意添加了一个<code>constructor</code>属性，因为每创建一个函数，就会自动创建他的<code>prototype</code>对象，这个对象会自动获取<code>contractor</code>属性。而我们这中写法，本质上重写了默认的<code>prototype</code>对象，因此，<code>constructor</code>属性也就变成新的对象的<code>constructor</code>属性了（指向 Object 构造函数），所以这里的简写方式，一定要加上<code>constructor</code>。</p>
</blockquote>
<p>下面我们再谈一谈原型模式的优缺点。</p>
<p>优点，正如上面我们说到的，可以省略为构造函数传递出实体参数这个环节，并且很多实例可以共享属性和方法。正是因为原型中所有的属性是被所有的实例所共享的，这个特性在方法中非常实用，但是对于包含引用类型的属性来说问题就比较突出了。</p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

Person<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token punctuation">{</span>
  constructor<span class="token punctuation">:</span> Person<span class="token punctuation">,</span>
  name<span class="token punctuation">:</span> <span class="token string">'liusixin'</span><span class="token punctuation">,</span>
  friends<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'xiaohong'</span><span class="token punctuation">,</span> <span class="token string">'xiaoming'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> person1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> person2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

person1<span class="token punctuation">.</span>friends<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'xiaohua'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">alert</span><span class="token punctuation">(</span>person1<span class="token punctuation">.</span>friends<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 'xiaohong','xiaoming','xiaohua'</span>
<span class="token function">alert</span><span class="token punctuation">(</span>person2<span class="token punctuation">.</span>friends<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 'xiaohong','xiaoming','xiaohua'</span>
<span class="token function">alert</span><span class="token punctuation">(</span>person1<span class="token punctuation">.</span>friends <span class="token operator">==</span> person2<span class="token punctuation">.</span>friends<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true</span>
</code></pre>
<blockquote>
<p>由于 friends 数组存在于<code>Person.prototype</code>上，并不是 person1 上，所以当我们修改的时候，其实修改的是所有实例所共享的那个值。</p>
</blockquote>
<h3 id="组合使用构造函数和原型模式"><a href="#组合使用构造函数和原型模式" class="headerlink" title="组合使用构造函数和原型模式"></a>组合使用构造函数和原型模式</h3><p>这是创建自定义类型最常见的一种方式。就是组合使用构造函数和原型模式.构造函数模式用于定义实力属性，原型模式用于定义方法和共享的属性。</p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

Person<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token punctuation">{</span>
  constructor<span class="token punctuation">:</span> Person<span class="token punctuation">,</span>
  <span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> person1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'Liu'</span><span class="token punctuation">,</span> <span class="token number">26</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> person2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'Sixin'</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">...</span>
</code></pre>
<blockquote>
<p>上面的例子中，实例所有的属性都是在构造函数中定义，而实例所有共享的属性和方法都是在原型中定义。这种构造函数和原型模式混合的模式，是目前 ECMAScript 中使用最为广泛的一种方法。</p>
</blockquote>
<p>当然，有些人会觉得独立的构造函数和原型非常的难受，所以也有推出所谓的动态原型构造模式的这么一说。</p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token keyword">this</span><span class="token punctuation">.</span>sayName <span class="token operator">!==</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Person<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>sayName <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token operator">...</span>
</code></pre>
<blockquote>
<p>注意上面的代码，之后在 sayName 不存在的时候，才会在原型上给他添加相应的方法。因为对原型的修改，能够立即在所有的实例中得到反应。所以这中做法确实也是非常的完美。</p>
</blockquote>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><blockquote>
<p>说到面向对象，当然得说到继承。说到继承当然得说到原型。说到原型，这里我们参考一篇博文：<a href="https://www.ibm.com/developerworks/cn/web/1304_zengyz_jsoo" rel="external nofollow noopener noreferrer" target="_blank">全面理解面向对象的 JavaScript</a></p>
</blockquote>
<p>首先什么是 javascript 面向对象呢</p>
<ol>
<li>一切事物皆对象。</li>
<li>对象具有封装和继承特性。</li>
<li>对象与对象之间使用消息通信，各自存在信息隐秘。</li>
</ol>
<p>js 语言是通过一种叫做原型(prototype) 的方式来实现面向对象编程的。当然，还有比如 java 就是基于类来实现面向对象编程的。</p>
<h3 id="基于类的面向对象和基于原型的面向对象方式比较"><a href="#基于类的面向对象和基于原型的面向对象方式比较" class="headerlink" title="基于类的面向对象和基于原型的面向对象方式比较"></a>基于类的面向对象和基于原型的面向对象方式比较</h3><p>对于基于类的面向对象的方式中，对象依靠 class 类来产生。而在基于原型的面向对象方式中，对象则是依靠构造器(constructor)利用原型(prototype)构造出来的。举个客观世界的例子来说，例如工厂造一辆汽车一方面，工人必须参照一张工程图纸，设计规定这辆车如何制造，这里的工程图纸就好比语言中的类 class。而车就是按照这个类制造出来的。另一方面，工人和机器相当于 contractor，利用各种零部件(prototype)将汽车造出来。</p>
<p>首先，客观世界中的对象的产生都是其他实物对象构造的世界，而抽象的图纸是不能产生出汽车的。也就是说，类，是一个抽象概念的而非实体，而对象的产生是一个实体的产生。其次，按照一切事物皆对象的面向对象的法则来说，类本身并不是一个对象，然而原型方式的构造函数和原型本身也是个对象。再次，在类的面向对象语言中，对象的状态为对象的实例所持有，对象的行为方法则由申明该对象的类所持有，并且只有对象的构造和方法能够被继承。而在原型的面向对象语言中，对象的行为、状态都属于对象本身，并且能够一起被继承。</p>
<h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><blockquote>
<p>ECMAScript 描述了原型链的概念，并将原型链作为实现继承的主要方法。基本思想就是利用原型让一个引用类型继承另一个引用类型的属性和方法。</p>
</blockquote>
<p>实现原型链有一种基本模式：</p>
<pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">SuperType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>property <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

SuperType<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>getSuperValue <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>property<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">SubType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>subproperty <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

SubType<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SuperType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

SubType<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>getSubValue <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>subproperty<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">alert</span><span class="token punctuation">(</span>instance<span class="token punctuation">.</span><span class="token function">getSuperValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>在上面的代码中，我们没有使用 SubType 默认提供的原型，而是给它换了一个新的原型，这个新原型就是 SuperType 的实例。于是，新原型不仅具有所谓一个 SuperType 的实例所拥有的全部属性和方法，而且其内部还有一个指针，指向 SuperType 的原型。最终结果是这样的：instance 指向 subtype 的原型，subtype 的原型又指向 SuperType 的原型。</p>
<p>通过实现原型链，本质上是扩展了原型搜索机制。</p>
<p>虽然如上，我们已经实现了 javascript 中的继承。但是依旧存在一些问题：最主要的问题来自包含引用类型的原型。第二个问题就是在创建子类型的实例时，不能向超类型的构造函数中传递参数。这两个问题上面也都有说到，这里就不做过多介绍，直接看解决办法:</p>
<h3 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h3><blockquote>
<p>在解决原型中包含引用类型的数据时，我们可以在子类型构造函数内部调用超类型的构造函数。直接看代码：</p>
</blockquote>
<pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">SuperType</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>colors <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'red'</span><span class="token punctuation">,</span> <span class="token string">'yellow'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">SubType</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">// 继承了Super</span>
  SuperType<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> instance1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubType</span><span class="token punctuation">(</span><span class="token string">'Liu'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>instance1<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
instance1<span class="token punctuation">.</span>colors<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'black'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>instance1<span class="token punctuation">.</span>colors<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 'red','yellow','black'</span>

<span class="token keyword">const</span> instance2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubType</span><span class="token punctuation">(</span><span class="token string">'sixin'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>instance2<span class="token punctuation">.</span>colors<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 'red','yellow'</span>
</code></pre>
<p>毕竟函数只不过是在特定环境中执行代码的对象，因此可以通过 call 或者 apply 方法在新创建的对象上执行构造函数。而且如上代码也解决了子类构造函数中向超类构造函数传递参数的问题</p>
<p>但是，这样问题就来了，类似我们之前讨论创建的对象那种构造函数的问题：如果都是使用构造函数，那么，也就避免不了方法都在构造函数中定义，然后就会产生大量重复的代码了。</p>
<h3 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h3><blockquote>
<p>因为考虑到上述的缺点，所以这里又使用了组合继承的方式，历史总是惊人的相似。直接看代码：</p>
</blockquote>
<pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">SuperType</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>colors <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'red'</span><span class="token punctuation">,</span> <span class="token string">'yellow'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

SuperType<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>sayName <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">SubType</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">// 继承属性</span>
  SuperType<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 继承方法</span>
SubType<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SuperType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
SubType<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> SubType<span class="token punctuation">;</span>
SubType<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>sayAge <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> instance1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubType</span><span class="token punctuation">(</span><span class="token string">'Liusixin'</span><span class="token punctuation">,</span> <span class="token number">26</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
instance1<span class="token punctuation">.</span>colors<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'white'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
instance1<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Liusixin</span>
instance1<span class="token punctuation">.</span><span class="token function">sayAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 26</span>

<span class="token keyword">const</span> instance2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubType</span><span class="token punctuation">(</span><span class="token string">'Liu'</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">alert</span><span class="token punctuation">(</span>instance2<span class="token punctuation">.</span>colors<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 'red','yellow'</span>
instance2<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Liu</span>
instance2<span class="token punctuation">.</span><span class="token function">sayAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 20</span>
</code></pre>
<p>在上面的例子中，SuperType 构造函数定义了两个属性，name 和 colors，SuperType 的原型中定义了一个方法 sayName，subtype 的构造函数中调用 SuperType 构造函数并且传入 name，然后将 SuperType 的实例赋值给 subtype 的原型。然后又在新的原型中定义了 sayAge 的方法。这样一来，就可以让两个不同的 SubType 实例既分别拥有自己的属性，包括 colors，又可以使用相同的方法了。</p>
<blockquote>
<p>组合继承避免了原型链和借用构造函数的缺陷，融合了他们的优点。成为 javascript 中最为常见的继承模式。而且<code>instanceof</code>和<code>isPrototypeOf</code>方法也能用于识别组合模式创建的对象。</p>
</blockquote>
<h3 id="别的继承模式"><a href="#别的继承模式" class="headerlink" title="别的继承模式"></a>别的继承模式</h3><p>继承模式不止上面几种，这里只是说到常见的继承模式。还有原型式继承、寄生式继承、寄生组合式继承等，其实，只要理解了原型、原型链、构造函数等对象的基本概念，理解起来这中模式都是非常容易的。</p>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2017-10-15T05:32:32.000Z" itemprop="dateUpdated">2017-10-15 13:32:32</time>
</span><br>


        
    </div>
    
    <footer>
        <a href="http://coder.liusixin.cn">
            <img src="http://cdn-blog.liusixin.cn/coder-1.jpg" alt="刘思鑫">
            刘思鑫
        </a>
    </footer>
</blockquote>

        


        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/">javascript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/编程笔记/">编程笔记</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://coder.liusixin.cn/posts/3d2ababd/&title=《Javascript面向对象总结》 — Sixin的小站&pic=http://cdn-blog.liusixin.cn/coder-1.jpg" data-title="微博" rel="external nofollow noopener noreferrer">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://coder.liusixin.cn/posts/3d2ababd/&title=《Javascript面向对象总结》 — Sixin的小站&source=刘思鑫的个人博客" data-title=" QQ" rel="external nofollow noopener noreferrer">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://coder.liusixin.cn/posts/3d2ababd/" data-title=" Facebook" rel="external nofollow noopener noreferrer">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《Javascript面向对象总结》 — Sixin的小站&url=http://coder.liusixin.cn/posts/3d2ababd/&via=http://coder.liusixin.cn" data-title=" Twitter" rel="external nofollow noopener noreferrer">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://coder.liusixin.cn/posts/3d2ababd/" data-title=" Google+" rel="external nofollow noopener noreferrer">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/posts/b48d1f6c/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">JavaScript设计模式--面向对象的JS</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/posts/d446ebaa/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">JS的变量、作用域和内存问题</h4>
      </a>
    </div>
  
</nav>



    











    <!-- Valine Comments -->
    <div class="comments vcomment" id="comments"></div>
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script>
    <!-- Valine Comments script -->
    <script>
        var GUEST_INFO = ['nick','mail','link'];
        var guest_info = 'nick,mail,link'.split(',').filter(function(item){
          return GUEST_INFO.indexOf(item) > -1
        });
        new Valine({
            el: '#comments',
            notify: 'false' == 'true',
            verify: 'false' == 'true',
            appId: "2WXGXLypM4zFckxtGM4xyoQe-gzGzoHsz",
            appKey: "muMuDGGs0nePJORgEeCJmgWA",
            avatar: "mm",
            placeholder: "说点什么吧...",
            guest_info: guest_info.length == 0 ? GUEST_INFO : guest_info,
            pageSize: "10"
        })
    </script>
    <!-- Valine Comments end -->







</article>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style="display:none">
        总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style="display:none">
        总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <!-- <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>博客内容遵循 <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
        </p> -->
    </div>
    <div class="bottom">
        <p><span>刘思鑫 &copy; 2017 - 2020</span>
            <span>
                
                <a href="http://www.miitbeian.gov.cn/" target="_blank" rel="external nofollow noopener noreferrer">京ICP备17054400号-1</a><br>
                
                <!-- Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a> -->
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://coder.liusixin.cn/posts/3d2ababd/&title=《Javascript面向对象总结》 — Sixin的小站&pic=http://cdn-blog.liusixin.cn/coder-1.jpg" data-title="微博" rel="external nofollow noopener noreferrer">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://coder.liusixin.cn/posts/3d2ababd/&title=《Javascript面向对象总结》 — Sixin的小站&source=刘思鑫的个人博客" data-title=" QQ" rel="external nofollow noopener noreferrer">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://coder.liusixin.cn/posts/3d2ababd/" data-title=" Facebook" rel="external nofollow noopener noreferrer">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《Javascript面向对象总结》 — Sixin的小站&url=http://coder.liusixin.cn/posts/3d2ababd/&via=http://coder.liusixin.cn" data-title=" Twitter" rel="external nofollow noopener noreferrer">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://coder.liusixin.cn/posts/3d2ababd/" data-title=" Google+" rel="external nofollow noopener noreferrer">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAK4AAACuCAAAAACKZ2kyAAAB0UlEQVR42u3aQW6DQAwFUO5/aSp11SoCvm2YsHisoopMXzbWtz3bFj/77/P5+fOdv0/y/vbEg4uLO+bup88R9/OfHb1TPfPofVxc3PXcpHgdEc9L0jmxXOxwcXFfxr0rGI1iEC4u7su4SUw571Z6DRUuLu63uEmjkrcr59GnehouLu567jyszD8vmu/i4uKOtxLVgpK3N3vrwcXFXcM9KijVaJIUqV6E2pJ+CBcX91ZuPvg4L2rzpiWR4OLiruH2rkn1RiS9pWx5youLizvmzq9MJdEkL3wXPwwXF3cJt7oQvWtdWv2pF0EHFxf3Vm61oFQbm/mSdbQNxsXFHXB7w4teSBqtXXFxcV/Dzdeu1XCTp7B/EQcXF/dhbi+gJOOPSbOEi4v7Xe68rPQuY+V/wcXFXc8ttx/jximJQRffwsXFfZibR5C81ane+yisWnFxcRdy86PnZWtU/nBxcRdy77p61TunsLjFxcVdwu2tV/MBR17Uepe9cHFxn+P2ildvBpNf3LzhNhkuLu6YWy1eeWDKT4iqLC4u7su4eQCanHxxAi4u7ou5T1zMiqIVLi7uQm5vuFldmlZbo9FYBBcXd8CtDkzz5iePR+VyhouL+xT3B09vV66sOJtxAAAAAElFTkSuQmCC" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: false };


lazyScripts.push('//s95.cnzz.com/z_stat.php?id=1274200658&web_id=1274200658')

</script>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/main.min.js"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/search.min.js" async></script>






<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>





</body>
</html>
